---
title: Consideraciones de rendimiento de EF4, EF5 y EF6
author: divega
ms.date: 10/23/2016
ms.assetid: d6d5a465-6434-45fa-855d-5eb48c61a2ea
ms.openlocfilehash: c87c1412cb23abf232663d7e4f44eef5f7818ea2
ms.sourcegitcommit: 5e11125c9b838ce356d673ef5504aec477321724
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 10/25/2018
ms.locfileid: "50022394"
---
# <a name="performance-considerations-for-ef-4-5-and-6"></a><span data-ttu-id="de3cf-102">Consideraciones de rendimiento para EF 4, 5 y 6</span><span class="sxs-lookup"><span data-stu-id="de3cf-102">Performance considerations for EF 4, 5, and 6</span></span>
<span data-ttu-id="de3cf-103">Por David Obando, Eric Dettinger y otros</span><span class="sxs-lookup"><span data-stu-id="de3cf-103">By David Obando, Eric Dettinger and others</span></span>

<span data-ttu-id="de3cf-104">Fecha de publicación: Abril de 2012</span><span class="sxs-lookup"><span data-stu-id="de3cf-104">Published: April 2012</span></span>

<span data-ttu-id="de3cf-105">Última actualización: mayo de 2014</span><span class="sxs-lookup"><span data-stu-id="de3cf-105">Last updated: May 2014</span></span>

------------------------------------------------------------------------

## <a name="1-introduction"></a><span data-ttu-id="de3cf-106">1. Introducción</span><span class="sxs-lookup"><span data-stu-id="de3cf-106">1. Introduction</span></span>

<span data-ttu-id="de3cf-107">Marcos de asignación relacional de objetos son una manera cómoda de proporcionar una abstracción para el acceso a datos en una aplicación orientada a objetos.</span><span class="sxs-lookup"><span data-stu-id="de3cf-107">Object-Relational Mapping frameworks are a convenient way to provide an abstraction for data access in an object-oriented application.</span></span> <span data-ttu-id="de3cf-108">Para aplicaciones. NET, Microsoft recomienda QUE O/RM es Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="de3cf-108">For .NET applications, Microsoft's recommended O/RM is Entity Framework.</span></span> <span data-ttu-id="de3cf-109">Sin embargo, con cualquier abstracción de rendimiento puede volverse un problema.</span><span class="sxs-lookup"><span data-stu-id="de3cf-109">With any abstraction though, performance can become a concern.</span></span>

<span data-ttu-id="de3cf-110">Estas notas del producto se escribieron para mostrar las consideraciones de rendimiento al desarrollar aplicaciones con Entity Framework, para dar una idea de los algoritmos internos de Entity Framework que puede afectar al rendimiento de los desarrolladores y para proporcionar sugerencias para la investigación y mejorar el rendimiento en aquellas aplicaciones que usan Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="de3cf-110">This whitepaper was written to show the performance considerations when developing applications using Entity Framework, to give developers an idea of the Entity Framework internal algorithms that can affect performance, and to provide tips for investigation and improving performance in their applications that use Entity Framework.</span></span> <span data-ttu-id="de3cf-111">Hay un número de temas buen rendimiento ya disponibles en la web, y también hemos intentado que apunta a estos recursos, siempre que sea posible.</span><span class="sxs-lookup"><span data-stu-id="de3cf-111">There are a number of good topics on performance already available on the web, and we've also tried pointing to these resources where possible.</span></span>

<span data-ttu-id="de3cf-112">El rendimiento es un tema complicado.</span><span class="sxs-lookup"><span data-stu-id="de3cf-112">Performance is a tricky topic.</span></span> <span data-ttu-id="de3cf-113">Estas notas del producto está pensado como un recurso para ayudar a realizar rendimiento relacionados con las decisiones para las aplicaciones que usan Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="de3cf-113">This whitepaper is intended as a resource to help you make performance related decisions for your applications that use Entity Framework.</span></span> <span data-ttu-id="de3cf-114">Hemos incluido algunas métricas de pruebas para demostrar el rendimiento, pero estas métricas no están diseñadas como absolutos indicadores del rendimiento que ve en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="de3cf-114">We have included some test metrics to demonstrate performance, but these metrics aren't intended as absolute indicators of the performance you will see in your application.</span></span>

<span data-ttu-id="de3cf-115">Por motivos prácticos, este documento se supone que Entity Framework 4 se ejecuta en .NET 4.0 y Entity Framework 5 y 6 se ejecutan en .NET 4.5.</span><span class="sxs-lookup"><span data-stu-id="de3cf-115">For practical purposes, this document assumes Entity Framework 4 is run under .NET 4.0 and Entity Framework 5 and 6 are run under .NET 4.5.</span></span> <span data-ttu-id="de3cf-116">Muchas de las mejoras de rendimiento para Entity Framework 5 residen dentro de los componentes principales que se incluyen con .NET 4.5.</span><span class="sxs-lookup"><span data-stu-id="de3cf-116">Many of the performance improvements made for Entity Framework 5 reside within the core components that ship with .NET 4.5.</span></span>

<span data-ttu-id="de3cf-117">Entity Framework 6 es un fuera de la versión de banda y no depende de los componentes de Entity Framework que se suministran con. NET.</span><span class="sxs-lookup"><span data-stu-id="de3cf-117">Entity Framework 6 is an out of band release and does not depend on the Entity Framework components that ship with .NET.</span></span> <span data-ttu-id="de3cf-118">Entity Framework 6 trabajar en .NET 4.0 y 4.5 de .NET y puede ofrecer una mejora del rendimiento grande a aquellos que no ha actualizado de .NET 4.0 pero desea que los bits más recientes de Entity Framework en su aplicación.</span><span class="sxs-lookup"><span data-stu-id="de3cf-118">Entity Framework 6 work on both .NET 4.0 and .NET 4.5, and can offer a big performance benefit to those who haven’t upgraded from .NET 4.0 but want the latest Entity Framework bits in their application.</span></span> <span data-ttu-id="de3cf-119">Cuando este documento hace referencia a Entity Framework 6, se refiere a la versión más reciente disponible en el momento de redactar este artículo: versión 6.1.0.</span><span class="sxs-lookup"><span data-stu-id="de3cf-119">When this document mentions Entity Framework 6, it refers to the latest version available at the time of this writing: version 6.1.0.</span></span>

## <a name="2-cold-vs-warm-query-execution"></a><span data-ttu-id="de3cf-120">2. Vs en frío. Ejecución de consulta activa</span><span class="sxs-lookup"><span data-stu-id="de3cf-120">2. Cold vs. Warm Query Execution</span></span>

<span data-ttu-id="de3cf-121">La primera vez que se realiza cualquier consulta contra un modelo determinado, Entity Framework realiza mucho trabajo en segundo plano para cargar y validar el modelo.</span><span class="sxs-lookup"><span data-stu-id="de3cf-121">The very first time any query is made against a given model, the Entity Framework does a lot of work behind the scenes to load and validate the model.</span></span> <span data-ttu-id="de3cf-122">Con frecuencia nos referimos a esta consulta primera como una consulta "en frío".</span><span class="sxs-lookup"><span data-stu-id="de3cf-122">We frequently refer to this first query as a "cold" query.</span></span><span data-ttu-id="de3cf-123">  Se conocen como "activos" consultas más consultas en un modelo ya cargada y son mucho más rápidas.</span><span class="sxs-lookup"><span data-stu-id="de3cf-123">  Further queries against an already loaded model are known as "warm" queries, and are much faster.</span></span>

<span data-ttu-id="de3cf-124">Tomemos una visión general de tiempo empleado al ejecutar una consulta mediante Entity Framework y vea dónde están mejorando las cosas en Entity Framework 6.</span><span class="sxs-lookup"><span data-stu-id="de3cf-124">Let’s take a high-level view of where time is spent when executing a query using Entity Framework, and see where things are improving in Entity Framework 6.</span></span>

<span data-ttu-id="de3cf-125">**Primera ejecución de consulta: consulta frío**</span><span class="sxs-lookup"><span data-stu-id="de3cf-125">**First Query Execution – cold query**</span></span>

| <span data-ttu-id="de3cf-126">Escrituras de usuario de código</span><span class="sxs-lookup"><span data-stu-id="de3cf-126">Code User Writes</span></span>                                                                                     | <span data-ttu-id="de3cf-127">Acción</span><span class="sxs-lookup"><span data-stu-id="de3cf-127">Action</span></span>                    | <span data-ttu-id="de3cf-128">EF4 Impacto de rendimiento</span><span class="sxs-lookup"><span data-stu-id="de3cf-128">EF4 Performance Impact</span></span>                                                                                                                                                                                                                                                                                                                                                                                                        | <span data-ttu-id="de3cf-129">EF5 Impacto de rendimiento</span><span class="sxs-lookup"><span data-stu-id="de3cf-129">EF5 Performance Impact</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                    | <span data-ttu-id="de3cf-130">EF6 Impacto de rendimiento</span><span class="sxs-lookup"><span data-stu-id="de3cf-130">EF6 Performance Impact</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
|:-----------------------------------------------------------------------------------------------------|:--------------------------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `using(var db = new MyContext())` <br/> `{`                                                          | <span data-ttu-id="de3cf-131">Creación del contexto</span><span class="sxs-lookup"><span data-stu-id="de3cf-131">Context creation</span></span>          | <span data-ttu-id="de3cf-132">Medium</span><span class="sxs-lookup"><span data-stu-id="de3cf-132">Medium</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                        | <span data-ttu-id="de3cf-133">Medium</span><span class="sxs-lookup"><span data-stu-id="de3cf-133">Medium</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | <span data-ttu-id="de3cf-134">Bajo</span><span class="sxs-lookup"><span data-stu-id="de3cf-134">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| `  var q1 = ` <br/> `    from c in db.Customers` <br/> `    where c.Id == id1` <br/> `    select c;` | <span data-ttu-id="de3cf-135">Creación de la expresión de consulta</span><span class="sxs-lookup"><span data-stu-id="de3cf-135">Query expression creation</span></span> | <span data-ttu-id="de3cf-136">Bajo</span><span class="sxs-lookup"><span data-stu-id="de3cf-136">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                           | <span data-ttu-id="de3cf-137">Bajo</span><span class="sxs-lookup"><span data-stu-id="de3cf-137">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | <span data-ttu-id="de3cf-138">Bajo</span><span class="sxs-lookup"><span data-stu-id="de3cf-138">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| `  var c1 = q1.First();`                                                                             | <span data-ttu-id="de3cf-139">Ejecución de consultas LINQ</span><span class="sxs-lookup"><span data-stu-id="de3cf-139">LINQ query execution</span></span>      | <span data-ttu-id="de3cf-140">-Carga metadatos: alta, pero se ha almacenado en caché</span><span class="sxs-lookup"><span data-stu-id="de3cf-140">- Metadata loading: High but cached</span></span> <br/> <span data-ttu-id="de3cf-141">-Ver generación: potencialmente muy alta pero almacenados en caché</span><span class="sxs-lookup"><span data-stu-id="de3cf-141">- View generation: Potentially very high but cached</span></span> <br/> <span data-ttu-id="de3cf-142">-Evaluación del parámetro: medio</span><span class="sxs-lookup"><span data-stu-id="de3cf-142">- Parameter evaluation: Medium</span></span> <br/> <span data-ttu-id="de3cf-143">-Traducción de consultas: medio</span><span class="sxs-lookup"><span data-stu-id="de3cf-143">- Query translation: Medium</span></span> <br/> <span data-ttu-id="de3cf-144">-Generación materializador: medio, pero se ha almacenado en caché</span><span class="sxs-lookup"><span data-stu-id="de3cf-144">- Materializer generation: Medium but cached</span></span> <br/> <span data-ttu-id="de3cf-145">-Ejecución de la consulta de base de datos: potencialmente alto</span><span class="sxs-lookup"><span data-stu-id="de3cf-145">- Database query execution: Potentially high</span></span> <br/> <span data-ttu-id="de3cf-146">+ Connection.Open</span><span class="sxs-lookup"><span data-stu-id="de3cf-146">+ Connection.Open</span></span> <br/> <span data-ttu-id="de3cf-147">+ Command.ExecuteReader</span><span class="sxs-lookup"><span data-stu-id="de3cf-147">+ Command.ExecuteReader</span></span> <br/> <span data-ttu-id="de3cf-148">+ DataReader.Read</span><span class="sxs-lookup"><span data-stu-id="de3cf-148">+ DataReader.Read</span></span> <br/> <span data-ttu-id="de3cf-149">Materialización de objetos: medio</span><span class="sxs-lookup"><span data-stu-id="de3cf-149">Object materialization: Medium</span></span> <br/> <span data-ttu-id="de3cf-150">-Búsqueda identity: medio</span><span class="sxs-lookup"><span data-stu-id="de3cf-150">- Identity lookup: Medium</span></span> | <span data-ttu-id="de3cf-151">-Carga metadatos: alta, pero se ha almacenado en caché</span><span class="sxs-lookup"><span data-stu-id="de3cf-151">- Metadata loading: High but cached</span></span> <br/> <span data-ttu-id="de3cf-152">-Ver generación: potencialmente muy alta pero almacenados en caché</span><span class="sxs-lookup"><span data-stu-id="de3cf-152">- View generation: Potentially very high but cached</span></span> <br/> <span data-ttu-id="de3cf-153">-Evaluación del parámetro: baja</span><span class="sxs-lookup"><span data-stu-id="de3cf-153">- Parameter evaluation: Low</span></span> <br/> <span data-ttu-id="de3cf-154">-Traducción de consultas: medio, pero se ha almacenado en caché</span><span class="sxs-lookup"><span data-stu-id="de3cf-154">- Query translation: Medium but cached</span></span> <br/> <span data-ttu-id="de3cf-155">-Generación materializador: medio, pero se ha almacenado en caché</span><span class="sxs-lookup"><span data-stu-id="de3cf-155">- Materializer generation: Medium but cached</span></span> <br/> <span data-ttu-id="de3cf-156">-Ejecución de la consulta de base de datos: potencialmente alto (mejor las consultas en algunas situaciones)</span><span class="sxs-lookup"><span data-stu-id="de3cf-156">- Database query execution: Potentially high (Better queries in some situations)</span></span> <br/> <span data-ttu-id="de3cf-157">+ Connection.Open</span><span class="sxs-lookup"><span data-stu-id="de3cf-157">+ Connection.Open</span></span> <br/> <span data-ttu-id="de3cf-158">+ Command.ExecuteReader</span><span class="sxs-lookup"><span data-stu-id="de3cf-158">+ Command.ExecuteReader</span></span> <br/> <span data-ttu-id="de3cf-159">+ DataReader.Read</span><span class="sxs-lookup"><span data-stu-id="de3cf-159">+ DataReader.Read</span></span> <br/> <span data-ttu-id="de3cf-160">Materialización de objetos: medio</span><span class="sxs-lookup"><span data-stu-id="de3cf-160">Object materialization: Medium</span></span> <br/> <span data-ttu-id="de3cf-161">-Búsqueda identity: medio</span><span class="sxs-lookup"><span data-stu-id="de3cf-161">- Identity lookup: Medium</span></span> | <span data-ttu-id="de3cf-162">-Carga metadatos: alta, pero se ha almacenado en caché</span><span class="sxs-lookup"><span data-stu-id="de3cf-162">- Metadata loading: High but cached</span></span> <br/> <span data-ttu-id="de3cf-163">-Ver generación: medio, pero se ha almacenado en caché</span><span class="sxs-lookup"><span data-stu-id="de3cf-163">- View generation: Medium but cached</span></span> <br/> <span data-ttu-id="de3cf-164">-Evaluación del parámetro: baja</span><span class="sxs-lookup"><span data-stu-id="de3cf-164">- Parameter evaluation: Low</span></span> <br/> <span data-ttu-id="de3cf-165">-Traducción de consultas: medio, pero se ha almacenado en caché</span><span class="sxs-lookup"><span data-stu-id="de3cf-165">- Query translation: Medium but cached</span></span> <br/> <span data-ttu-id="de3cf-166">-Generación materializador: medio, pero se ha almacenado en caché</span><span class="sxs-lookup"><span data-stu-id="de3cf-166">- Materializer generation: Medium but cached</span></span> <br/> <span data-ttu-id="de3cf-167">-Ejecución de la consulta de base de datos: potencialmente alto (mejor las consultas en algunas situaciones)</span><span class="sxs-lookup"><span data-stu-id="de3cf-167">- Database query execution: Potentially high (Better queries in some situations)</span></span> <br/> <span data-ttu-id="de3cf-168">+ Connection.Open</span><span class="sxs-lookup"><span data-stu-id="de3cf-168">+ Connection.Open</span></span> <br/> <span data-ttu-id="de3cf-169">+ Command.ExecuteReader</span><span class="sxs-lookup"><span data-stu-id="de3cf-169">+ Command.ExecuteReader</span></span> <br/> <span data-ttu-id="de3cf-170">+ DataReader.Read</span><span class="sxs-lookup"><span data-stu-id="de3cf-170">+ DataReader.Read</span></span> <br/> <span data-ttu-id="de3cf-171">Materialización de objetos: medio (Faster de EF5)</span><span class="sxs-lookup"><span data-stu-id="de3cf-171">Object materialization: Medium (Faster than EF5)</span></span> <br/> <span data-ttu-id="de3cf-172">-Búsqueda identity: medio</span><span class="sxs-lookup"><span data-stu-id="de3cf-172">- Identity lookup: Medium</span></span> |
| `}`                                                                                                  | <span data-ttu-id="de3cf-173">Connection.Close</span><span class="sxs-lookup"><span data-stu-id="de3cf-173">Connection.Close</span></span>          | <span data-ttu-id="de3cf-174">Bajo</span><span class="sxs-lookup"><span data-stu-id="de3cf-174">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                           | <span data-ttu-id="de3cf-175">Bajo</span><span class="sxs-lookup"><span data-stu-id="de3cf-175">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | <span data-ttu-id="de3cf-176">Bajo</span><span class="sxs-lookup"><span data-stu-id="de3cf-176">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |


<span data-ttu-id="de3cf-177">**Segunda ejecución de consulta: consulta activa**</span><span class="sxs-lookup"><span data-stu-id="de3cf-177">**Second Query Execution – warm query**</span></span>

| <span data-ttu-id="de3cf-178">Escrituras de usuario de código</span><span class="sxs-lookup"><span data-stu-id="de3cf-178">Code User Writes</span></span>                                                                                     | <span data-ttu-id="de3cf-179">Acción</span><span class="sxs-lookup"><span data-stu-id="de3cf-179">Action</span></span>                    | <span data-ttu-id="de3cf-180">EF4 Impacto de rendimiento</span><span class="sxs-lookup"><span data-stu-id="de3cf-180">EF4 Performance Impact</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | <span data-ttu-id="de3cf-181">EF5 Impacto de rendimiento</span><span class="sxs-lookup"><span data-stu-id="de3cf-181">EF5 Performance Impact</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | <span data-ttu-id="de3cf-182">EF6 Impacto de rendimiento</span><span class="sxs-lookup"><span data-stu-id="de3cf-182">EF6 Performance Impact</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|:-----------------------------------------------------------------------------------------------------|:--------------------------|:--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `using(var db = new MyContext())` <br/> `{`                                                          | <span data-ttu-id="de3cf-183">Creación del contexto</span><span class="sxs-lookup"><span data-stu-id="de3cf-183">Context creation</span></span>          | <span data-ttu-id="de3cf-184">Medium</span><span class="sxs-lookup"><span data-stu-id="de3cf-184">Medium</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | <span data-ttu-id="de3cf-185">Medium</span><span class="sxs-lookup"><span data-stu-id="de3cf-185">Medium</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | <span data-ttu-id="de3cf-186">Bajo</span><span class="sxs-lookup"><span data-stu-id="de3cf-186">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| `  var q1 = ` <br/> `    from c in db.Customers` <br/> `    where c.Id == id1` <br/> `    select c;` | <span data-ttu-id="de3cf-187">Creación de la expresión de consulta</span><span class="sxs-lookup"><span data-stu-id="de3cf-187">Query expression creation</span></span> | <span data-ttu-id="de3cf-188">Bajo</span><span class="sxs-lookup"><span data-stu-id="de3cf-188">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | <span data-ttu-id="de3cf-189">Bajo</span><span class="sxs-lookup"><span data-stu-id="de3cf-189">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | <span data-ttu-id="de3cf-190">Bajo</span><span class="sxs-lookup"><span data-stu-id="de3cf-190">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| `  var c1 = q1.First();`                                                                             | <span data-ttu-id="de3cf-191">Ejecución de consultas LINQ</span><span class="sxs-lookup"><span data-stu-id="de3cf-191">LINQ query execution</span></span>      | <span data-ttu-id="de3cf-192">-Metadata ~~cargando~~ búsqueda: ~~alta, pero se ha almacenado en caché~~ baja</span><span class="sxs-lookup"><span data-stu-id="de3cf-192">- Metadata ~~loading~~ lookup: ~~High but cached~~ Low</span></span> <br/> <span data-ttu-id="de3cf-193">-Ver ~~generación~~ búsqueda: ~~potencialmente muy alta pero almacenados en caché~~ baja</span><span class="sxs-lookup"><span data-stu-id="de3cf-193">- View ~~generation~~ lookup: ~~Potentially very high but cached~~ Low</span></span> <br/> <span data-ttu-id="de3cf-194">-Evaluación del parámetro: medio</span><span class="sxs-lookup"><span data-stu-id="de3cf-194">- Parameter evaluation: Medium</span></span> <br/> <span data-ttu-id="de3cf-195">-Query ~~traducción~~ búsqueda: medio</span><span class="sxs-lookup"><span data-stu-id="de3cf-195">- Query ~~translation~~ lookup: Medium</span></span> <br/> <span data-ttu-id="de3cf-196">-Materializador ~~generación~~ búsqueda: ~~medio, pero se ha almacenado en caché~~ baja</span><span class="sxs-lookup"><span data-stu-id="de3cf-196">- Materializer ~~generation~~ lookup: ~~Medium but cached~~ Low</span></span> <br/> <span data-ttu-id="de3cf-197">-Ejecución de la consulta de base de datos: potencialmente alto</span><span class="sxs-lookup"><span data-stu-id="de3cf-197">- Database query execution: Potentially high</span></span> <br/> <span data-ttu-id="de3cf-198">+ Connection.Open</span><span class="sxs-lookup"><span data-stu-id="de3cf-198">+ Connection.Open</span></span> <br/> <span data-ttu-id="de3cf-199">+ Command.ExecuteReader</span><span class="sxs-lookup"><span data-stu-id="de3cf-199">+ Command.ExecuteReader</span></span> <br/> <span data-ttu-id="de3cf-200">+ DataReader.Read</span><span class="sxs-lookup"><span data-stu-id="de3cf-200">+ DataReader.Read</span></span> <br/> <span data-ttu-id="de3cf-201">Materialización de objetos: medio</span><span class="sxs-lookup"><span data-stu-id="de3cf-201">Object materialization: Medium</span></span> <br/> <span data-ttu-id="de3cf-202">-Búsqueda identity: medio</span><span class="sxs-lookup"><span data-stu-id="de3cf-202">- Identity lookup: Medium</span></span> | <span data-ttu-id="de3cf-203">-Metadata ~~cargando~~ búsqueda: ~~alta, pero se ha almacenado en caché~~ baja</span><span class="sxs-lookup"><span data-stu-id="de3cf-203">- Metadata ~~loading~~ lookup: ~~High but cached~~ Low</span></span> <br/> <span data-ttu-id="de3cf-204">-Ver ~~generación~~ búsqueda: ~~potencialmente muy alta pero almacenados en caché~~ baja</span><span class="sxs-lookup"><span data-stu-id="de3cf-204">- View ~~generation~~ lookup: ~~Potentially very high but cached~~ Low</span></span> <br/> <span data-ttu-id="de3cf-205">-Evaluación del parámetro: baja</span><span class="sxs-lookup"><span data-stu-id="de3cf-205">- Parameter evaluation: Low</span></span> <br/> <span data-ttu-id="de3cf-206">-Query ~~traducción~~ búsqueda: ~~medio, pero se ha almacenado en caché~~ baja</span><span class="sxs-lookup"><span data-stu-id="de3cf-206">- Query ~~translation~~ lookup: ~~Medium but cached~~ Low</span></span> <br/> <span data-ttu-id="de3cf-207">-Materializador ~~generación~~ búsqueda: ~~medio, pero se ha almacenado en caché~~ baja</span><span class="sxs-lookup"><span data-stu-id="de3cf-207">- Materializer ~~generation~~ lookup: ~~Medium but cached~~ Low</span></span> <br/> <span data-ttu-id="de3cf-208">-Ejecución de la consulta de base de datos: potencialmente alto (mejor las consultas en algunas situaciones)</span><span class="sxs-lookup"><span data-stu-id="de3cf-208">- Database query execution: Potentially high (Better queries in some situations)</span></span> <br/> <span data-ttu-id="de3cf-209">+ Connection.Open</span><span class="sxs-lookup"><span data-stu-id="de3cf-209">+ Connection.Open</span></span> <br/> <span data-ttu-id="de3cf-210">+ Command.ExecuteReader</span><span class="sxs-lookup"><span data-stu-id="de3cf-210">+ Command.ExecuteReader</span></span> <br/> <span data-ttu-id="de3cf-211">+ DataReader.Read</span><span class="sxs-lookup"><span data-stu-id="de3cf-211">+ DataReader.Read</span></span> <br/> <span data-ttu-id="de3cf-212">Materialización de objetos: medio</span><span class="sxs-lookup"><span data-stu-id="de3cf-212">Object materialization: Medium</span></span> <br/> <span data-ttu-id="de3cf-213">-Búsqueda identity: medio</span><span class="sxs-lookup"><span data-stu-id="de3cf-213">- Identity lookup: Medium</span></span> | <span data-ttu-id="de3cf-214">-Metadata ~~cargando~~ búsqueda: ~~alta, pero se ha almacenado en caché~~ baja</span><span class="sxs-lookup"><span data-stu-id="de3cf-214">- Metadata ~~loading~~ lookup: ~~High but cached~~ Low</span></span> <br/> <span data-ttu-id="de3cf-215">-Ver ~~generación~~ búsqueda: ~~medio, pero se ha almacenado en caché~~ baja</span><span class="sxs-lookup"><span data-stu-id="de3cf-215">- View ~~generation~~ lookup: ~~Medium but cached~~ Low</span></span> <br/> <span data-ttu-id="de3cf-216">-Evaluación del parámetro: baja</span><span class="sxs-lookup"><span data-stu-id="de3cf-216">- Parameter evaluation: Low</span></span> <br/> <span data-ttu-id="de3cf-217">-Query ~~traducción~~ búsqueda: ~~medio, pero se ha almacenado en caché~~ baja</span><span class="sxs-lookup"><span data-stu-id="de3cf-217">- Query ~~translation~~ lookup: ~~Medium but cached~~ Low</span></span> <br/> <span data-ttu-id="de3cf-218">-Materializador ~~generación~~ búsqueda: ~~medio, pero se ha almacenado en caché~~ baja</span><span class="sxs-lookup"><span data-stu-id="de3cf-218">- Materializer ~~generation~~ lookup: ~~Medium but cached~~ Low</span></span> <br/> <span data-ttu-id="de3cf-219">-Ejecución de la consulta de base de datos: potencialmente alto (mejor las consultas en algunas situaciones)</span><span class="sxs-lookup"><span data-stu-id="de3cf-219">- Database query execution: Potentially high (Better queries in some situations)</span></span> <br/> <span data-ttu-id="de3cf-220">+ Connection.Open</span><span class="sxs-lookup"><span data-stu-id="de3cf-220">+ Connection.Open</span></span> <br/> <span data-ttu-id="de3cf-221">+ Command.ExecuteReader</span><span class="sxs-lookup"><span data-stu-id="de3cf-221">+ Command.ExecuteReader</span></span> <br/> <span data-ttu-id="de3cf-222">+ DataReader.Read</span><span class="sxs-lookup"><span data-stu-id="de3cf-222">+ DataReader.Read</span></span> <br/> <span data-ttu-id="de3cf-223">Materialización de objetos: medio (Faster de EF5)</span><span class="sxs-lookup"><span data-stu-id="de3cf-223">Object materialization: Medium (Faster than EF5)</span></span> <br/> <span data-ttu-id="de3cf-224">-Búsqueda identity: medio</span><span class="sxs-lookup"><span data-stu-id="de3cf-224">- Identity lookup: Medium</span></span> |
| `}`                                                                                                  | <span data-ttu-id="de3cf-225">Connection.Close</span><span class="sxs-lookup"><span data-stu-id="de3cf-225">Connection.Close</span></span>          | <span data-ttu-id="de3cf-226">Bajo</span><span class="sxs-lookup"><span data-stu-id="de3cf-226">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | <span data-ttu-id="de3cf-227">Bajo</span><span class="sxs-lookup"><span data-stu-id="de3cf-227">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | <span data-ttu-id="de3cf-228">Bajo</span><span class="sxs-lookup"><span data-stu-id="de3cf-228">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |


<span data-ttu-id="de3cf-229">Hay varias maneras de reducir el costo de rendimiento de las consultas en frío y calientes y echaremos un vistazo en ellos en la sección siguiente.</span><span class="sxs-lookup"><span data-stu-id="de3cf-229">There are several ways to reduce the performance cost of both cold and warm queries, and we'll take a look at these in the following section.</span></span> <span data-ttu-id="de3cf-230">En concreto, veremos que reduce el costo de cargar en las consultas en frío mediante las vistas generadas previamente, lo que deberían ayudar a solucionar las dificultades de rendimiento producidas durante la generación de la vista de modelo.</span><span class="sxs-lookup"><span data-stu-id="de3cf-230">Specifically, we'll look at reducing the cost of model loading in cold queries by using pre-generated views, which should help alleviate performance pains experienced during view generation.</span></span> <span data-ttu-id="de3cf-231">Para consultas semiactivos, hablaremos sobre las opciones de ejecución de consulta diferentes, ninguna consulta de seguimiento y almacenamiento en caché del plan de consulta.</span><span class="sxs-lookup"><span data-stu-id="de3cf-231">For warm queries, we'll cover query plan caching, no tracking queries, and different query execution options.</span></span>

### <a name="21-what-is-view-generation"></a><span data-ttu-id="de3cf-232">2.1 ¿Qué es la generación de vistas?</span><span class="sxs-lookup"><span data-stu-id="de3cf-232">2.1 What is View Generation?</span></span>

<span data-ttu-id="de3cf-233">Para entender qué vista generación es, debemos comprender primero qué son las "Vistas de asignación".</span><span class="sxs-lookup"><span data-stu-id="de3cf-233">In order to understand what view generation is, we must first understand what “Mapping Views” are.</span></span> <span data-ttu-id="de3cf-234">Las vistas de asignación son representaciones ejecutables de las transformaciones especificadas en la asignación para cada conjunto de entidades y asociaciones.</span><span class="sxs-lookup"><span data-stu-id="de3cf-234">Mapping Views are executable representations of the transformations specified in the mapping for each entity set and association.</span></span> <span data-ttu-id="de3cf-235">Internamente, estas vistas de asignación adoptar la forma de CQTs (árboles canónicos de consulta).</span><span class="sxs-lookup"><span data-stu-id="de3cf-235">Internally, these mapping views take the shape of CQTs (canonical query trees).</span></span> <span data-ttu-id="de3cf-236">Hay dos tipos de vistas de asignación:</span><span class="sxs-lookup"><span data-stu-id="de3cf-236">There are two types of mapping views:</span></span>

-   <span data-ttu-id="de3cf-237">Vistas de consulta: representan la transformación necesaria para pasar desde el esquema de base de datos al modelo conceptual.</span><span class="sxs-lookup"><span data-stu-id="de3cf-237">Query views: these represent the transformation necessary to go from the database schema to the conceptual model.</span></span>
-   <span data-ttu-id="de3cf-238">Actualizar vistas: representan la transformación necesaria para pasar del modelo conceptual para el esquema de base de datos.</span><span class="sxs-lookup"><span data-stu-id="de3cf-238">Update views: these represent the transformation necessary to go from the conceptual model to the database schema.</span></span>

<span data-ttu-id="de3cf-239">Tenga en cuenta que el modelo conceptual podría diferir de esquema de base de datos de varias maneras.</span><span class="sxs-lookup"><span data-stu-id="de3cf-239">Keep in mind that the conceptual model might differ from the database schema in various ways.</span></span> <span data-ttu-id="de3cf-240">Por ejemplo, se puede usar una sola tabla para almacenar los datos para dos tipos de entidad diferente.</span><span class="sxs-lookup"><span data-stu-id="de3cf-240">For example, one single table might be used to store the data for two different entity types.</span></span> <span data-ttu-id="de3cf-241">Herencia y las asignaciones no trivial desempeñan un papel en la complejidad de las vistas de asignación.</span><span class="sxs-lookup"><span data-stu-id="de3cf-241">Inheritance and non-trivial mappings play a role in the complexity of the mapping views.</span></span>

<span data-ttu-id="de3cf-242">El proceso de la informática estas vistas según la especificación de la asignación es lo que llamamos generación de la vista.</span><span class="sxs-lookup"><span data-stu-id="de3cf-242">The process of computing these views based on the specification of the mapping is what we call view generation.</span></span> <span data-ttu-id="de3cf-243">Generación de la vista puede bien tener lugar dinámicamente cuando se carga un modelo, o en tiempo de compilación mediante el uso de "las vistas generadas previamente"; se serializan en forma de instrucciones SQL de la entidad para una C\# o archivo de VB.</span><span class="sxs-lookup"><span data-stu-id="de3cf-243">View generation can either take place dynamically when a model is loaded, or at build time, by using "pre-generated views"; the latter are serialized in the form of Entity SQL statements to a C\# or VB file.</span></span>

<span data-ttu-id="de3cf-244">Cuando se generan vistas, también se validan.</span><span class="sxs-lookup"><span data-stu-id="de3cf-244">When views are generated, they are also validated.</span></span> <span data-ttu-id="de3cf-245">Desde la perspectiva del rendimiento, la mayoría de los costes de generación de vistas es realmente la validación de las vistas que garantiza que las conexiones entre las entidades tienen sentido y tienen la cardinalidad correcta para todas las operaciones compatibles.</span><span class="sxs-lookup"><span data-stu-id="de3cf-245">From a performance standpoint, the vast majority of the cost of view generation is actually the validation of the views which ensures that the connections between the entities make sense and have the correct cardinality for all the supported operations.</span></span>

<span data-ttu-id="de3cf-246">Cuando se ejecuta una consulta a través de un conjunto de entidades, la consulta se combina con la vista de consulta correspondiente y se ejecuta el resultado de esta composición mediante el compilador de plan para crear la representación de la consulta que pueda entender el almacén de respaldo.</span><span class="sxs-lookup"><span data-stu-id="de3cf-246">When a query over an entity set is executed, the query is combined with the corresponding query view, and the result of this composition is run through the plan compiler to create the representation of the query that the backing store can understand.</span></span> <span data-ttu-id="de3cf-247">Para SQL Server, el resultado final de esta compilación será una instrucción SELECT de Transact-SQL.</span><span class="sxs-lookup"><span data-stu-id="de3cf-247">For SQL Server, the final result of this compilation will be a T-SQL SELECT statement.</span></span> <span data-ttu-id="de3cf-248">La primera vez que se realiza una actualización a través de un conjunto de entidades, la vista de actualización se ejecuta mediante un proceso similar para transformarlos en las instrucciones DML para la base de datos de destino.</span><span class="sxs-lookup"><span data-stu-id="de3cf-248">The first time an update over an entity set is performed, the update view is run through a similar process to transform it into DML statements for the target database.</span></span>

### <a name="22-factors-that-affect-view-generation-performance"></a><span data-ttu-id="de3cf-249">2.2 factores que afectan al rendimiento de generación de vistas</span><span class="sxs-lookup"><span data-stu-id="de3cf-249">2.2 Factors that affect View Generation performance</span></span>

<span data-ttu-id="de3cf-250">El rendimiento del paso de generación de vista no solo depende del tamaño del modelo, sino también en el modelo de cómo interconectados es.</span><span class="sxs-lookup"><span data-stu-id="de3cf-250">The performance of view generation step not only depends on the size of your model but also on how interconnected the model is.</span></span> <span data-ttu-id="de3cf-251">Si dos entidades están conectadas a través de una cadena de herencia o una asociación, se dice que estar conectado.</span><span class="sxs-lookup"><span data-stu-id="de3cf-251">If two Entities are connected via an inheritance chain or an Association, they are said to be connected.</span></span> <span data-ttu-id="de3cf-252">De forma similar si dos tablas están conectadas a través de una clave externa, están conectados.</span><span class="sxs-lookup"><span data-stu-id="de3cf-252">Similarly if two tables are connected via a foreign key, they are connected.</span></span> <span data-ttu-id="de3cf-253">A medida que aumenta el número de conectados entidades y tablas en los esquemas, la generación de vistas costo aumenta.</span><span class="sxs-lookup"><span data-stu-id="de3cf-253">As the number of connected Entities and tables in your schemas increase, the view generation cost increases.</span></span>

<span data-ttu-id="de3cf-254">El algoritmo que se usa para generar y validar las vistas es exponencial en el peor de los casos, aunque utilizamos algunas optimizaciones para mejorar esta situación.</span><span class="sxs-lookup"><span data-stu-id="de3cf-254">The algorithm that we use to generate and validate views is exponential in the worst case, though we do use some optimizations to improve this.</span></span> <span data-ttu-id="de3cf-255">Los factores más importantes que parecen afectar negativamente al rendimiento son:</span><span class="sxs-lookup"><span data-stu-id="de3cf-255">The biggest factors that seem to negatively affect performance are:</span></span>

-   <span data-ttu-id="de3cf-256">Tamaño del modelo, que hace referencia al número de entidades y la cantidad de las asociaciones entre estas entidades.</span><span class="sxs-lookup"><span data-stu-id="de3cf-256">Model size, referring to the number of entities and the amount of associations between these entities.</span></span>
-   <span data-ttu-id="de3cf-257">Complejidad de modelo, específicamente la herencia que implican a un gran número de tipos.</span><span class="sxs-lookup"><span data-stu-id="de3cf-257">Model complexity, specifically inheritance involving a large number of types.</span></span>
-   <span data-ttu-id="de3cf-258">Uso de asociaciones independientes, en lugar de las asociaciones de clave externa.</span><span class="sxs-lookup"><span data-stu-id="de3cf-258">Using Independent Associations, instead of Foreign Key Associations.</span></span>

<span data-ttu-id="de3cf-259">Para los modelos pequeños y sencillos, el costo puede ser lo suficientemente pequeño como para no moleste con las vistas generadas previamente.</span><span class="sxs-lookup"><span data-stu-id="de3cf-259">For small, simple models the cost may be small enough to not bother using pre-generated views.</span></span> <span data-ttu-id="de3cf-260">A medida que aumentan el tamaño del modelo y la complejidad, hay varias opciones reducir el costo de validación y generación de la vista.</span><span class="sxs-lookup"><span data-stu-id="de3cf-260">As model size and complexity increase, there are several options available to reduce the cost of view generation and validation.</span></span>

### <a name="23-using-pre-generated-views-to-decrease-model-load-time"></a><span data-ttu-id="de3cf-261">2.3 mediante Pre-Generated vistas para reducir el modelo de tiempo de carga</span><span class="sxs-lookup"><span data-stu-id="de3cf-261">2.3 Using Pre-Generated Views to decrease model load time</span></span>

<span data-ttu-id="de3cf-262">Para obtener información detallada sobre cómo usar las vistas generadas previamente en Entity Framework 6 visite [Pre-Generated vistas de asignación](~/ef6/fundamentals/performance/pre-generated-views.md)</span><span class="sxs-lookup"><span data-stu-id="de3cf-262">For detailed information on how to use pre-generated views on Entity Framework 6 visit [Pre-Generated Mapping Views](~/ef6/fundamentals/performance/pre-generated-views.md)</span></span>

#### <a name="231-pre-generated-views-using-the-entity-framework-power-tools-community-edition"></a><span data-ttu-id="de3cf-263">2.3.1 las vistas generadas previamente mediante la edición Community de Entity Framework Power Tools</span><span class="sxs-lookup"><span data-stu-id="de3cf-263">2.3.1 Pre-Generated views using the Entity Framework Power Tools Community Edition</span></span>

<span data-ttu-id="de3cf-264">Puede usar el [Entity Framework 6 Power Tools Community Edition](https://marketplace.visualstudio.com/items?itemName=ErikEJ.EntityFramework6PowerToolsCommunityEdition) para generar vistas de modelos EDMX y Code First haciendo clic en el archivo de clase de modelo y seleccione "Generar vistas" mediante el menú de Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="de3cf-264">You can use the [Entity Framework 6 Power Tools Community Edition](https://marketplace.visualstudio.com/items?itemName=ErikEJ.EntityFramework6PowerToolsCommunityEdition) to generate views of EDMX and Code First models by right-clicking the model class file and using the Entity Framework menu to select “Generate Views”.</span></span> <span data-ttu-id="de3cf-265">La edición Community de Entity Framework Power Tools funcionan únicamente en contextos derivada de DbContext.</span><span class="sxs-lookup"><span data-stu-id="de3cf-265">The Entity Framework Power Tools Community Edition work only on DbContext-derived contexts.</span></span>

#### <a name="232-how-to-use-pre-generated-views-with-a-model-created-by-edmgen"></a><span data-ttu-id="de3cf-266">2.3.2 cómo usar las vistas generadas previamente con un modelo creado forma EDMGen</span><span class="sxs-lookup"><span data-stu-id="de3cf-266">2.3.2 How to use Pre-generated views with a model created by EDMGen</span></span>

<span data-ttu-id="de3cf-267">EDMGen es una utilidad que se distribuye con .NET y funciona con Entity Framework 4 y 5, pero no con Entity Framework 6.</span><span class="sxs-lookup"><span data-stu-id="de3cf-267">EDMGen is a utility that ships with .NET and works with Entity Framework 4 and 5, but not with Entity Framework 6.</span></span> <span data-ttu-id="de3cf-268">EDMGen le permite generar un archivo de modelo, la capa de objeto y las vistas de la línea de comandos.</span><span class="sxs-lookup"><span data-stu-id="de3cf-268">EDMGen allows you to generate a model file, the object layer and the views from the command line.</span></span> <span data-ttu-id="de3cf-269">Una de las salidas será un archivo de vistas en el lenguaje elegido, VB o C\#.</span><span class="sxs-lookup"><span data-stu-id="de3cf-269">One of the outputs will be a Views file in your language of choice, VB or C\#.</span></span> <span data-ttu-id="de3cf-270">Se trata de un archivo de código que contiene fragmentos de código de Entity SQL para cada conjunto de entidades.</span><span class="sxs-lookup"><span data-stu-id="de3cf-270">This is a code file containing Entity SQL snippets for each entity set.</span></span> <span data-ttu-id="de3cf-271">Para habilitar las vistas generadas previamente, basta con incluir el archivo en el proyecto.</span><span class="sxs-lookup"><span data-stu-id="de3cf-271">To enable pre-generated views, you simply include the file in your project.</span></span>

<span data-ttu-id="de3cf-272">Si realiza modificaciones a los archivos de esquema para el modelo manualmente, deberá volver a generar el archivo de vistas.</span><span class="sxs-lookup"><span data-stu-id="de3cf-272">If you manually make edits to the schema files for the model, you will need to re-generate the views file.</span></span> <span data-ttu-id="de3cf-273">Puede hacerlo mediante la ejecución EDMGen con el **/mode:ViewGeneration** marca.</span><span class="sxs-lookup"><span data-stu-id="de3cf-273">You can do this by running EDMGen with the **/mode:ViewGeneration** flag.</span></span>

#### <a name="233-how-to-use-pre-generated-views-with-an-edmx-file"></a><span data-ttu-id="de3cf-274">2.3.3 cómo usar vistas Pre-Generated con un archivo EDMX</span><span class="sxs-lookup"><span data-stu-id="de3cf-274">2.3.3 How to use Pre-Generated Views with an EDMX file</span></span>

<span data-ttu-id="de3cf-275">También puede usar EDMGen para generar vistas para un archivo EDMX: el tema de MSDN mencionado anteriormente describe cómo agregar un evento anterior a la compilación para hacer esto - pero esto es complicado y existen algunos casos donde no es posible.</span><span class="sxs-lookup"><span data-stu-id="de3cf-275">You can also use EDMGen to generate views for an EDMX file - the previously referenced MSDN topic describes how to add a pre-build event to do this - but this is complicated and there are some cases where it isn't possible.</span></span> <span data-ttu-id="de3cf-276">Es por lo general más fácil de usar una plantilla T4 para generar las vistas cuando el modelo está en un archivo edmx.</span><span class="sxs-lookup"><span data-stu-id="de3cf-276">It's generally easier to use a T4 template to generate the views when your model is in an edmx file.</span></span>

<span data-ttu-id="de3cf-277">El blog del equipo ADO.NET tiene una entrada de blog que describe cómo utilizar una plantilla T4 para la generación de vistas ( \<http://blogs.msdn.com/b/adonet/archive/2008/06/20/how-to-use-a-t4-template-for-view-generation.aspx>).</span><span class="sxs-lookup"><span data-stu-id="de3cf-277">The ADO.NET team blog has a post that describes how to use a T4 template for view generation ( \<http://blogs.msdn.com/b/adonet/archive/2008/06/20/how-to-use-a-t4-template-for-view-generation.aspx>).</span></span> <span data-ttu-id="de3cf-278">Esta publicación incluye una plantilla que se puede descargar y agregada al proyecto.</span><span class="sxs-lookup"><span data-stu-id="de3cf-278">This post includes a template that can be downloaded and added to your project.</span></span> <span data-ttu-id="de3cf-279">La plantilla se escribió para la primera versión de Entity Framework, por lo que no se garantiza que funcionen con las últimas versiones de Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="de3cf-279">The template was written for the first version of Entity Framework, so they aren’t guaranteed to work with the latest versions of Entity Framework.</span></span> <span data-ttu-id="de3cf-280">Sin embargo, puede descargar un conjunto de plantillas de generación de la vista más actualizado para Entity Framework 4 y 5from la Galería de Visual Studio:</span><span class="sxs-lookup"><span data-stu-id="de3cf-280">However, you can download a more up-to-date set of view generation templates for Entity Framework 4 and 5from the Visual Studio Gallery:</span></span>

-   <span data-ttu-id="de3cf-281">VB.NET: \<http://visualstudiogallery.msdn.microsoft.com/118b44f2-1b91-4de2-a584-7a680418941d></span><span class="sxs-lookup"><span data-stu-id="de3cf-281">VB.NET: \<http://visualstudiogallery.msdn.microsoft.com/118b44f2-1b91-4de2-a584-7a680418941d></span></span>
-   <span data-ttu-id="de3cf-282">C\#: \<http://visualstudiogallery.msdn.microsoft.com/ae7730ce-ddab-470f-8456-1b313cd2c44d></span><span class="sxs-lookup"><span data-stu-id="de3cf-282">C\#: \<http://visualstudiogallery.msdn.microsoft.com/ae7730ce-ddab-470f-8456-1b313cd2c44d></span></span>

<span data-ttu-id="de3cf-283">Si usa Entity Framework 6 puede obtener la vista por plantillas T4 de generación de la Galería de Visual Studio en \<http://visualstudiogallery.msdn.microsoft.com/18a7db90-6705-4d19-9dd1-0a6c23d0751f>.</span><span class="sxs-lookup"><span data-stu-id="de3cf-283">If you’re using Entity Framework 6 you can get the view generation T4 templates from the Visual Studio Gallery at \<http://visualstudiogallery.msdn.microsoft.com/18a7db90-6705-4d19-9dd1-0a6c23d0751f>.</span></span>

### <a name="24-reducing-the-cost-of-view-generation"></a><span data-ttu-id="de3cf-284">2.4, lo que reduce el costo de la generación de vistas</span><span class="sxs-lookup"><span data-stu-id="de3cf-284">2.4 Reducing the cost of view generation</span></span>

<span data-ttu-id="de3cf-285">Uso de las vistas generadas previamente mueve el costo de la generación de la vista de modelo de carga (tiempo de ejecución) al tiempo de diseño.</span><span class="sxs-lookup"><span data-stu-id="de3cf-285">Using pre-generated views moves the cost of view generation from model loading (run time) to design time.</span></span> <span data-ttu-id="de3cf-286">Aunque esto mejora el rendimiento de inicio en tiempo de ejecución, sigue experimentando la dificultad de generación de la vista mientras está desarrollando.</span><span class="sxs-lookup"><span data-stu-id="de3cf-286">While this improves startup performance at runtime, you will still experience the pain of view generation while you are developing.</span></span> <span data-ttu-id="de3cf-287">Existen varios trucos adicionales que pueden ayudar a reducir el costo de generación de la vista, tanto en tiempo de compilación y tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="de3cf-287">There are several additional tricks that can help reduce the cost of view generation, both at compile time and run time.</span></span>

#### <a name="241-using-foreign-key-associations-to-reduce-view-generation-cost"></a><span data-ttu-id="de3cf-288">2.4.1 utilizando las asociaciones de clave externa para reducir los costos de generación de vista</span><span class="sxs-lookup"><span data-stu-id="de3cf-288">2.4.1 Using Foreign Key Associations to reduce view generation cost</span></span>

<span data-ttu-id="de3cf-289">Hemos visto un número de casos que cambiar drásticamente las asociaciones en el modelo de asociaciones independientes a las asociaciones de clave externa mejora el tiempo empleado en la generación de la vista.</span><span class="sxs-lookup"><span data-stu-id="de3cf-289">We have seen a number of cases where switching the associations in the model from Independent Associations to Foreign Key Associations dramatically improved the time spent in view generation.</span></span>

<span data-ttu-id="de3cf-290">Para demostrar esta mejora, se generan dos versiones del modelo Navision mediante EDMGen.</span><span class="sxs-lookup"><span data-stu-id="de3cf-290">To demonstrate this improvement, we generated two versions of the Navision model by using EDMGen.</span></span> <span data-ttu-id="de3cf-291">*Nota: seeappendix Cfor una descripción del modelo Navision.*</span><span class="sxs-lookup"><span data-stu-id="de3cf-291">*Note: seeappendix Cfor a description of the Navision model.*</span></span> <span data-ttu-id="de3cf-292">El modelo Navision es interesante para este ejercicio debido a su gran cantidad de entidades y relaciones entre ellos.</span><span class="sxs-lookup"><span data-stu-id="de3cf-292">The Navision model is interesting for this exercise due to its very large amount of entities and relationships between them.</span></span>

<span data-ttu-id="de3cf-293">Se ha generado una versión de este modelo muy grande con asociaciones de las claves externas y la otra se generó con asociaciones independientes.</span><span class="sxs-lookup"><span data-stu-id="de3cf-293">One version of this very large model was generated with Foreign Keys Associations and the other was generated with Independent Associations.</span></span> <span data-ttu-id="de3cf-294">Hemos, a continuación, ha superado el tiempo ¿cuánto tiempo se tardó en generar las vistas para cada modelo.</span><span class="sxs-lookup"><span data-stu-id="de3cf-294">We then timed how long it took to generate the views for each model.</span></span> <span data-ttu-id="de3cf-295">Prueba Framework5 de entidad usa el método GenerateViews() de la clase EntityViewGenerator para generar las vistas, mientras que la prueba de Entity Framework 6 usa el método GenerateViews() de la clase StorageMappingItemCollection.</span><span class="sxs-lookup"><span data-stu-id="de3cf-295">Entity Framework5 test used the GenerateViews() method from class EntityViewGenerator to generate the views, while the Entity Framework 6 test used the GenerateViews() method from class StorageMappingItemCollection.</span></span> <span data-ttu-id="de3cf-296">Esto debido a la reestructuración de código que se produjeron en la base de código de Entity Framework 6.</span><span class="sxs-lookup"><span data-stu-id="de3cf-296">This due to code restructuring that occurred in the Entity Framework 6 codebase.</span></span>

<span data-ttu-id="de3cf-297">Con Entity Framework 5, generación de la vista para el modelo con claves externas tardó 65 minutos en una máquina de laboratorio.</span><span class="sxs-lookup"><span data-stu-id="de3cf-297">Using Entity Framework 5, view generation for the model with Foreign Keys took 65 minutes in a lab machine.</span></span> <span data-ttu-id="de3cf-298">Se desconoce el tiempo que habría necesitado para generar las vistas para el modelo que usa asociaciones independientes.</span><span class="sxs-lookup"><span data-stu-id="de3cf-298">It's unknown how long it would have taken to generate the views for the model that used independent associations.</span></span> <span data-ttu-id="de3cf-299">Hemos dejado la prueba en ejecución durante más de un mes antes de que se ha reiniciado el equipo en nuestro laboratorio para instalar las actualizaciones mensuales.</span><span class="sxs-lookup"><span data-stu-id="de3cf-299">We left the test running for over a month before the machine was rebooted in our lab to install monthly updates.</span></span>

<span data-ttu-id="de3cf-300">Mediante Entity Framework 6, generación de la vista para el modelo con claves externas tardó 28 segundos en el mismo equipo de laboratorio.</span><span class="sxs-lookup"><span data-stu-id="de3cf-300">Using Entity Framework 6, view generation for the model with Foreign Keys took 28 seconds in the same lab machine.</span></span> <span data-ttu-id="de3cf-301">Generación de la vista para el modelo que usa asociaciones independientes tardó 58 segundos.</span><span class="sxs-lookup"><span data-stu-id="de3cf-301">View generation for the model that uses Independent Associations took 58 seconds.</span></span> <span data-ttu-id="de3cf-302">Las mejoras de hecho a Entity Framework 6 en su código de generación de vista significan que muchos proyectos no tendrán las vistas generadas previamente para obtener tiempos de inicio más rápidos.</span><span class="sxs-lookup"><span data-stu-id="de3cf-302">The improvements done to Entity Framework 6 on its view generation code mean that many projects won’t need pre-generated views to obtain faster startup times.</span></span>

<span data-ttu-id="de3cf-303">Es importante para el comentario que generar previamente las vistas en Entity Framework 4 y 5 puede hacerse con EDMGen o Entity Framework Power Tools.</span><span class="sxs-lookup"><span data-stu-id="de3cf-303">It’s important to remark that pre-generating views in Entity Framework 4 and 5 can be done with EDMGen or the Entity Framework Power Tools.</span></span> <span data-ttu-id="de3cf-304">Para la vista de Entity Framework 6 generación puede realizarse a través de Entity Framework Power Tools o mediante programación, como se describe en [Pre-Generated asignación vistas](~/ef6/fundamentals/performance/pre-generated-views.md).</span><span class="sxs-lookup"><span data-stu-id="de3cf-304">For Entity Framework 6 view generation can be done via the Entity Framework Power Tools or programmatically as described in [Pre-Generated Mapping Views](~/ef6/fundamentals/performance/pre-generated-views.md).</span></span>

##### <a name="2411-how-to-use-foreign-keys-instead-of-independent-associations"></a><span data-ttu-id="de3cf-305">2.4.1.1 cómo usar las claves externas en lugar de asociaciones independientes</span><span class="sxs-lookup"><span data-stu-id="de3cf-305">2.4.1.1 How to use Foreign Keys instead of Independent Associations</span></span>

<span data-ttu-id="de3cf-306">Al usar EDMGen o Entity Designer en Visual Studio, obtenga las claves externas de forma predeterminada y solo toma una única marca de casilla o de línea de comandos para cambiar entre las claves externas e IAs.</span><span class="sxs-lookup"><span data-stu-id="de3cf-306">When using EDMGen or the Entity Designer in Visual Studio, you get FKs by default, and it only takes a single checkbox or command line flag to switch between FKs and IAs.</span></span>

<span data-ttu-id="de3cf-307">Si tiene un modelo de Code First grande, uso de asociaciones independientes tendrán el mismo efecto en la generación de la vista.</span><span class="sxs-lookup"><span data-stu-id="de3cf-307">If you have a large Code First model, using Independent Associations will have the same effect on view generation.</span></span> <span data-ttu-id="de3cf-308">Puede evitar este impacto mediante la inclusión de propiedades de clave externa en las clases para los objetos dependientes, aunque algunos desarrolladores tendrá en cuenta esta opción para ser contaminar su modelo de objetos.</span><span class="sxs-lookup"><span data-stu-id="de3cf-308">You can avoid this impact by including Foreign Key properties on the classes for your dependent objects, though some developers will consider this to be polluting their object model.</span></span> <span data-ttu-id="de3cf-309">Puede encontrar más información sobre este tema en \<http://blog.oneunicorn.com/2011/12/11/whats-the-deal-with-mapping-foreign-keys-using-the-entity-framework/>.</span><span class="sxs-lookup"><span data-stu-id="de3cf-309">You can find more information on this subject in \<http://blog.oneunicorn.com/2011/12/11/whats-the-deal-with-mapping-foreign-keys-using-the-entity-framework/>.</span></span>

| <span data-ttu-id="de3cf-310">Cuando se usa</span><span class="sxs-lookup"><span data-stu-id="de3cf-310">When using</span></span>      | <span data-ttu-id="de3cf-311">Haga esto</span><span class="sxs-lookup"><span data-stu-id="de3cf-311">Do this</span></span>                                                                                                                                                                                                                                                                                                                              |
|:----------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="de3cf-312">Diseñador de entidades</span><span class="sxs-lookup"><span data-stu-id="de3cf-312">Entity Designer</span></span> | <span data-ttu-id="de3cf-313">Después de agregar una asociación entre dos entidades, asegúrese de que tiene una restricción referencial.</span><span class="sxs-lookup"><span data-stu-id="de3cf-313">After adding an association between two entities, make sure you have a referential constraint.</span></span> <span data-ttu-id="de3cf-314">Las restricciones referenciales indicar a Entity Framework para usar las claves externas en lugar de asociaciones independientes.</span><span class="sxs-lookup"><span data-stu-id="de3cf-314">Referential constraints tell Entity Framework to use Foreign Keys instead of Independent Associations.</span></span> <span data-ttu-id="de3cf-315">Para obtener más información, visite \<http://blogs.msdn.com/b/efdesign/archive/2009/03/16/foreign-keys-in-the-entity-framework.aspx>.</span><span class="sxs-lookup"><span data-stu-id="de3cf-315">For additional details visit \<http://blogs.msdn.com/b/efdesign/archive/2009/03/16/foreign-keys-in-the-entity-framework.aspx>.</span></span> |
| <span data-ttu-id="de3cf-316">EDMGen</span><span class="sxs-lookup"><span data-stu-id="de3cf-316">EDMGen</span></span>          | <span data-ttu-id="de3cf-317">Cuando use EDMGen para generar los archivos de la base de datos, las claves externas se respeta y se agregará al modelo como tal.</span><span class="sxs-lookup"><span data-stu-id="de3cf-317">When using EDMGen to generate your files from the database, your Foreign Keys will be respected and added to the model as such.</span></span> <span data-ttu-id="de3cf-318">Para obtener más información sobre las distintas opciones que se expone de forma EDMGen visite [http://msdn.microsoft.com/library/bb387165.aspx](https://msdn.microsoft.com/library/bb387165.aspx).</span><span class="sxs-lookup"><span data-stu-id="de3cf-318">For more information on the different options exposed by EDMGen visit [http://msdn.microsoft.com/library/bb387165.aspx](https://msdn.microsoft.com/library/bb387165.aspx).</span></span>                           |
| <span data-ttu-id="de3cf-319">Code First</span><span class="sxs-lookup"><span data-stu-id="de3cf-319">Code First</span></span>      | <span data-ttu-id="de3cf-320">Consulte la sección "Convención relación" de la [convenciones de Code First](~/ef6/modeling/code-first/conventions/built-in.md) tema para obtener información sobre cómo incluir propiedades de clave externa en los objetos dependientes cuando utilice Code First.</span><span class="sxs-lookup"><span data-stu-id="de3cf-320">See the "Relationship Convention" section of the [Code First Conventions](~/ef6/modeling/code-first/conventions/built-in.md) topic for information on how to include foreign key properties on dependent objects when using Code First.</span></span>                                                                                              |

#### <a name="242-moving-your-model-to-a-separate-assembly"></a><span data-ttu-id="de3cf-321">2.4.2 moviendo el modelo a un ensamblado independiente</span><span class="sxs-lookup"><span data-stu-id="de3cf-321">2.4.2 Moving your model to a separate assembly</span></span>

<span data-ttu-id="de3cf-322">Cuando el modelo se incluye directamente en el proyecto de la aplicación y generar vistas a través de un evento anterior a la compilación o una plantilla T4, validación y generación de la vista llevará a cabo cada vez que se vuelve a generar el proyecto, incluso si no se ha cambiado el modelo.</span><span class="sxs-lookup"><span data-stu-id="de3cf-322">When your model is included directly in your application's project and you generate views through a pre-build event or a T4 template, view generation and validation will take place whenever the project is rebuilt, even if the model wasn't changed.</span></span> <span data-ttu-id="de3cf-323">Si pasa el modelo a un ensamblado independiente y hacer referencia a él desde el proyecto de la aplicación, puede realizar otros cambios a la aplicación sin tener que recompilar el proyecto que contiene el modelo.</span><span class="sxs-lookup"><span data-stu-id="de3cf-323">If you move the model to a separate assembly and reference it from your application's project, you can make other changes to your application without needing to rebuild the project containing the model.</span></span>

<span data-ttu-id="de3cf-324">*Nota:*  al mover el modelo para separar los ensamblados no olvide copiar las cadenas de conexión para el modelo en el archivo de configuración del proyecto de cliente.</span><span class="sxs-lookup"><span data-stu-id="de3cf-324">*Note:*  when moving your model to separate assemblies remember to copy the connection strings for the model into the application configuration file of the client project.</span></span>

#### <a name="243-disable-validation-of-an-edmx-based-model"></a><span data-ttu-id="de3cf-325">2.4.3 deshabilitar la validación de un modelo basado en edmx</span><span class="sxs-lookup"><span data-stu-id="de3cf-325">2.4.3 Disable validation of an edmx-based model</span></span>

<span data-ttu-id="de3cf-326">Con modelos EDMX se validan en tiempo de compilación, incluso si el modelo se ha modificado.</span><span class="sxs-lookup"><span data-stu-id="de3cf-326">EDMX models are validated at compile time, even if the model is unchanged.</span></span> <span data-ttu-id="de3cf-327">Si ya se ha validado el modelo, puede suprimir la validación en tiempo de compilación estableciendo la propiedad "Validar al compilar" en false en la ventana Propiedades.</span><span class="sxs-lookup"><span data-stu-id="de3cf-327">If your model has already been validated, you can suppress validation at compile time by setting the "Validate on Build" property to false in the properties window.</span></span> <span data-ttu-id="de3cf-328">Al cambiar la asignación o el modelo, temporalmente puede volver a habilitar la validación para comprobar los cambios.</span><span class="sxs-lookup"><span data-stu-id="de3cf-328">When you change your mapping or model, you can temporarily re-enable validation to verify your changes.</span></span>

<span data-ttu-id="de3cf-329">Tenga en cuenta que se han realizado mejoras de rendimiento para el Diseñador de Entity Framework para Entity Framework 6 y el costo de la "validar en la compilación" es mucho menor que en versiones anteriores del diseñador.</span><span class="sxs-lookup"><span data-stu-id="de3cf-329">Note that performance improvements were made to the Entity Framework Designer for Entity Framework 6, and the cost of the “Validate on Build” is much lower than in previous versions of the designer.</span></span>

## <a name="3-caching-in-the-entity-framework"></a><span data-ttu-id="de3cf-330">3 de almacenamiento en caché en Entity Framework</span><span class="sxs-lookup"><span data-stu-id="de3cf-330">3 Caching in the Entity Framework</span></span>

<span data-ttu-id="de3cf-331">Entity Framework tiene las siguientes formas de almacenamiento en caché integrado:</span><span class="sxs-lookup"><span data-stu-id="de3cf-331">Entity Framework has the following forms of caching built-in:</span></span>

1.  <span data-ttu-id="de3cf-332">Objeto de almacenamiento en caché: ObjectStateManager integrado en una instancia de ObjectContext realiza un seguimiento de los objetos que se han recuperado mediante esa instancia en memoria.</span><span class="sxs-lookup"><span data-stu-id="de3cf-332">Object caching – the ObjectStateManager built into an ObjectContext instance keeps track in memory of the objects that have been retrieved using that instance.</span></span> <span data-ttu-id="de3cf-333">Esto es también conocida como caché de primer nivel.</span><span class="sxs-lookup"><span data-stu-id="de3cf-333">This is also known as first-level cache.</span></span>
2.  <span data-ttu-id="de3cf-334">Caching de Plan de consulta: volver a usar el comando generado cuando se ejecuta una consulta más de una vez.</span><span class="sxs-lookup"><span data-stu-id="de3cf-334">Query Plan Caching - reusing the generated store command when a query is executed more than once.</span></span>
3.  <span data-ttu-id="de3cf-335">Metadatos de almacenamiento en caché: los metadatos para un modelo de uso compartido a través de diferentes conexiones con el mismo modelo.</span><span class="sxs-lookup"><span data-stu-id="de3cf-335">Metadata caching - sharing the metadata for a model across different connections to the same model.</span></span>

<span data-ttu-id="de3cf-336">Además de las memorias caché que ofrece EF desde el principio, un tipo especial de proveedor de datos ADO.NET, conocido como un proveedor de ajuste también se puede usar para extender el marco de entidad con una memoria caché para los resultados recuperados de la base de datos, también conocido como almacenamiento en caché de segundo nivel.</span><span class="sxs-lookup"><span data-stu-id="de3cf-336">Besides the caches that EF provides out of the box, a special kind of ADO.NET data provider known as a wrapping provider can also be used to extend Entity Framework with a cache for the results retrieved from the database, also known as second-level caching.</span></span>

### <a name="31-object-caching"></a><span data-ttu-id="de3cf-337">3.1 objeto de almacenamiento en caché</span><span class="sxs-lookup"><span data-stu-id="de3cf-337">3.1 Object Caching</span></span>

<span data-ttu-id="de3cf-338">De forma predeterminada cuando se devuelve una entidad en los resultados de una consulta, justo antes de que EF materializa, ObjectContext comprobará si una entidad con la misma clave ya se han cargado en el ObjectStateManager.</span><span class="sxs-lookup"><span data-stu-id="de3cf-338">By default when an entity is returned in the results of a query, just before EF materializes it, the ObjectContext will check if an entity with the same key has already been loaded into its ObjectStateManager.</span></span> <span data-ttu-id="de3cf-339">Si ya hay una entidad con las mismas claves EF incluirá en los resultados de la consulta.</span><span class="sxs-lookup"><span data-stu-id="de3cf-339">If an entity with the same keys is already present EF will include it in the results of the query.</span></span> <span data-ttu-id="de3cf-340">Aunque EF sigue emitirá la consulta en la base de datos, puede omitir este comportamiento gran parte del costo de materializar la entidad varias veces.</span><span class="sxs-lookup"><span data-stu-id="de3cf-340">Although EF will still issue the query against the database, this behavior can bypass much of the cost of materializing the entity multiple times.</span></span>

#### <a name="311-getting-entities-from-the-object-cache-using-dbcontext-find"></a><span data-ttu-id="de3cf-341">3.1.1 obtener entidades de la caché de objetos mediante DbContext Find</span><span class="sxs-lookup"><span data-stu-id="de3cf-341">3.1.1 Getting entities from the object cache using DbContext Find</span></span>

<span data-ttu-id="de3cf-342">A diferencia de una consulta regular, el método Find en DbSet (API incluidas por primera vez en EF 4.1) llevará a cabo una búsqueda en la memoria antes de emitir incluso la consulta en la base de datos.</span><span class="sxs-lookup"><span data-stu-id="de3cf-342">Unlike a regular query, the Find method in DbSet (APIs included for the first time in EF 4.1) will perform a search in memory before even issuing the query against the database.</span></span> <span data-ttu-id="de3cf-343">Es importante tener en cuenta que dos instancias distintas de ObjectContext tendrá dos instancias de ObjectStateManager diferentes, lo que significa que tienen las memorias caché de objeto independiente.</span><span class="sxs-lookup"><span data-stu-id="de3cf-343">It’s important to note that two different ObjectContext instances will have two different ObjectStateManager instances, meaning that they have separate object caches.</span></span>

<span data-ttu-id="de3cf-344">Búsqueda usa el valor de clave principal para intentar buscar una entidad en el contexto realiza el seguimiento.</span><span class="sxs-lookup"><span data-stu-id="de3cf-344">Find uses the primary key value to attempt to find an entity tracked by the context.</span></span> <span data-ttu-id="de3cf-345">Si la entidad no está en el contexto, a continuación, una consulta se ejecuta y evalúa con respecto a la base de datos y se devuelve null si no se encuentra la entidad en el contexto o en la base de datos.</span><span class="sxs-lookup"><span data-stu-id="de3cf-345">If the entity is not in the context then a query will be executed and evaluated against the database, and null is returned if the entity is not found in the context or in the database.</span></span> <span data-ttu-id="de3cf-346">Tenga en cuenta que encuentre también devuelve las entidades que se han agregado al contexto, pero aún no se han guardado en la base de datos.</span><span class="sxs-lookup"><span data-stu-id="de3cf-346">Note that Find also returns entities that have been added to the context but have not yet been saved to the database.</span></span>

<span data-ttu-id="de3cf-347">Hay una consideración de rendimiento que se realizará cuando el uso de la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="de3cf-347">There is a performance consideration to be taken when using Find.</span></span> <span data-ttu-id="de3cf-348">Las llamadas a este método de forma predeterminada desencadenarán una validación de la caché de objetos con el fin de detectar cambios siguen pendientes de confirmación a la base de datos.</span><span class="sxs-lookup"><span data-stu-id="de3cf-348">Invocations to this method by default will trigger a validation of the object cache in order to detect changes that are still pending commit to the database.</span></span> <span data-ttu-id="de3cf-349">Este proceso puede resultar muy caro si hay un gran número de objetos en la caché de objetos o en un gráfico de objetos grandes que se va a agregar a la caché de objetos, pero también se puede deshabilitar.</span><span class="sxs-lookup"><span data-stu-id="de3cf-349">This process can be very expensive if there are a very large number of objects in the object cache or in a large object graph being added to the object cache, but it can also be disabled.</span></span> <span data-ttu-id="de3cf-350">En algunos casos, pueden percibir a través de un orden de magnitud de diferencia en la llamada a la búsqueda de método cuando se deshabilita automáticamente detectar cambios.</span><span class="sxs-lookup"><span data-stu-id="de3cf-350">In certain cases, you may perceive over an order of magnitude of difference in calling the Find method when you disable auto detect changes.</span></span> <span data-ttu-id="de3cf-351">Aún se percibe un segundo orden de magnitud cuando el objeto está realmente en la caché frente a cuando el objeto tiene que deben recuperarse de la base de datos.</span><span class="sxs-lookup"><span data-stu-id="de3cf-351">Yet a second order of magnitude is perceived when the object actually is in the cache versus when the object has to be retrieved from the database.</span></span> <span data-ttu-id="de3cf-352">Este es un gráfico de ejemplo con las mediciones tomadas con algunos de nuestros microbenchmarks, expresado en milisegundos, con una carga de 5000 entidades:</span><span class="sxs-lookup"><span data-stu-id="de3cf-352">Here is an example graph with measurements taken using some of our microbenchmarks, expressed in milliseconds, with a load of 5000 entities:</span></span>

<span data-ttu-id="de3cf-353">![Escala logarítmica de .NET 4.5](~/ef6/media/net45logscale.png ".NET 4.5 - escala logarítmica")</span><span class="sxs-lookup"><span data-stu-id="de3cf-353">![.NET 4.5 logarithmic scale](~/ef6/media/net45logscale.png ".NET 4.5 - logarithmic scale")</span></span>

<span data-ttu-id="de3cf-354">Ejemplo de búsqueda con los cambios de la detección automática deshabilitada:</span><span class="sxs-lookup"><span data-stu-id="de3cf-354">Example of Find with auto-detect changes disabled:</span></span>

``` csharp
    context.Configuration.AutoDetectChangesEnabled = false;
    var product = context.Products.Find(productId);
    context.Configuration.AutoDetectChangesEnabled = true;
    ...
```

<span data-ttu-id="de3cf-355">¿Qué debe tener en cuenta al usar el método Find es:</span><span class="sxs-lookup"><span data-stu-id="de3cf-355">What you have to consider when using the Find method is:</span></span>

1.  <span data-ttu-id="de3cf-356">Si el objeto no está en la memoria caché se niega los beneficios de buscar, pero la sintaxis es aún más sencilla que una consulta mediante la clave.</span><span class="sxs-lookup"><span data-stu-id="de3cf-356">If the object is not in the cache the benefits of Find are negated, but the syntax is still simpler than a query by key.</span></span>
2.  <span data-ttu-id="de3cf-357">Si los cambios de detección automática está habilitada puede aumentar el costo del método Find en un orden de magnitud, o incluso más según la complejidad de su modelo y la cantidad de entidades en la memoria caché de objetos.</span><span class="sxs-lookup"><span data-stu-id="de3cf-357">If auto detect changes is enabled the cost of the Find method may increase by one order of magnitude, or even more depending on the complexity of your model and the amount of entities in your object cache.</span></span>

<span data-ttu-id="de3cf-358">Además, tenga en cuenta que busque sólo devuelve la entidad que está buscando y lo hace automáticamente carga sus entidades asociadas si aún no están en la caché de objetos.</span><span class="sxs-lookup"><span data-stu-id="de3cf-358">Also, keep in mind that Find only returns the entity you are looking for and it does not automatically loads its associated entities if they are not already in the object cache.</span></span> <span data-ttu-id="de3cf-359">Si necesita recuperar las entidades asociadas, puede usar una consulta mediante la clave con la carga diligente.</span><span class="sxs-lookup"><span data-stu-id="de3cf-359">If you need to retrieve associated entities, you can use a query by key with eager loading.</span></span> <span data-ttu-id="de3cf-360">Para obtener más información, consulte **8.1 frente a la carga diferida. La carga diligente**.</span><span class="sxs-lookup"><span data-stu-id="de3cf-360">For more information see **8.1 Lazy Loading vs. Eager Loading**.</span></span>

#### <a name="312-performance-issues-when-the-object-cache-has-many-entities"></a><span data-ttu-id="de3cf-361">3.1.2 problemas de rendimiento de cuando la caché de objetos tiene muchas entidades</span><span class="sxs-lookup"><span data-stu-id="de3cf-361">3.1.2 Performance issues when the object cache has many entities</span></span>

<span data-ttu-id="de3cf-362">La caché de objetos ayuda a aumentar la capacidad de respuesta general de Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="de3cf-362">The object cache helps to increase the overall responsiveness of Entity Framework.</span></span> <span data-ttu-id="de3cf-363">Sin embargo, cuando la caché de objetos tiene una gran cantidad de entidades cargadas puede afectar a ciertas operaciones, como agregar, quitar, buscar, entrada, SaveChanges y mucho más.</span><span class="sxs-lookup"><span data-stu-id="de3cf-363">However, when the object cache has a very large amount of entities loaded it may affect certain operations such as Add, Remove, Find, Entry, SaveChanges and more.</span></span> <span data-ttu-id="de3cf-364">En concreto, el operaciones que desencadenan una llamada a DetectChanges se verán afectadas negativamente por las memorias caché de objetos muy grandes.</span><span class="sxs-lookup"><span data-stu-id="de3cf-364">In particular, operations that trigger a call to DetectChanges will be negatively affected by very large object caches.</span></span> <span data-ttu-id="de3cf-365">DetectChanges sincroniza el gráfico de objetos con el Administrador de estado de objeto y su rendimiento determinada directamente por el tamaño del gráfico de objetos.</span><span class="sxs-lookup"><span data-stu-id="de3cf-365">DetectChanges synchronizes the object graph with the object state manager and its performance will determined directly by the size of the object graph.</span></span> <span data-ttu-id="de3cf-366">Para obtener más información acerca de DetectChanges, consulte [seguimiento de los cambios en entidades POCO](https://msdn.microsoft.com/library/dd456848.aspx).</span><span class="sxs-lookup"><span data-stu-id="de3cf-366">For more information about DetectChanges, see [Tracking Changes in POCO Entities](https://msdn.microsoft.com/library/dd456848.aspx).</span></span>

<span data-ttu-id="de3cf-367">Cuando se usa Entity Framework 6, los desarrolladores pueden realizar llamadas a AddRange y RemoveRange directamente en una clase DbSet, en lugar de efectuar una iteración en una colección y llamar a agregar una vez por cada instancia.</span><span class="sxs-lookup"><span data-stu-id="de3cf-367">When using Entity Framework 6, developers are able to call AddRange and RemoveRange directly on a DbSet, instead of iterating on a collection and calling Add once per instance.</span></span> <span data-ttu-id="de3cf-368">La ventaja de usar los métodos range es que el costo de DetectChanges solo se paga una vez para todo el conjunto de entidades en lugar de una vez por cada entidad agregada.</span><span class="sxs-lookup"><span data-stu-id="de3cf-368">The advantage of using the range methods is that the cost of DetectChanges is only paid once for the entire set of entities as opposed to once per each added entity.</span></span>

### <a name="32-query-plan-caching"></a><span data-ttu-id="de3cf-369">3.2 almacenamiento en caché de Plan de consulta de</span><span class="sxs-lookup"><span data-stu-id="de3cf-369">3.2 Query Plan Caching</span></span>

<span data-ttu-id="de3cf-370">La primera vez que se ejecuta una consulta, pasa por el compilador plan interno para traducir la consulta conceptual en el comando de almacén (por ejemplo, el T-SQL que se ejecuta cuando se ejecuta en SQL Server).</span><span class="sxs-lookup"><span data-stu-id="de3cf-370">The first time a query is executed, it goes through the internal plan compiler to translate the conceptual query into the store command (for example, the T-SQL which is executed when run against SQL Server).</span></span><span data-ttu-id="de3cf-371">  Si está habilitado el almacenamiento en caché del plan de consulta, la próxima vez que la consulta es ejecuta el almacén de comando se recupera directamente desde la caché del plan de consulta para su ejecución, omitiendo el compilador de plan.</span><span class="sxs-lookup"><span data-stu-id="de3cf-371">  If query plan caching is enabled, the next time the query is executed the store command is retrieved directly from the query plan cache for execution, bypassing the plan compiler.</span></span>

<span data-ttu-id="de3cf-372">La caché del plan de consulta se comparte entre las instancias de ObjectContext dentro del mismo AppDomain.</span><span class="sxs-lookup"><span data-stu-id="de3cf-372">The query plan cache is shared across ObjectContext instances within the same AppDomain.</span></span> <span data-ttu-id="de3cf-373">No es necesario retener una instancia de ObjectContext para beneficiarse del almacenamiento en caché del plan de consulta.</span><span class="sxs-lookup"><span data-stu-id="de3cf-373">You don't need to hold onto an ObjectContext instance to benefit from query plan caching.</span></span>

#### <a name="321-some-notes-about-query-plan-caching"></a><span data-ttu-id="de3cf-374">3.2.1 algunas notas acerca de la caché de Plan de consultas</span><span class="sxs-lookup"><span data-stu-id="de3cf-374">3.2.1 Some notes about Query Plan Caching</span></span>

-   <span data-ttu-id="de3cf-375">Se comparte la caché del plan de consulta para todos los tipos de consulta: Entity SQL, LINQ to Entities y los objetos de CompiledQuery.</span><span class="sxs-lookup"><span data-stu-id="de3cf-375">The query plan cache is shared for all query types: Entity SQL, LINQ to Entities, and CompiledQuery objects.</span></span>
-   <span data-ttu-id="de3cf-376">De forma predeterminada, el almacenamiento en caché del plan de consulta está habilitado para las consultas de Entity SQL, si se ejecuta a través de un EntityCommand o un elemento ObjectQuery.</span><span class="sxs-lookup"><span data-stu-id="de3cf-376">By default, query plan caching is enabled for Entity SQL queries, whether executed through an EntityCommand or through an ObjectQuery.</span></span> <span data-ttu-id="de3cf-377">También está habilitada de forma predeterminada para LINQ a consultas de las entidades de Entity Framework en .NET 4.5 y en Entity Framework 6</span><span class="sxs-lookup"><span data-stu-id="de3cf-377">It is also enabled by default for LINQ to Entities queries in Entity Framework on .NET 4.5, and in Entity Framework 6</span></span>
    -   <span data-ttu-id="de3cf-378">Almacenamiento en caché del plan de consulta se puede deshabilitar estableciendo la propiedad EnablePlanCaching (en EntityCommand o ObjectQuery) en false.</span><span class="sxs-lookup"><span data-stu-id="de3cf-378">Query plan caching can be disabled by setting the EnablePlanCaching property (on EntityCommand or ObjectQuery) to false.</span></span> <span data-ttu-id="de3cf-379">Por ejemplo:</span><span class="sxs-lookup"><span data-stu-id="de3cf-379">For example:</span></span>
``` csharp
                    var query = from customer in context.Customer
                                where customer.CustomerId == id
                                select new
                                {
                                    customer.CustomerId,
                                    customer.Name
                                };
                    ObjectQuery oQuery = query as ObjectQuery;
                    oQuery.EnablePlanCaching = false;
```
-   <span data-ttu-id="de3cf-380">Para las consultas parametrizadas, cambiar el valor del parámetro todavía alcanzará la consulta en caché.</span><span class="sxs-lookup"><span data-stu-id="de3cf-380">For parameterized queries, changing the parameter's value will still hit the cached query.</span></span> <span data-ttu-id="de3cf-381">Pero cambiar las facetas de un parámetro (por ejemplo, tamaño, precisión o escala) llegará a una entrada distinta en la memoria caché.</span><span class="sxs-lookup"><span data-stu-id="de3cf-381">But changing a parameter's facets (for example, size, precision, or scale) will hit a different entry in the cache.</span></span>
-   <span data-ttu-id="de3cf-382">Al utilizar Entity SQL, la cadena de consulta forma parte de la clave.</span><span class="sxs-lookup"><span data-stu-id="de3cf-382">When using Entity SQL, the query string is part of the key.</span></span> <span data-ttu-id="de3cf-383">Cambiar la consulta en absoluto dará como resultado en entradas de caché diferente, incluso si las consultas son funcionalmente equivalentes.</span><span class="sxs-lookup"><span data-stu-id="de3cf-383">Changing the query at all will result in different cache entries, even if the queries are functionally equivalent.</span></span> <span data-ttu-id="de3cf-384">Esto incluye los cambios de mayúsculas y minúsculas o espacio en blanco.</span><span class="sxs-lookup"><span data-stu-id="de3cf-384">This includes changes to casing or whitespace.</span></span>
-   <span data-ttu-id="de3cf-385">Al usar LINQ, se procesa la consulta para generar una parte de la clave.</span><span class="sxs-lookup"><span data-stu-id="de3cf-385">When using LINQ, the query is processed to generate a part of the key.</span></span> <span data-ttu-id="de3cf-386">Cambiar la expresión LINQ, por tanto, se generará una clave diferente.</span><span class="sxs-lookup"><span data-stu-id="de3cf-386">Changing the LINQ expression will therefore generate a different key.</span></span>
-   <span data-ttu-id="de3cf-387">Pueden aplicar otras limitaciones técnicas; Para obtener más información, consulte Autocompiled consultas.</span><span class="sxs-lookup"><span data-stu-id="de3cf-387">Other technical limitations may apply; see Autocompiled Queries for more details.</span></span>

#### <a name="322-cache-eviction-algorithm"></a><span data-ttu-id="de3cf-388">3.2.2 algoritmo de expulsión de caché</span><span class="sxs-lookup"><span data-stu-id="de3cf-388">3.2.2      Cache eviction algorithm</span></span>

<span data-ttu-id="de3cf-389">Comprender cómo el algoritmo interno funciona le ayudarán a averiguar cuando para habilitar o deshabilitar caché de plan de consulta.</span><span class="sxs-lookup"><span data-stu-id="de3cf-389">Understanding how the internal algorithm works will help you figure out when to enable or disable query plan caching.</span></span> <span data-ttu-id="de3cf-390">El algoritmo de limpieza es como sigue:</span><span class="sxs-lookup"><span data-stu-id="de3cf-390">The cleanup algorithm is as follows:</span></span>

1.  <span data-ttu-id="de3cf-391">Una vez que la memoria caché contiene un número de conjunto de entradas (800), se inicia un temporizador que periódicamente (una vez por minuto) barre la memoria caché.</span><span class="sxs-lookup"><span data-stu-id="de3cf-391">Once the cache contains a set number of entries (800), we start a timer that periodically (once-per-minute) sweeps the cache.</span></span>
2.  <span data-ttu-id="de3cf-392">Durante los rastreos de memoria caché, se quitan las entradas de la memoria caché en un LFRU (menos frecuentemente – usados recientemente) base.</span><span class="sxs-lookup"><span data-stu-id="de3cf-392">During cache sweeps, entries are removed from the cache on a LFRU (Least frequently – recently used) basis.</span></span> <span data-ttu-id="de3cf-393">Este algoritmo tiene número de llamadas y la antigüedad en cuenta al decidir las entradas que se expulsan.</span><span class="sxs-lookup"><span data-stu-id="de3cf-393">This algorithm takes both hit count and age into account when deciding which entries are ejected.</span></span>
3.  <span data-ttu-id="de3cf-394">Al final de cada barrido de caché, la memoria caché nuevo contiene 800 entradas.</span><span class="sxs-lookup"><span data-stu-id="de3cf-394">At the end of each cache sweep, the cache again contains 800 entries.</span></span>

<span data-ttu-id="de3cf-395">Todas las entradas de caché se consideran iguales al determinar las entradas que se va a expulsar.</span><span class="sxs-lookup"><span data-stu-id="de3cf-395">All cache entries are treated equally when determining which entries to evict.</span></span> <span data-ttu-id="de3cf-396">Esto significa que el comando de almacén para un CompiledQuery tiene la misma probabilidad de expulsión que el comando de almacén para una consulta de Entity SQL.</span><span class="sxs-lookup"><span data-stu-id="de3cf-396">This means the store command for a CompiledQuery has the same chance of eviction as the store command for an Entity SQL query.</span></span>

<span data-ttu-id="de3cf-397">Tenga en cuenta que el temporizador de expulsión de caché es entrara en acción cuando hay 800 entidades en la memoria caché, pero la memoria caché solo es más de 60 segundos después de este temporizador se inicia.</span><span class="sxs-lookup"><span data-stu-id="de3cf-397">Note that the cache eviction timer is kicked in when there are 800 entities in the cache, but the cache is only swept 60 seconds after this timer is started.</span></span> <span data-ttu-id="de3cf-398">Esto significa que hasta 60 segundos la memoria caché puede crecer a ser bastante grande.</span><span class="sxs-lookup"><span data-stu-id="de3cf-398">That means that for up to 60 seconds your cache may grow to be quite large.</span></span>

#### <a name="323-test-metrics-demonstrating-query-plan-caching-performance"></a><span data-ttu-id="de3cf-399">3.2.3 probar las métricas que muestran el rendimiento de almacenamiento en caché el plan de consulta</span><span class="sxs-lookup"><span data-stu-id="de3cf-399">3.2.3       Test Metrics demonstrating query plan caching performance</span></span>

<span data-ttu-id="de3cf-400">Para mostrar el efecto del plan de consulta en el rendimiento de la aplicación de almacenamiento en caché, se realiza una prueba donde se ejecuta un número de consultas de Entity SQL en el modelo de Navision.</span><span class="sxs-lookup"><span data-stu-id="de3cf-400">To demonstrate the effect of query plan caching on your application's performance, we performed a test where we executed a number of Entity SQL queries against the Navision model.</span></span> <span data-ttu-id="de3cf-401">Consulte el apéndice para obtener una descripción del modelo Navision y los tipos de consultas que se ejecutaron.</span><span class="sxs-lookup"><span data-stu-id="de3cf-401">See the appendix for a description of the Navision model and the types of queries which were executed.</span></span> <span data-ttu-id="de3cf-402">En esta prueba, primero se recorrer en iteración la lista de consultas y ejecute cada uno de ellos una vez para agregarlos a la memoria caché (si está habilitado el almacenamiento en caché).</span><span class="sxs-lookup"><span data-stu-id="de3cf-402">In this test, we first iterate through the list of queries and execute each one once to add them to the cache (if caching is enabled).</span></span> <span data-ttu-id="de3cf-403">Este paso es untimed.</span><span class="sxs-lookup"><span data-stu-id="de3cf-403">This step is untimed.</span></span> <span data-ttu-id="de3cf-404">A continuación, nos suspender el subproceso principal de más de 60 segundos permitir que la memoria caché de barrido de hiperparámetros para tener lugar; Por último, establecemos una iteración por la hora de la lista una 2ª para ejecutar las consultas en caché.</span><span class="sxs-lookup"><span data-stu-id="de3cf-404">Next, we sleep the main thread for over 60 seconds to allow cache sweeping to take place; finally, we iterate through the list a 2nd time to execute the cached queries.</span></span> <span data-ttu-id="de3cf-405">Además, le caché de planes de SQL Server se vacíe antes de que se ejecuta cada conjunto de consultas para que reflejen de las horas que obtenemos con precisión el beneficio proporcionado por la caché del plan de consulta.</span><span class="sxs-lookup"><span data-stu-id="de3cf-405">Additionally, he SQL Server plan cache is flushed before each set of queries is executed so that the times we obtain accurately reflect the benefit given by the query plan cache.</span></span>

##### <a name="3231-test-results"></a><span data-ttu-id="de3cf-406">3.2.3.1 los resultados de pruebas</span><span class="sxs-lookup"><span data-stu-id="de3cf-406">3.2.3.1       Test Results</span></span>

| <span data-ttu-id="de3cf-407">Prueba</span><span class="sxs-lookup"><span data-stu-id="de3cf-407">Test</span></span>                                                                   | <span data-ttu-id="de3cf-408">EF5 sin caché</span><span class="sxs-lookup"><span data-stu-id="de3cf-408">EF5 no cache</span></span> | <span data-ttu-id="de3cf-409">EF5 en caché</span><span class="sxs-lookup"><span data-stu-id="de3cf-409">EF5 cached</span></span> | <span data-ttu-id="de3cf-410">EF6 sin caché</span><span class="sxs-lookup"><span data-stu-id="de3cf-410">EF6 no cache</span></span> | <span data-ttu-id="de3cf-411">EF6 en caché</span><span class="sxs-lookup"><span data-stu-id="de3cf-411">EF6 cached</span></span> |
|:-----------------------------------------------------------------------|:-------------|:-----------|:-------------|:-----------|
| <span data-ttu-id="de3cf-412">Enumerar todas las 18723 consultas</span><span class="sxs-lookup"><span data-stu-id="de3cf-412">Enumerating all 18723 queries</span></span>                                          | <span data-ttu-id="de3cf-413">124</span><span class="sxs-lookup"><span data-stu-id="de3cf-413">124</span></span>          | <span data-ttu-id="de3cf-414">125.4</span><span class="sxs-lookup"><span data-stu-id="de3cf-414">125.4</span></span>      | <span data-ttu-id="de3cf-415">124.3</span><span class="sxs-lookup"><span data-stu-id="de3cf-415">124.3</span></span>        | <span data-ttu-id="de3cf-416">125.3</span><span class="sxs-lookup"><span data-stu-id="de3cf-416">125.3</span></span>      |
| <span data-ttu-id="de3cf-417">Evitar barrido (solo el primero 800 consultas, independientemente de complejidad)</span><span class="sxs-lookup"><span data-stu-id="de3cf-417">Avoiding sweep (just the first 800 queries, regardless of complexity)</span></span>  | <span data-ttu-id="de3cf-418">41.7</span><span class="sxs-lookup"><span data-stu-id="de3cf-418">41.7</span></span>         | <span data-ttu-id="de3cf-419">5.5</span><span class="sxs-lookup"><span data-stu-id="de3cf-419">5.5</span></span>        | <span data-ttu-id="de3cf-420">40,5</span><span class="sxs-lookup"><span data-stu-id="de3cf-420">40.5</span></span>         | <span data-ttu-id="de3cf-421">5.4</span><span class="sxs-lookup"><span data-stu-id="de3cf-421">5.4</span></span>        |
| <span data-ttu-id="de3cf-422">Solo las consultas AggregatingSubtotals (178 total: lo que evita el barrido)</span><span class="sxs-lookup"><span data-stu-id="de3cf-422">Just the AggregatingSubtotals queries (178 total - which avoids sweep)</span></span> | <span data-ttu-id="de3cf-423">39.5</span><span class="sxs-lookup"><span data-stu-id="de3cf-423">39.5</span></span>         | <span data-ttu-id="de3cf-424">4.5</span><span class="sxs-lookup"><span data-stu-id="de3cf-424">4.5</span></span>        | <span data-ttu-id="de3cf-425">38.1</span><span class="sxs-lookup"><span data-stu-id="de3cf-425">38.1</span></span>         | <span data-ttu-id="de3cf-426">4.6</span><span class="sxs-lookup"><span data-stu-id="de3cf-426">4.6</span></span>        |

<span data-ttu-id="de3cf-427">*Todas las horas en segundos.*</span><span class="sxs-lookup"><span data-stu-id="de3cf-427">*All times in seconds.*</span></span>

<span data-ttu-id="de3cf-428">Moral - cuando la ejecución de lotes de consultas distintivas (por ejemplo, creado dinámicamente las consultas), almacenamiento en caché no ayuda y el vaciado resultante de la memoria caché puede mantener las consultas que se beneficiarían de la mayoría de almacenamiento en caché del plan de usarla realmente.</span><span class="sxs-lookup"><span data-stu-id="de3cf-428">Moral - when executing lots of distinct queries (for example,  dynamically created queries), caching doesn't help and the resulting flushing of the cache can keep the queries that would benefit the most from plan caching from actually using it.</span></span>

<span data-ttu-id="de3cf-429">Las consultas AggregatingSubtotals son más complejas de las consultas que hemos probado con.</span><span class="sxs-lookup"><span data-stu-id="de3cf-429">The AggregatingSubtotals queries are the most complex of the queries we tested with.</span></span> <span data-ttu-id="de3cf-430">Según lo previsto, es más complejo de la consulta, más ventajas verá del almacenamiento en caché del plan de consulta.</span><span class="sxs-lookup"><span data-stu-id="de3cf-430">As expected, the more complex the query is, the more benefit you will see from query plan caching.</span></span>

<span data-ttu-id="de3cf-431">Dado que un CompiledQuery es realmente una consulta LINQ con su plan en caché, la comparación de un CompiledQuery frente a la consulta de Entity SQL equivalente debe tener resultados similares.</span><span class="sxs-lookup"><span data-stu-id="de3cf-431">Because a CompiledQuery is really a LINQ query with its plan cached, the comparison of a CompiledQuery versus the equivalent Entity SQL query should have similar results.</span></span> <span data-ttu-id="de3cf-432">De hecho, si una aplicación tiene una gran cantidad de consultas de Entity SQL dinámicas, llenar la memoria caché con consultas también provocará CompiledQueries "descompilar" cuando se vacían de la memoria caché.</span><span class="sxs-lookup"><span data-stu-id="de3cf-432">In fact, if an app has lots of dynamic Entity SQL queries, filling the cache with queries will also effectively cause CompiledQueries to “decompile” when they are flushed from the cache.</span></span> <span data-ttu-id="de3cf-433">En este escenario, puede mejorar el rendimiento al deshabilitar el almacenamiento en caché en las consultas dinámicas para dar prioridad a la CompiledQueries.</span><span class="sxs-lookup"><span data-stu-id="de3cf-433">In this scenario, performance may be improved by disabling caching on the dynamic queries to prioritize the CompiledQueries.</span></span> <span data-ttu-id="de3cf-434">Mejor aún, por supuesto, sería volver a escribir la aplicación para usar consultas parametrizadas en lugar de consultas dinámicas.</span><span class="sxs-lookup"><span data-stu-id="de3cf-434">Better yet, of course, would be to rewrite the app to use parameterized queries instead of dynamic queries.</span></span>

### <a name="33-using-compiledquery-to-improve-performance-with-linq-queries"></a><span data-ttu-id="de3cf-435">3.3 usar CompiledQuery para mejorar el rendimiento con las consultas LINQ</span><span class="sxs-lookup"><span data-stu-id="de3cf-435">3.3 Using CompiledQuery to improve performance with LINQ queries</span></span>

<span data-ttu-id="de3cf-436">Nuestras pruebas indican que uso CompiledQuery puede aportar una ventaja de % 7 a través de autocompiled consultas LINQ; Esto significa que se pierda 7% menos tiempo ejecutando código de la pila de Entity Framework. no significa que la aplicación estará 7% más rápido.</span><span class="sxs-lookup"><span data-stu-id="de3cf-436">Our tests indicate that using CompiledQuery can bring a benefit of 7% over autocompiled LINQ queries; this means that you’ll spend 7% less time executing code from the Entity Framework stack; it does not mean your application will be 7% faster.</span></span> <span data-ttu-id="de3cf-437">Por lo general, el costo de escribir y mantener los objetos de CompiledQuery de EF 5.0 no puede ser que vale la pena el problema en comparación con las ventajas.</span><span class="sxs-lookup"><span data-stu-id="de3cf-437">Generally speaking, the cost of writing and maintaining CompiledQuery objects in EF 5.0 may not be worth the trouble when compared to the benefits.</span></span> <span data-ttu-id="de3cf-438">El kilometraje puede variar, así que actúan sobre esta opción si el proyecto requiere la inserción adicional.</span><span class="sxs-lookup"><span data-stu-id="de3cf-438">Your mileage may vary, so exercise this option if your project requires the extra push.</span></span> <span data-ttu-id="de3cf-439">Tenga en cuenta que CompiledQueries solo son compatibles con modelos de ObjectContext derivado y no es compatible con los modelos derivada de DbContext.</span><span class="sxs-lookup"><span data-stu-id="de3cf-439">Note that CompiledQueries are only compatible with ObjectContext-derived models, and not compatible with DbContext-derived models.</span></span>

<span data-ttu-id="de3cf-440">Para obtener más información sobre la creación e invocar un CompiledQuery, consulte [consultas compiladas (LINQ to Entities)](https://msdn.microsoft.com/library/bb896297.aspx).</span><span class="sxs-lookup"><span data-stu-id="de3cf-440">For more information on creating and invoking a CompiledQuery, see [Compiled Queries (LINQ to Entities)](https://msdn.microsoft.com/library/bb896297.aspx).</span></span>

<span data-ttu-id="de3cf-441">Existen dos consideraciones que debe seguir al usar un CompiledQuery, es decir, el requisito para utilizar instancias estáticas y los problemas que tienen con capacidad de composición.</span><span class="sxs-lookup"><span data-stu-id="de3cf-441">There are two considerations you have to take when using a CompiledQuery, namely the requirement to use static instances and the problems they have with composability.</span></span> <span data-ttu-id="de3cf-442">A continuación se sigue una explicación detallada de estos dos factores.</span><span class="sxs-lookup"><span data-stu-id="de3cf-442">Here follows an in-depth explanation of these two considerations.</span></span>

#### <a name="331-use-static-compiledquery-instances"></a><span data-ttu-id="de3cf-443">3.3.1 usar instancias estáticas de CompiledQuery</span><span class="sxs-lookup"><span data-stu-id="de3cf-443">3.3.1       Use static CompiledQuery instances</span></span>

<span data-ttu-id="de3cf-444">Dado que compilar una consulta LINQ es un proceso lento, no queremos hacerlo cada vez que se necesita capturar datos de la base de datos.</span><span class="sxs-lookup"><span data-stu-id="de3cf-444">Since compiling a LINQ query is a time-consuming process, we don’t want to do it every time we need to fetch data from the database.</span></span> <span data-ttu-id="de3cf-445">Las instancias de CompiledQuery le permiten compilar una vez y ejecutar varias veces, pero tener cuidado y adquirir para volver a usar la misma instancia de CompiledQuery cada vez en lugar de compilarlo y otra vez.</span><span class="sxs-lookup"><span data-stu-id="de3cf-445">CompiledQuery instances allow you to compile once and run multiple times, but you have to be careful and procure to re-use the same CompiledQuery instance every time instead of compiling it over and over again.</span></span> <span data-ttu-id="de3cf-446">El uso de los miembros estáticos para almacenar las instancias de CompiledQuery es necesario; en caso contrario, no verá ninguna ventaja.</span><span class="sxs-lookup"><span data-stu-id="de3cf-446">The use of static members to store the CompiledQuery instances becomes necessary; otherwise you won’t see any benefit.</span></span>

<span data-ttu-id="de3cf-447">Por ejemplo, supongamos que la página tiene el siguiente cuerpo de método para controlar la visualización de los productos para la categoría seleccionada:</span><span class="sxs-lookup"><span data-stu-id="de3cf-447">For example, suppose your page has the following method body to handle displaying the products for the selected category:</span></span>

``` csharp
    // Warning: this is the wrong way of using CompiledQuery
    using (NorthwindEntities context = new NorthwindEntities())
    {
        string selectedCategory = this.categoriesList.SelectedValue;

        var productsForCategory = CompiledQuery.Compile<NorthwindEntities, string, IQueryable<Product>>(
            (NorthwindEntities nwnd, string category) =>
                nwnd.Products.Where(p => p.Category.CategoryName == category)
        );

        this.productsGrid.DataSource = productsForCategory.Invoke(context, selectedCategory).ToList();
        this.productsGrid.DataBind();
    }

    this.productsGrid.Visible = true;
```

<span data-ttu-id="de3cf-448">En este caso, creará una nueva instancia de CompiledQuery sobre la marcha cada vez que se llama al método.</span><span class="sxs-lookup"><span data-stu-id="de3cf-448">In this case, you will create a new CompiledQuery instance on the fly every time the method is called.</span></span> <span data-ttu-id="de3cf-449">En lugar de ver las ventajas de rendimiento al recuperar el comando de almacén de la caché del plan de consulta, el CompiledQuery pasarán por el compilador plan cada vez que se crea una nueva instancia.</span><span class="sxs-lookup"><span data-stu-id="de3cf-449">Instead of seeing performance benefits by retrieving the store command from the query plan cache, the CompiledQuery will go through the plan compiler every time a new instance is created.</span></span> <span data-ttu-id="de3cf-450">De hecho, se pueden contaminar la caché del plan de consulta con una nueva entrada de CompiledQuery cada vez que se llama al método.</span><span class="sxs-lookup"><span data-stu-id="de3cf-450">In fact, you will be polluting your query plan cache with a new CompiledQuery entry every time the method is called.</span></span>

<span data-ttu-id="de3cf-451">En su lugar, desea crear una instancia estática de la consulta compilada, por lo que se está invocando la misma consulta compilada cada vez que se llama al método.</span><span class="sxs-lookup"><span data-stu-id="de3cf-451">Instead, you want to create a static instance of the compiled query, so you are invoking the same compiled query every time the method is called.</span></span> <span data-ttu-id="de3cf-452">Una manera de esto es mediante la adición de la instancia de CompiledQuery como miembro del contexto del objeto.</span><span class="sxs-lookup"><span data-stu-id="de3cf-452">One way to so this is by adding the CompiledQuery instance as a member of your object context.</span></span><span data-ttu-id="de3cf-453">  Posteriormente, puede hacer cosas un poco claro mediante el acceso a la CompiledQuery a través de un método auxiliar:</span><span class="sxs-lookup"><span data-stu-id="de3cf-453">  You can then make things a little cleaner by accessing the CompiledQuery through a helper method:</span></span>

``` csharp
    public partial class NorthwindEntities : ObjectContext
    {
        private static readonly Func<NorthwindEntities, string, IEnumerable<Product>> productsForCategoryCQ = CompiledQuery.Compile(
            (NorthwindEntities context, string categoryName) =>
                context.Products.Where(p => p.Category.CategoryName == categoryName)
            );

        public IEnumerable<Product> GetProductsForCategory(string categoryName)
        {
            return productsForCategoryCQ.Invoke(this, categoryName).ToList();
        }
```

<span data-ttu-id="de3cf-454">Este método auxiliar se invocaría como sigue:</span><span class="sxs-lookup"><span data-stu-id="de3cf-454">This helper method would be invoked as follows:</span></span>

``` csharp
    this.productsGrid.DataSource = context.GetProductsForCategory(selectedCategory);
```

#### <a name="332-composing-over-a-compiledquery"></a><span data-ttu-id="de3cf-455">3.3.2 componer sobre un CompiledQuery</span><span class="sxs-lookup"><span data-stu-id="de3cf-455">3.3.2       Composing over a CompiledQuery</span></span>

<span data-ttu-id="de3cf-456">La capacidad de crear a través de cualquier consulta LINQ es extremadamente útil; Para ello, basta con invocar un método después de IQueryable como *Skip()* o *Count()*.</span><span class="sxs-lookup"><span data-stu-id="de3cf-456">The ability to compose over any LINQ query is extremely useful; to do this, you simply invoke a method after the IQueryable such as *Skip()* or *Count()*.</span></span> <span data-ttu-id="de3cf-457">Sin embargo, si se realiza básicamente, devuelve un nuevo objeto IQueryable.</span><span class="sxs-lookup"><span data-stu-id="de3cf-457">However, doing so essentially returns a new IQueryable object.</span></span> <span data-ttu-id="de3cf-458">Aunque no hay nada que impida técnicamente componer sobre un CompiledQuery, esto hará que la generación de un nuevo objeto IQueryable requiere pasando por el compilador plan nuevo.</span><span class="sxs-lookup"><span data-stu-id="de3cf-458">While there’s nothing to stop you technically from composing over a CompiledQuery, doing so will cause the generation of a new IQueryable object that requires passing through the plan compiler again.</span></span>

<span data-ttu-id="de3cf-459">Algunos componentes hará uso de IQueryable compuesto objetos para habilitar la funcionalidad avanzada.</span><span class="sxs-lookup"><span data-stu-id="de3cf-459">Some components will make use of composed IQueryable objects to enable advanced functionality.</span></span> <span data-ttu-id="de3cf-460">Por ejemplo, ASP. GridView de la red puede estar enlazado a datos a un objeto IQueryable a través de la propiedad SelectMethod.</span><span class="sxs-lookup"><span data-stu-id="de3cf-460">For example, ASP.NET’s GridView can be data-bound to an IQueryable object via the SelectMethod property.</span></span> <span data-ttu-id="de3cf-461">El control GridView, a continuación, se creará sobre este objeto IQueryable para permitir la ordenación y paginación a través del modelo de datos.</span><span class="sxs-lookup"><span data-stu-id="de3cf-461">The GridView will then compose over this IQueryable object to allow sorting and paging over the data model.</span></span> <span data-ttu-id="de3cf-462">Como puede ver, utilizando un CompiledQuery de GridView podría no alcanzar la consulta compilada pero generaría una nueva consulta autocompiled.</span><span class="sxs-lookup"><span data-stu-id="de3cf-462">As you can see, using a CompiledQuery for the GridView would not hit the compiled query but would generate a new autocompiled query.</span></span>

<span data-ttu-id="de3cf-463">El equipo de asesoramiento al cliente se describe en su blog "Potencial rendimiento problemas con compilado LINQ consulta vuelve a compilar": <http://blogs.msdn.com/b/appfabriccat/archive/2010/08/06/potential-performance-issues-with-compiled-linq-query-re-compiles.aspx>.</span><span class="sxs-lookup"><span data-stu-id="de3cf-463">The Customer Advisory Team discusses this in their "Potential Performance Issues with Compiled LINQ Query Re-Compiles" blog post: <http://blogs.msdn.com/b/appfabriccat/archive/2010/08/06/potential-performance-issues-with-compiled-linq-query-re-compiles.aspx>.</span></span>

<span data-ttu-id="de3cf-464">Un único lugar donde puede encontrarse con esto es cuando se agregan filtros progresivos a una consulta.</span><span class="sxs-lookup"><span data-stu-id="de3cf-464">One place where you may run into this is when adding progressive filters to a query.</span></span> <span data-ttu-id="de3cf-465">Por ejemplo, suponga que tiene una página de los clientes con varias listas desplegables para filtros opcionales (por ejemplo, país y OrdersCount).</span><span class="sxs-lookup"><span data-stu-id="de3cf-465">For example, suppose you had a Customers page with several drop-down lists for optional filters (for example, Country and OrdersCount).</span></span> <span data-ttu-id="de3cf-466">Estos filtros puede redactar sobre los resultados de IQueryable de un CompiledQuery, pero hacerlo dará lugar a en la nueva consulta que pasar por el compilador plan cada vez que la ejecute.</span><span class="sxs-lookup"><span data-stu-id="de3cf-466">You can compose these filters over the IQueryable results of a CompiledQuery, but doing so will result in the new query going through the plan compiler every time you execute it.</span></span>

``` csharp
    using (NorthwindEntities context = new NorthwindEntities())
    {
        IQueryable<Customer> myCustomers = context.InvokeCustomersForEmployee();

        if (this.orderCountFilterList.SelectedItem.Value != defaultFilterText)
        {
            int orderCount = int.Parse(orderCountFilterList.SelectedValue);
            myCustomers = myCustomers.Where(c => c.Orders.Count > orderCount);
        }

        if (this.countryFilterList.SelectedItem.Value != defaultFilterText)
        {
            myCustomers = myCustomers.Where(c => c.Address.Country == countryFilterList.SelectedValue);
        }

        this.customersGrid.DataSource = myCustomers;
        this.customersGrid.DataBind();
    }
```

 <span data-ttu-id="de3cf-467">Para evitar esta recompilación, puede volver a escribir la CompiledQuery para los filtros posibles de tener en cuenta:</span><span class="sxs-lookup"><span data-stu-id="de3cf-467">To avoid this re-compilation, you can rewrite the CompiledQuery to take the possible filters into account:</span></span>

``` csharp
    private static readonly Func<NorthwindEntities, int, int?, string, IQueryable<Customer>> customersForEmployeeWithFiltersCQ = CompiledQuery.Compile(
        (NorthwindEntities context, int empId, int? countFilter, string countryFilter) =>
            context.Customers.Where(c => c.Orders.Any(o => o.EmployeeID == empId))
            .Where(c => countFilter.HasValue == false || c.Orders.Count > countFilter)
            .Where(c => countryFilter == null || c.Address.Country == countryFilter)
        );
```

<span data-ttu-id="de3cf-468">Que se invoquen en la interfaz de usuario, como:</span><span class="sxs-lookup"><span data-stu-id="de3cf-468">Which would be invoked in the UI like:</span></span>

``` csharp
    using (NorthwindEntities context = new NorthwindEntities())
    {
        int? countFilter = (this.orderCountFilterList.SelectedIndex == 0) ?
            (int?)null :
            int.Parse(this.orderCountFilterList.SelectedValue);

        string countryFilter = (this.countryFilterList.SelectedIndex == 0) ?
            null :
            this.countryFilterList.SelectedValue;

        IQueryable<Customer> myCustomers = context.InvokeCustomersForEmployeeWithFilters(
                countFilter, countryFilter);

        this.customersGrid.DataSource = myCustomers;
        this.customersGrid.DataBind();
    }
```

 <span data-ttu-id="de3cf-469">Un inconveniente es que el comando generado siempre tendrá los filtros con las comprobaciones de null, pero deben ser bastante sencillas para el servidor de base de datos optimizar:</span><span class="sxs-lookup"><span data-stu-id="de3cf-469">A tradeoff here is the generated store command will always have the filters with the null checks, but these should be fairly simple for the database server to optimize:</span></span>

``` SQL
...
WHERE ((0 = (CASE WHEN (@p__linq__1 IS NOT NULL) THEN cast(1 as bit) WHEN (@p__linq__1 IS NULL) THEN cast(0 as bit) END)) OR ([Project3].[C2] > @p__linq__2)) AND (@p__linq__3 IS NULL OR [Project3].[Country] = @p__linq__4)
```

### <a name="34-metadata-caching"></a><span data-ttu-id="de3cf-470">3.4 almacenamiento en caché de metadatos</span><span class="sxs-lookup"><span data-stu-id="de3cf-470">3.4 Metadata caching</span></span>

<span data-ttu-id="de3cf-471">Entity Framework también admite el almacenamiento en caché de metadatos.</span><span class="sxs-lookup"><span data-stu-id="de3cf-471">The Entity Framework also supports Metadata caching.</span></span> <span data-ttu-id="de3cf-472">Esto es esencialmente almacenamiento en caché de información de tipo y la información de asignación de tipo a base de datos a través de diferentes conexiones con el mismo modelo.</span><span class="sxs-lookup"><span data-stu-id="de3cf-472">This is essentially caching of type information and type-to-database mapping information across different connections to the same model.</span></span> <span data-ttu-id="de3cf-473">La caché de metadatos es única para cada dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="de3cf-473">The Metadata cache is unique per AppDomain.</span></span>

#### <a name="341-metadata-caching-algorithm"></a><span data-ttu-id="de3cf-474">3.4.1 algoritmo de almacenamiento en caché de metadatos</span><span class="sxs-lookup"><span data-stu-id="de3cf-474">3.4.1 Metadata Caching algorithm</span></span>

1.  <span data-ttu-id="de3cf-475">Información de metadatos para un modelo se almacena en un objeto ItemCollection para cada EntityConnection.</span><span class="sxs-lookup"><span data-stu-id="de3cf-475">Metadata information for a model is stored in an ItemCollection for each EntityConnection.</span></span>
    -   <span data-ttu-id="de3cf-476">Como una nota al margen, hay diferentes objetos ItemCollection para las distintas partes del modelo.</span><span class="sxs-lookup"><span data-stu-id="de3cf-476">As a side note, there are different ItemCollection objects for different parts of the model.</span></span> <span data-ttu-id="de3cf-477">Por ejemplo, StoreItemCollections contiene la información sobre el modelo de base de datos; ObjectItemCollection contiene información sobre el modelo de datos; EdmItemCollection contiene información sobre el modelo conceptual.</span><span class="sxs-lookup"><span data-stu-id="de3cf-477">For example, StoreItemCollections contains the information about the database model; ObjectItemCollection contains information about the data model; EdmItemCollection contains information about the conceptual model.</span></span>

2.  <span data-ttu-id="de3cf-478">Si dos conexiones usan la misma cadena de conexión, comparten la misma instancia ItemCollection.</span><span class="sxs-lookup"><span data-stu-id="de3cf-478">If two connections use the same connection string, they will share the same ItemCollection instance.</span></span>
3.  <span data-ttu-id="de3cf-479">Es posible que las cadenas de conexión funcionalmente equivalentes pero textualmente diferentes en las memorias caché de metadatos diferentes.</span><span class="sxs-lookup"><span data-stu-id="de3cf-479">Functionally equivalent but textually different connection strings may result in different metadata caches.</span></span> <span data-ttu-id="de3cf-480">Simplemente cambiando el orden de los tokens debe producir metadatos compartidos se dividir las cadenas de conexión.</span><span class="sxs-lookup"><span data-stu-id="de3cf-480">We do tokenize connection strings, so simply changing the order of the tokens should result in shared metadata.</span></span> <span data-ttu-id="de3cf-481">Pero dos cadenas de conexión que parecen funcionalmente la misma no se pueden evaluar como idénticos después de la tokenización.</span><span class="sxs-lookup"><span data-stu-id="de3cf-481">But two connection strings that seem functionally the same may not be evaluated as identical after tokenization.</span></span>
4.  <span data-ttu-id="de3cf-482">ItemCollection se comprueba periódicamente para su uso.</span><span class="sxs-lookup"><span data-stu-id="de3cf-482">The ItemCollection is periodically checked for use.</span></span> <span data-ttu-id="de3cf-483">Si se determina que no se ha accedido recientemente un área de trabajo, se marcará para la limpieza en el siguiente rastreo de memoria caché.</span><span class="sxs-lookup"><span data-stu-id="de3cf-483">If it is determined that a workspace has not been accessed recently, it will be marked for cleanup on the next cache sweep.</span></span>
5.  <span data-ttu-id="de3cf-484">Simplemente crear una EntityConnection hará que una memoria caché de metadatos para crearse (aunque no se inicializarán las colecciones de elementos en ella hasta que se abre la conexión).</span><span class="sxs-lookup"><span data-stu-id="de3cf-484">Merely creating an EntityConnection will cause a metadata cache to be created (though the item collections in it will not be initialized until the connection is opened).</span></span> <span data-ttu-id="de3cf-485">Esta área de trabajo permanecerá en memoria hasta que el algoritmo de almacenamiento en caché determina no es "en uso".</span><span class="sxs-lookup"><span data-stu-id="de3cf-485">This workspace will remain in-memory until the caching algorithm determines it is not “in use”.</span></span>

<span data-ttu-id="de3cf-486">Customer Advisory Team ha escrito una entrada de blog que describe que contiene una referencia a un objeto ItemCollection con el fin de evitar la "degradación" al usar los modelos grandes: \<http://blogs.msdn.com/b/appfabriccat/archive/2010/10/22/metadataworkspace-reference-in-wcf-services.aspx>.</span><span class="sxs-lookup"><span data-stu-id="de3cf-486">The Customer Advisory Team has written a blog post that describes holding a reference to an ItemCollection in order to avoid "deprecation" when using large models: \<http://blogs.msdn.com/b/appfabriccat/archive/2010/10/22/metadataworkspace-reference-in-wcf-services.aspx>.</span></span>

#### <a name="342-the-relationship-between-metadata-caching-and-query-plan-caching"></a><span data-ttu-id="de3cf-487">3.4.2 la relación entre el almacenamiento en caché de metadatos y la caché de Plan de consultas</span><span class="sxs-lookup"><span data-stu-id="de3cf-487">3.4.2 The relationship between Metadata Caching and Query Plan Caching</span></span>

<span data-ttu-id="de3cf-488">La instancia de caché del plan de consulta reside en ItemCollection del MetadataWorkspace de tipos de almacén.</span><span class="sxs-lookup"><span data-stu-id="de3cf-488">The query plan cache instance lives in the MetadataWorkspace's ItemCollection of store types.</span></span> <span data-ttu-id="de3cf-489">Esto significa que los comandos de almacenamiento en caché se utilizará para las consultas en cualquier contexto que se crea una instancia con un MetadataWorkspace determinado.</span><span class="sxs-lookup"><span data-stu-id="de3cf-489">This means that cached store commands will be used for queries against any context instantiated using a given MetadataWorkspace.</span></span> <span data-ttu-id="de3cf-490">También significa que si tiene dos cadenas de conexiones que son ligeramente diferentes y no coinciden después de dividir en tokens, habrá consulta diferentes instancias de caché de plan.</span><span class="sxs-lookup"><span data-stu-id="de3cf-490">It also means that if you have two connections strings that are slightly different and don't match after tokenizing, you will have different query plan cache instances.</span></span>

### <a name="35-results-caching"></a><span data-ttu-id="de3cf-491">3.5 almacenamiento en caché de resultados de</span><span class="sxs-lookup"><span data-stu-id="de3cf-491">3.5 Results caching</span></span>

<span data-ttu-id="de3cf-492">Con los resultados de almacenamiento en caché (también conocido como "segundo nivel de almacenamiento en caché"), mantener los resultados de consultas en una caché local.</span><span class="sxs-lookup"><span data-stu-id="de3cf-492">With results caching (also known as "second-level caching"), you keep the results of queries in a local cache.</span></span> <span data-ttu-id="de3cf-493">Al emitir una consulta, aparece en primer lugar si los resultados están disponibles localmente antes de la consulta en el almacén.</span><span class="sxs-lookup"><span data-stu-id="de3cf-493">When issuing a query, you first see if the results are available locally before you query against the store.</span></span> <span data-ttu-id="de3cf-494">Aunque el almacenamiento en caché de resultados no es compatible directamente con Entity Framework, es posible agregar una caché de segundo nivel con un proveedor de ajuste.</span><span class="sxs-lookup"><span data-stu-id="de3cf-494">While results caching isn't directly supported by Entity Framework, it's possible to add a second level cache by using a wrapping provider.</span></span> <span data-ttu-id="de3cf-495">Un ejemplo de proveedor de ajuste con una memoria caché de segundo nivel es del Alachisoft [Entity Framework segundo nivel de caché en función de NCache](http://www.alachisoft.com/ncache/entity-framework.html).</span><span class="sxs-lookup"><span data-stu-id="de3cf-495">An example wrapping provider with a second-level cache is Alachisoft's [Entity Framework Second Level Cache based on NCache](http://www.alachisoft.com/ncache/entity-framework.html).</span></span>

<span data-ttu-id="de3cf-496">Esta implementación de almacenamiento en caché de segundo nivel es una funcionalidad insertada que tiene lugar después de que se ha evaluado la expresión LINQ (y funcletized) y el plan de ejecución de consulta es calculado o se recupera de la caché de primer nivel.</span><span class="sxs-lookup"><span data-stu-id="de3cf-496">This implementation of second-level caching is an injected functionality that takes place after the LINQ expression has been evaluated (and funcletized) and the query execution plan is computed or retrieved from the first-level cache.</span></span> <span data-ttu-id="de3cf-497">La memoria caché de segundo nivel, a continuación, almacenará solo los resultados de la base de datos sin procesar, por lo que la canalización de materialización ejecuta posteriormente.</span><span class="sxs-lookup"><span data-stu-id="de3cf-497">The second-level cache will then store only the raw database results, so the materialization pipeline still executes afterwards.</span></span>

#### <a name="351-additional-references-for-results-caching-with-the-wrapping-provider"></a><span data-ttu-id="de3cf-498">3.5.1 referencias adicionales de para con el proveedor de ajuste de almacenamiento en caché de resultados</span><span class="sxs-lookup"><span data-stu-id="de3cf-498">3.5.1 Additional references for results caching with the wrapping provider</span></span>

-   <span data-ttu-id="de3cf-499">Julie Lerman ha escrito un artículo MSDN "Segundo nivel de almacenamiento en caché en Entity Framework y Windows Azure" que incluye cómo actualizar el proveedor de ajuste de ejemplo para usar el almacenamiento en caché de Windows Server AppFabric: [https://msdn.microsoft.com/magazine/hh394143.aspx](https://msdn.microsoft.com/magazine/hh394143.aspx)</span><span class="sxs-lookup"><span data-stu-id="de3cf-499">Julie Lerman has written a "Second-Level Caching in Entity Framework and Windows Azure" MSDN article that includes how to update the sample wrapping provider to use Windows Server AppFabric caching: [https://msdn.microsoft.com/magazine/hh394143.aspx](https://msdn.microsoft.com/magazine/hh394143.aspx)</span></span>
-   <span data-ttu-id="de3cf-500">Si trabaja con Entity Framework 5, el blog del equipo tiene una entrada de blog que describe cómo empezar a funcionar con el proveedor de almacenamiento en caché para Entity Framework 5: \< http://blogs.msdn.com/b/adonet/archive/2010/09/13/ef-caching-with-jarek-kowalski-s-provider.aspx>.</span><span class="sxs-lookup"><span data-stu-id="de3cf-500">If you are working with Entity Framework 5, the team blog has a post that describes how to get things running with the caching provider for Entity Framework 5: \<http://blogs.msdn.com/b/adonet/archive/2010/09/13/ef-caching-with-jarek-kowalski-s-provider.aspx>.</span></span> <span data-ttu-id="de3cf-501">También incluye una plantilla T4 para ayudar a automatizar la adición de la memoria caché a nivel 2 º al proyecto.</span><span class="sxs-lookup"><span data-stu-id="de3cf-501">It also includes a T4 template to help automate adding the 2nd-level caching to your project.</span></span>

## <a name="4-autocompiled-queries"></a><span data-ttu-id="de3cf-502">4 consultas Autocompiled</span><span class="sxs-lookup"><span data-stu-id="de3cf-502">4 Autocompiled Queries</span></span>

<span data-ttu-id="de3cf-503">Cuando se emite una consulta en una base de datos mediante Entity Framework, debe pasar a través de una serie de pasos antes de realmente materializar los resultados. un paso de este tipo es la compilación de la consulta.</span><span class="sxs-lookup"><span data-stu-id="de3cf-503">When a query is issued against a database using Entity Framework, it must go through a series of steps before actually materializing the results; one such step is Query Compilation.</span></span> <span data-ttu-id="de3cf-504">Consultas de Entity SQL se sabe que tiene un buen rendimiento tal como se almacenan automáticamente en caché, por lo que el tiempo de segundo o tercer ejecutar la misma consulta puede omitir el compilador de plan y utilizar el plan almacenado en caché en su lugar.</span><span class="sxs-lookup"><span data-stu-id="de3cf-504">Entity SQL queries were known to have good performance as they are automatically cached, so the second or third time you execute the same query it can skip the plan compiler and use the cached plan instead.</span></span>

<span data-ttu-id="de3cf-505">Entity Framework 5 introdujo el almacenamiento en caché automático para LINQ a consultas de las entidades también.</span><span class="sxs-lookup"><span data-stu-id="de3cf-505">Entity Framework 5 introduced automatic caching for LINQ to Entities queries as well.</span></span> <span data-ttu-id="de3cf-506">En ediciones anteriores de Entity Framework creando un CompiledQuery para acelerar el rendimiento de la era una práctica común, como esto haría que las de LINQ para consultar entidades almacenables en caché.</span><span class="sxs-lookup"><span data-stu-id="de3cf-506">In past editions of Entity Framework creating a CompiledQuery to speed your performance was a common practice, as this would make your LINQ to Entities query cacheable.</span></span> <span data-ttu-id="de3cf-507">Puesto que el almacenamiento en caché se realiza automáticamente sin necesidad de utilizar un CompiledQuery, llamamos a esta característica "autocompiled consultas".</span><span class="sxs-lookup"><span data-stu-id="de3cf-507">Since caching is now done automatically without the use of a CompiledQuery, we call this feature “autocompiled queries”.</span></span> <span data-ttu-id="de3cf-508">Para obtener más información acerca de la caché del plan de consulta y sus mecanismos, consulte almacenamiento en caché del Plan de consulta.</span><span class="sxs-lookup"><span data-stu-id="de3cf-508">For more information about the query plan cache and its mechanics, see Query Plan Caching.</span></span>

<span data-ttu-id="de3cf-509">Entity Framework detecta cuando una consulta requiere volver a compilar, y lo hace cuando se invoca la consulta aunque había sido compilado antes.</span><span class="sxs-lookup"><span data-stu-id="de3cf-509">Entity Framework detects when a query requires to be recompiled, and does so when the query is invoked even if it had been compiled before.</span></span> <span data-ttu-id="de3cf-510">Condiciones comunes que hacer que se vuelvan a compilar la consulta son:</span><span class="sxs-lookup"><span data-stu-id="de3cf-510">Common conditions that cause the query to be recompiled are:</span></span>

-   <span data-ttu-id="de3cf-511">Cambiar MergeOption asociado a la consulta.</span><span class="sxs-lookup"><span data-stu-id="de3cf-511">Changing the MergeOption associated to your query.</span></span> <span data-ttu-id="de3cf-512">No se usará la consulta en caché, en su lugar, el compilador de plan se ejecutará de nuevo y se almacenan en caché el plan recién creado.</span><span class="sxs-lookup"><span data-stu-id="de3cf-512">The cached query will not be used, instead the plan compiler will run again and the newly created plan gets cached.</span></span>
-   <span data-ttu-id="de3cf-513">Cambiar el valor de ContextOptions.UseCSharpNullComparisonBehavior.</span><span class="sxs-lookup"><span data-stu-id="de3cf-513">Changing the value of ContextOptions.UseCSharpNullComparisonBehavior.</span></span> <span data-ttu-id="de3cf-514">Obtener el mismo efecto que el cambio de MergeOption.</span><span class="sxs-lookup"><span data-stu-id="de3cf-514">You get the same effect as changing the MergeOption.</span></span>

<span data-ttu-id="de3cf-515">Otras condiciones pueden impedir que la consulta utilizando la memoria caché.</span><span class="sxs-lookup"><span data-stu-id="de3cf-515">Other conditions can prevent your query from using the cache.</span></span> <span data-ttu-id="de3cf-516">Algunos ejemplos comunes son:</span><span class="sxs-lookup"><span data-stu-id="de3cf-516">Common examples are:</span></span>

-   <span data-ttu-id="de3cf-517">Uso de IEnumerable&lt;T&gt;. Contiene&lt;&gt;(valor de T).</span><span class="sxs-lookup"><span data-stu-id="de3cf-517">Using IEnumerable&lt;T&gt;.Contains&lt;&gt;(T value).</span></span>
-   <span data-ttu-id="de3cf-518">Uso de funciones que generan consultas con constantes.</span><span class="sxs-lookup"><span data-stu-id="de3cf-518">Using functions that produce queries with constants.</span></span>
-   <span data-ttu-id="de3cf-519">Mediante las propiedades de un objeto no asignados.</span><span class="sxs-lookup"><span data-stu-id="de3cf-519">Using the properties of a non-mapped object.</span></span>
-   <span data-ttu-id="de3cf-520">La vinculación a otra consulta que requiere volver a compilar la consulta.</span><span class="sxs-lookup"><span data-stu-id="de3cf-520">Linking your query to another query that requires to be recompiled.</span></span>

### <a name="41-using-ienumerablelttgtcontainslttgtt-value"></a><span data-ttu-id="de3cf-521">4.1 con IEnumerable&lt;T&gt;. Contiene&lt;T&gt;(valor de T)</span><span class="sxs-lookup"><span data-stu-id="de3cf-521">4.1 Using IEnumerable&lt;T&gt;.Contains&lt;T&gt;(T value)</span></span>

<span data-ttu-id="de3cf-522">Entity Framework no almacena en caché las consultas que invocan IEnumerable&lt;T&gt;. Contiene&lt;T&gt;(valor de T) frente a una colección en memoria, ya que los valores de la colección se consideran volátiles.</span><span class="sxs-lookup"><span data-stu-id="de3cf-522">Entity Framework does not cache queries that invoke IEnumerable&lt;T&gt;.Contains&lt;T&gt;(T value) against an in-memory collection, since the values of the collection are considered volatile.</span></span> <span data-ttu-id="de3cf-523">La consulta de ejemplo siguiente no se almacenará en caché, por lo que siempre se procesarán por el compilador de plan:</span><span class="sxs-lookup"><span data-stu-id="de3cf-523">The following example query will not be cached, so it will always be processed by the plan compiler:</span></span>

``` csharp
int[] ids = new int[10000];
...
using (var context = new MyContext())
{
    var query = context.MyEntities
                    .Where(entity => ids.Contains(entity.Id));

    var results = query.ToList();
    ...
}
```

<span data-ttu-id="de3cf-524">Tenga en cuenta que se ejecuta el tamaño de la interfaz IEnumerable contra qué Contains determina la rapidez o lentitud cómo se compila la consulta.</span><span class="sxs-lookup"><span data-stu-id="de3cf-524">Note that the size of the IEnumerable against which Contains is executed determines how fast or how slow your query is compiled.</span></span> <span data-ttu-id="de3cf-525">Rendimiento puede verse afectado significativamente al utilizar las colecciones grandes, como se muestra en el ejemplo anterior.</span><span class="sxs-lookup"><span data-stu-id="de3cf-525">Performance can suffer significantly when using large collections such as the one shown in the example above.</span></span>

<span data-ttu-id="de3cf-526">Entity Framework 6 contiene optimizado la forma IEnumerable&lt;T&gt;. Contiene&lt;T&gt;(valor de T) funciona cuando se ejecutan las consultas.</span><span class="sxs-lookup"><span data-stu-id="de3cf-526">Entity Framework 6 contains optimizations to the way IEnumerable&lt;T&gt;.Contains&lt;T&gt;(T value) works when queries are executed.</span></span> <span data-ttu-id="de3cf-527">El código SQL que se genera es mucho más rápido para generar y más legible, y en la mayoría de los casos también se ejecuta más rápido en el servidor.</span><span class="sxs-lookup"><span data-stu-id="de3cf-527">The SQL code that is generated is much faster to produce and more readable, and in most cases it also executes faster in the server.</span></span>

### <a name="42-using-functions-that-produce-queries-with-constants"></a><span data-ttu-id="de3cf-528">4.2 utilizando las funciones que generan consultas con constantes</span><span class="sxs-lookup"><span data-stu-id="de3cf-528">4.2 Using functions that produce queries with constants</span></span>

<span data-ttu-id="de3cf-529">Los operadores Skip(), utilice, Contains() y DefautIfEmpty() LINQ no generan consultas SQL con parámetros, pero en su lugar para colocar los valores que se les pasados como constantes.</span><span class="sxs-lookup"><span data-stu-id="de3cf-529">The Skip(), Take(), Contains() and DefautIfEmpty() LINQ operators do not produce SQL queries with parameters but instead put the values passed to them as constants.</span></span> <span data-ttu-id="de3cf-530">Por este motivo, las consultas en caso contrario, podrían ser idéntica acaban contaminar la consulta plan la memoria caché tanto en la pila EF en el servidor de base de datos y no obtener reutilized a menos que el mismas constantes se utilizan en una ejecución de consulta subsiguientes.</span><span class="sxs-lookup"><span data-stu-id="de3cf-530">Because of this, queries that might otherwise be identical end up polluting the query plan cache, both on the EF stack and on the database server, and do not get reutilized unless the same constants are used in a subsequent query execution.</span></span> <span data-ttu-id="de3cf-531">Por ejemplo:</span><span class="sxs-lookup"><span data-stu-id="de3cf-531">For example:</span></span>

``` csharp
var id = 10;
...
using (var context = new MyContext())
{
    var query = context.MyEntities.Select(entity => entity.Id).Contains(id);

    var results = query.ToList();
    ...
}
```

<span data-ttu-id="de3cf-532">En este ejemplo, cada vez que se ejecuta esta consulta con un valor diferente para el Id. de la consulta se compilarán en un nuevo plan.</span><span class="sxs-lookup"><span data-stu-id="de3cf-532">In this example, each time this query is executed with a different value for id the query will be compiled into a new plan.</span></span>

<span data-ttu-id="de3cf-533">En el pago particular atención al uso de Skip y Take al realizar la paginación.</span><span class="sxs-lookup"><span data-stu-id="de3cf-533">In particular pay attention to the use of Skip and Take when doing paging.</span></span> <span data-ttu-id="de3cf-534">En EF6, estos métodos tienen una sobrecarga de lambda que se convierte de manera efectiva el plan de consulta almacenado en caché reutilizables porque EF puede capturar variables pasadas a estos métodos y trasladarlas a SQLparameters.</span><span class="sxs-lookup"><span data-stu-id="de3cf-534">In EF6 these methods have a lambda overload that effectively makes the cached query plan reusable because EF can capture variables passed to these methods and translate them to SQLparameters.</span></span> <span data-ttu-id="de3cf-535">Esto también ayuda a mantener la memoria caché más limpio, ya que de lo contrario, cada consulta con una constante distinta de Skip y Take obtendría su propia entrada de caché del plan de consulta.</span><span class="sxs-lookup"><span data-stu-id="de3cf-535">This also helps keep the cache cleaner since otherwise each query with a different constant for Skip and Take would get its own query plan cache entry.</span></span>

<span data-ttu-id="de3cf-536">Tenga en cuenta el código siguiente, que no es óptimo, pero solo está pensado para ejemplificar esta clase de consultas:</span><span class="sxs-lookup"><span data-stu-id="de3cf-536">Consider the following code, which is suboptimal but is only meant to exemplify this class of queries:</span></span>

``` csharp
var customers = context.Customers.OrderBy(c => c.LastName);
for (var i = 0; i < count; ++i)
{
    var currentCustomer = customers.Skip(i).FirstOrDefault();
    ProcessCustomer(currentCustomer);
}
```

<span data-ttu-id="de3cf-537">Una versión más rápida de este mismo código implicaría una llamada a Skip con una expresión lambda:</span><span class="sxs-lookup"><span data-stu-id="de3cf-537">A faster version of this same code would involve calling Skip with a lambda:</span></span>

``` csharp
var customers = context.Customers.OrderBy(c => c.LastName);
for (var i = 0; i \< count; ++i)
{
    var currentCustomer = customers.Skip(() => i).FirstOrDefault();
    ProcessCustomer(currentCustomer);
}
```

<span data-ttu-id="de3cf-538">El segundo fragmento de código puede ejecutarse un 11% más rápido porque se utiliza el mismo plan de consulta cada vez que se ejecuta la consulta, lo que ahorra tiempo de CPU y evita contaminar la caché de consultas.</span><span class="sxs-lookup"><span data-stu-id="de3cf-538">The second snippet may run up to 11% faster because the same query plan is used every time the query is run, which saves CPU time and avoids polluting the query cache.</span></span> <span data-ttu-id="de3cf-539">Además, dado que el parámetro Skip es en una clausura el código podría también este aspecto ahora:</span><span class="sxs-lookup"><span data-stu-id="de3cf-539">Furthermore, because the parameter to Skip is in a closure the code might as well look like this now:</span></span>

``` csharp
var i = 0;
var skippyCustomers = context.Customers.OrderBy(c => c.LastName).Skip(() => i);
for (; i < count; ++i)
{
    var currentCustomer = skippyCustomers.FirstOrDefault();
    ProcessCustomer(currentCustomer);
}
```

### <a name="43-using-the-properties-of-a-non-mapped-object"></a><span data-ttu-id="de3cf-540">4.3 mediante las propiedades de un objeto no asignado</span><span class="sxs-lookup"><span data-stu-id="de3cf-540">4.3 Using the properties of a non-mapped object</span></span>

<span data-ttu-id="de3cf-541">Cuando una consulta usa las propiedades de un tipo de objeto no asignado como un parámetro, a continuación, la consulta no se almacene en caché.</span><span class="sxs-lookup"><span data-stu-id="de3cf-541">When a query uses the properties of a non-mapped object type as a parameter then the query will not get cached.</span></span> <span data-ttu-id="de3cf-542">Por ejemplo:</span><span class="sxs-lookup"><span data-stu-id="de3cf-542">For example:</span></span>

``` csharp
using (var context = new MyContext())
{
    var myObject = new NonMappedType();

    var query = from entity in context.MyEntities
                where entity.Name.StartsWith(myObject.MyProperty)
                select entity;

   var results = query.ToList();
    ...
}
```

<span data-ttu-id="de3cf-543">En este ejemplo, suponga que la clase NonMappedType no forma parte del modelo de entidad.</span><span class="sxs-lookup"><span data-stu-id="de3cf-543">In this example, assume that class NonMappedType is not part of the Entity model.</span></span> <span data-ttu-id="de3cf-544">Esta consulta puede modificarse fácilmente para no usar un tipo no asignado y en su lugar, use una variable local como parámetro a la consulta:</span><span class="sxs-lookup"><span data-stu-id="de3cf-544">This query can easily be changed to not use a non-mapped type and instead use a local variable as the parameter to the query:</span></span>

``` csharp
using (var context = new MyContext())
{
    var myObject = new NonMappedType();
    var myValue = myObject.MyProperty;
    var query = from entity in context.MyEntities
                where entity.Name.StartsWith(myValue)
                select entity;

    var results = query.ToList();
    ...
}
```

<span data-ttu-id="de3cf-545">En este caso, la consulta podrá se almacene en caché y se beneficiará de la caché del plan de consulta.</span><span class="sxs-lookup"><span data-stu-id="de3cf-545">In this case, the query will be able to get cached and will benefit from the query plan cache.</span></span>

### <a name="44-linking-to-queries-that-require-recompiling"></a><span data-ttu-id="de3cf-546">4.4 vinculación a las consultas que requieren volver a compilar</span><span class="sxs-lookup"><span data-stu-id="de3cf-546">4.4 Linking to queries that require recompiling</span></span>

<span data-ttu-id="de3cf-547">Siguiendo el mismo ejemplo anterior, si tiene una segunda consulta que se basa en una consulta que necesite volver a compilar, la segunda consulta toda también se volverá a compilar.</span><span class="sxs-lookup"><span data-stu-id="de3cf-547">Following the same example as above, if you have a second query that relies on a query that needs to be recompiled, your entire second query will also be recompiled.</span></span> <span data-ttu-id="de3cf-548">Este es un ejemplo para ilustrar este escenario:</span><span class="sxs-lookup"><span data-stu-id="de3cf-548">Here’s an example to illustrate this scenario:</span></span>

``` csharp
int[] ids = new int[10000];
...
using (var context = new MyContext())
{
    var firstQuery = from entity in context.MyEntities
                        where ids.Contains(entity.Id)
                        select entity;

    var secondQuery = from entity in context.MyEntities
                        where firstQuery.Any(otherEntity => otherEntity.Id == entity.Id)
                        select entity;

    var results = secondQuery.ToList();
    ...
}
```

<span data-ttu-id="de3cf-549">El ejemplo es genérico, pero ilustra cómo vincular a firstQuery está causando secondQuery no se pueden obtener en la memoria caché.</span><span class="sxs-lookup"><span data-stu-id="de3cf-549">The example is generic, but it illustrates how linking to firstQuery is causing secondQuery to be unable to get cached.</span></span> <span data-ttu-id="de3cf-550">Si no se hubiera una consulta que requiere volver a compilar firstQuery, a continuación, secondQuery habría ha almacenado en caché.</span><span class="sxs-lookup"><span data-stu-id="de3cf-550">If firstQuery had not been a query that requires recompiling, then secondQuery would have been cached.</span></span>

## <a name="5-notracking-queries"></a><span data-ttu-id="de3cf-551">5 consultas NoTracking</span><span class="sxs-lookup"><span data-stu-id="de3cf-551">5 NoTracking Queries</span></span>

### <a name="51-disabling-change-tracking-to-reduce-state-management-overhead"></a><span data-ttu-id="de3cf-552">5.1 deshabilitar el seguimiento de cambios para reducir la sobrecarga de administración de estado</span><span class="sxs-lookup"><span data-stu-id="de3cf-552">5.1 Disabling change tracking to reduce state management overhead</span></span>

<span data-ttu-id="de3cf-553">Si encuentra en un escenario de solo lectura y desea evitar la sobrecarga de carga de los objetos en el ObjectStateManager, se pueden emitir consultas de "Seguimiento de n".</span><span class="sxs-lookup"><span data-stu-id="de3cf-553">If you are in a read-only scenario and want to avoid the overhead of loading the objects into the ObjectStateManager, you can issue "No Tracking" queries.</span></span><span data-ttu-id="de3cf-554">  En el nivel de consulta, se pueden deshabilitar el seguimiento de cambios.</span><span class="sxs-lookup"><span data-stu-id="de3cf-554">  Change tracking can be disabled at the query level.</span></span>

<span data-ttu-id="de3cf-555">Sin embargo, tenga en cuenta que al deshabilitar, seguimiento de cambios eficaz desactiva la caché de objetos.</span><span class="sxs-lookup"><span data-stu-id="de3cf-555">Note though that by disabling change tracking you are effectively turning off the object cache.</span></span> <span data-ttu-id="de3cf-556">Al consultar una entidad, no podemos omitimos materialización extrayendo los resultados de consulta materializada previamente de ObjectStateManager.</span><span class="sxs-lookup"><span data-stu-id="de3cf-556">When you query for an entity, we can't skip materialization by pulling the previously-materialized query results from the ObjectStateManager.</span></span> <span data-ttu-id="de3cf-557">Si consulta repetidamente las mismas entidades en el mismo contexto, es posible que vea realmente un rendimiento beneficiarse de la habilitación de seguimiento de cambios.</span><span class="sxs-lookup"><span data-stu-id="de3cf-557">If you are repeatedly querying for the same entities on the same context, you might actually see a performance benefit from enabling change tracking.</span></span>

<span data-ttu-id="de3cf-558">Al consultar el uso de ObjectContext, las instancias de ObjectQuery y ObjectSet recordará un MergeOption una vez que se ha configurado y las consultas que están compuestas por ellos heredará MergeOption efectivo de la consulta primaria.</span><span class="sxs-lookup"><span data-stu-id="de3cf-558">When querying using ObjectContext, ObjectQuery and ObjectSet instances will remember a MergeOption once it is set, and queries that are composed on them will inherit the effective MergeOption of the parent query.</span></span> <span data-ttu-id="de3cf-559">Al usar DbContext, se puede deshabilitar el seguimiento llamando el modificador AsNoTracking() en DbSet.</span><span class="sxs-lookup"><span data-stu-id="de3cf-559">When using DbContext, tracking can be disabled by calling the AsNoTracking() modifier on the DbSet.</span></span>

#### <a name="511-disabling-change-tracking-for-a-query-when-using-dbcontext"></a><span data-ttu-id="de3cf-560">5.1.1 deshabilitar el seguimiento de cambios para una consulta al usar DbContext</span><span class="sxs-lookup"><span data-stu-id="de3cf-560">5.1.1 Disabling change tracking for a query when using DbContext</span></span>

<span data-ttu-id="de3cf-561">Puede cambiar el modo de una consulta a NoTracking al encadenar una llamada al método AsNoTracking() en la consulta.</span><span class="sxs-lookup"><span data-stu-id="de3cf-561">You can switch the mode of a query to NoTracking by chaining a call to the AsNoTracking() method in the query.</span></span> <span data-ttu-id="de3cf-562">A diferencia de ObjectQuery, las clases DbSet y DbQuery en la API de DbContext no tienen una propiedad mutable para MergeOption.</span><span class="sxs-lookup"><span data-stu-id="de3cf-562">Unlike ObjectQuery, the DbSet and DbQuery classes in the DbContext API don’t have a mutable property for the MergeOption.</span></span>

``` csharp
    var productsForCategory = from p in context.Products.AsNoTracking()
                                where p.Category.CategoryName == selectedCategory
                                select p;


```

#### <a name="512-disabling-change-tracking-at-the-query-level-using-objectcontext"></a><span data-ttu-id="de3cf-563">5.1.2 deshabilitar en el nivel de consulta mediante ObjectContext con establecimiento de seguimiento de cambios</span><span class="sxs-lookup"><span data-stu-id="de3cf-563">5.1.2 Disabling change tracking at the query level using ObjectContext</span></span>

``` csharp
    var productsForCategory = from p in context.Products
                                where p.Category.CategoryName == selectedCategory
                                select p;

    ((ObjectQuery)productsForCategory).MergeOption = MergeOption.NoTracking;
```

#### <a name="513-disabling-change-tracking-for-an-entire-entity-set-using-objectcontext"></a><span data-ttu-id="de3cf-564">5.1.3 deshabilitar el seguimiento de cambios para una entidad completa establecer uso de ObjectContext</span><span class="sxs-lookup"><span data-stu-id="de3cf-564">5.1.3 Disabling change tracking for an entire entity set using ObjectContext</span></span>

``` csharp
    context.Products.MergeOption = MergeOption.NoTracking;

    var productsForCategory = from p in context.Products
                                where p.Category.CategoryName == selectedCategory
                                select p;
```

### <a name="52test-metrics-demonstrating-the-performance-benefit-of-notracking-queries"></a><span data-ttu-id="de3cf-565">5.2 comprobar las métricas que muestran las ventajas de rendimiento de consultas NoTracking</span><span class="sxs-lookup"><span data-stu-id="de3cf-565">5.2 Test Metrics demonstrating the performance benefit of NoTracking queries</span></span>

<span data-ttu-id="de3cf-566">En esta prueba nos centramos a costa de rellenar el ObjectStateManager mediante la comparación de seguimiento a las consultas NoTracking para el modelo de Navision.</span><span class="sxs-lookup"><span data-stu-id="de3cf-566">In this test we look at the cost of filling the ObjectStateManager by comparing Tracking to NoTracking queries for the Navision model.</span></span> <span data-ttu-id="de3cf-567">Consulte el apéndice para obtener una descripción del modelo Navision y los tipos de consultas que se ejecutaron.</span><span class="sxs-lookup"><span data-stu-id="de3cf-567">See the appendix for a description of the Navision model and the types of queries which were executed.</span></span> <span data-ttu-id="de3cf-568">En esta prueba, hemos recorrer en iteración la lista de consultas y ejecutar una vez cada uno de ellos.</span><span class="sxs-lookup"><span data-stu-id="de3cf-568">In this test, we iterate through the list of queries and execute each one once.</span></span> <span data-ttu-id="de3cf-569">Se produjo dos variaciones de la prueba, una vez con NoTracking consultas y una vez con la opción de combinación predeterminada de "AppendOnly".</span><span class="sxs-lookup"><span data-stu-id="de3cf-569">We ran two variations of the test, once with NoTracking queries and once with the default merge option of "AppendOnly".</span></span> <span data-ttu-id="de3cf-570">Se ha ejecutado cada variación 3 veces y toma el valor medio de las ejecuciones.</span><span class="sxs-lookup"><span data-stu-id="de3cf-570">We ran each variation 3 times and take the mean value of the runs.</span></span> <span data-ttu-id="de3cf-571">Entre las pruebas se borrar la caché de consultas en SQL Server y reduce la tempdb que se ejecute los comandos siguientes:</span><span class="sxs-lookup"><span data-stu-id="de3cf-571">Between the tests we clear the query cache on the SQL Server and shrink the tempdb by running the following commands:</span></span>

1.  <span data-ttu-id="de3cf-572">DBCC DROPCLEANBUFFERS</span><span class="sxs-lookup"><span data-stu-id="de3cf-572">DBCC DROPCLEANBUFFERS</span></span>
2.  <span data-ttu-id="de3cf-573">DBCC FREEPROCCACHE</span><span class="sxs-lookup"><span data-stu-id="de3cf-573">DBCC FREEPROCCACHE</span></span>
3.  <span data-ttu-id="de3cf-574">DBCC SHRINKDATABASE (tempdb, 0)</span><span class="sxs-lookup"><span data-stu-id="de3cf-574">DBCC SHRINKDATABASE (tempdb, 0)</span></span>

<span data-ttu-id="de3cf-575">Resultados de pruebas, mediana se ejecuta más de 3:</span><span class="sxs-lookup"><span data-stu-id="de3cf-575">Test Results, median over 3 runs:</span></span>

|                        | <span data-ttu-id="de3cf-576">NINGÚN SEGUIMIENTO: EL ESPACIO DE TRABAJO</span><span class="sxs-lookup"><span data-stu-id="de3cf-576">NO TRACKING – WORKING SET</span></span> | <span data-ttu-id="de3cf-577">SIN SEGUIMIENTO: HORA</span><span class="sxs-lookup"><span data-stu-id="de3cf-577">NO TRACKING – TIME</span></span> | <span data-ttu-id="de3cf-578">ANEXAR SOLO: ESPACIO DE TRABAJO</span><span class="sxs-lookup"><span data-stu-id="de3cf-578">APPEND ONLY – WORKING SET</span></span> | <span data-ttu-id="de3cf-579">ANEXAR SOLO: HORA</span><span class="sxs-lookup"><span data-stu-id="de3cf-579">APPEND ONLY – TIME</span></span> |
|:-----------------------|:--------------------------|:-------------------|:--------------------------|:-------------------|
| <span data-ttu-id="de3cf-580">**Entity Framework 5**</span><span class="sxs-lookup"><span data-stu-id="de3cf-580">**Entity Framework 5**</span></span> | <span data-ttu-id="de3cf-581">460361728</span><span class="sxs-lookup"><span data-stu-id="de3cf-581">460361728</span></span>                 | <span data-ttu-id="de3cf-582">1163536 ms</span><span class="sxs-lookup"><span data-stu-id="de3cf-582">1163536 ms</span></span>         | <span data-ttu-id="de3cf-583">596545536</span><span class="sxs-lookup"><span data-stu-id="de3cf-583">596545536</span></span>                 | <span data-ttu-id="de3cf-584">1273042 ms</span><span class="sxs-lookup"><span data-stu-id="de3cf-584">1273042 ms</span></span>         |
| <span data-ttu-id="de3cf-585">**Entity Framework 6**</span><span class="sxs-lookup"><span data-stu-id="de3cf-585">**Entity Framework 6**</span></span> | <span data-ttu-id="de3cf-586">647127040</span><span class="sxs-lookup"><span data-stu-id="de3cf-586">647127040</span></span>                 | <span data-ttu-id="de3cf-587">190228 ms</span><span class="sxs-lookup"><span data-stu-id="de3cf-587">190228 ms</span></span>          | <span data-ttu-id="de3cf-588">832798720</span><span class="sxs-lookup"><span data-stu-id="de3cf-588">832798720</span></span>                 | <span data-ttu-id="de3cf-589">195521 ms</span><span class="sxs-lookup"><span data-stu-id="de3cf-589">195521 ms</span></span>          |

<span data-ttu-id="de3cf-590">Entity Framework 5 tendrá una superficie de memoria menor al final de la ejecución de Entity Framework 6.</span><span class="sxs-lookup"><span data-stu-id="de3cf-590">Entity Framework 5 will have a smaller memory footprint at the end of the run than Entity Framework 6 does.</span></span> <span data-ttu-id="de3cf-591">La memoria adicional utilizada por Entity Framework 6 es el resultado de las estructuras de memoria adicional y el código que permiten a las nuevas características y un mejor rendimiento.</span><span class="sxs-lookup"><span data-stu-id="de3cf-591">The additional memory consumed by Entity Framework 6 is the result of additional memory structures and code that enable new features and better performance.</span></span>

<span data-ttu-id="de3cf-592">También hay una diferencia clara en la superficie de memoria cuando se usa el ObjectStateManager.</span><span class="sxs-lookup"><span data-stu-id="de3cf-592">There’s also a clear difference in memory footprint when using the ObjectStateManager.</span></span> <span data-ttu-id="de3cf-593">Entity Framework 5 aumenta su impacto al 30% al realizar el seguimiento de todas las entidades que se materializan a partir de la base de datos.</span><span class="sxs-lookup"><span data-stu-id="de3cf-593">Entity Framework 5 increased its footprint by 30% when keeping track of all the entities we materialized from the database.</span></span> <span data-ttu-id="de3cf-594">Entity Framework 6 aumenta su impacto en un 28% al hacerlo.</span><span class="sxs-lookup"><span data-stu-id="de3cf-594">Entity Framework 6 increased its footprint by 28% when doing so.</span></span>

<span data-ttu-id="de3cf-595">En términos de tiempo, Entity Framework 6 supera a Entity Framework 5 en esta prueba por un margen de gran tamaño.</span><span class="sxs-lookup"><span data-stu-id="de3cf-595">In terms of time, Entity Framework 6 outperforms Entity Framework 5 in this test by a large margin.</span></span> <span data-ttu-id="de3cf-596">Entity Framework 6 ha completado la prueba en aproximadamente 16% del tiempo consumido por Entity Framework 5.</span><span class="sxs-lookup"><span data-stu-id="de3cf-596">Entity Framework 6 completed the test in roughly 16% of the time consumed by Entity Framework 5.</span></span> <span data-ttu-id="de3cf-597">Además, Entity Framework 5 tarda más de 9% en completarse cuando se usa el ObjectStateManager.</span><span class="sxs-lookup"><span data-stu-id="de3cf-597">Additionally, Entity Framework 5 takes 9% more time to complete when the ObjectStateManager is being used.</span></span> <span data-ttu-id="de3cf-598">En comparación, Entity Framework 6 está usando 3% más tiempo cuando se usa el ObjectStateManager.</span><span class="sxs-lookup"><span data-stu-id="de3cf-598">In comparison, Entity Framework 6 is using 3% more time when using the ObjectStateManager.</span></span>

## <a name="6-query-execution-options"></a><span data-ttu-id="de3cf-599">6 opciones de ejecución de consulta</span><span class="sxs-lookup"><span data-stu-id="de3cf-599">6 Query Execution Options</span></span>

<span data-ttu-id="de3cf-600">Entity Framework ofrece varias formas de consulta.</span><span class="sxs-lookup"><span data-stu-id="de3cf-600">Entity Framework offers several different ways to query.</span></span> <span data-ttu-id="de3cf-601">Se le Eche un vistazo a las siguientes opciones, compare las ventajas y desventajas de cada uno y examinar sus características de rendimiento:</span><span class="sxs-lookup"><span data-stu-id="de3cf-601">We'll take a look at the following options, compare the pros and cons of each, and examine their performance characteristics:</span></span>

-   <span data-ttu-id="de3cf-602">LINQ to Entities.</span><span class="sxs-lookup"><span data-stu-id="de3cf-602">LINQ to Entities.</span></span>
-   <span data-ttu-id="de3cf-603">Sin seguimiento LINQ to Entities.</span><span class="sxs-lookup"><span data-stu-id="de3cf-603">No Tracking LINQ to Entities.</span></span>
-   <span data-ttu-id="de3cf-604">Entity SQL a través de un elemento ObjectQuery.</span><span class="sxs-lookup"><span data-stu-id="de3cf-604">Entity SQL over an ObjectQuery.</span></span>
-   <span data-ttu-id="de3cf-605">Entity SQL a través de un EntityCommand.</span><span class="sxs-lookup"><span data-stu-id="de3cf-605">Entity SQL over an EntityCommand.</span></span>
-   <span data-ttu-id="de3cf-606">ExecuteStoreQuery.</span><span class="sxs-lookup"><span data-stu-id="de3cf-606">ExecuteStoreQuery.</span></span>
-   <span data-ttu-id="de3cf-607">SqlQuery.</span><span class="sxs-lookup"><span data-stu-id="de3cf-607">SqlQuery.</span></span>
-   <span data-ttu-id="de3cf-608">CompiledQuery.</span><span class="sxs-lookup"><span data-stu-id="de3cf-608">CompiledQuery.</span></span>

### <a name="61-linq-to-entities-queries"></a><span data-ttu-id="de3cf-609">6.1 consultas LINQ to Entities</span><span class="sxs-lookup"><span data-stu-id="de3cf-609">6.1       LINQ to Entities queries</span></span>

``` csharp
var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
```

<span data-ttu-id="de3cf-610">**Profesionales**</span><span class="sxs-lookup"><span data-stu-id="de3cf-610">**Pros**</span></span>

-   <span data-ttu-id="de3cf-611">Adecuado para las operaciones CUD.</span><span class="sxs-lookup"><span data-stu-id="de3cf-611">Suitable for CUD operations.</span></span>
-   <span data-ttu-id="de3cf-612">Objetos materializados completamente.</span><span class="sxs-lookup"><span data-stu-id="de3cf-612">Fully materialized objects.</span></span>
-   <span data-ttu-id="de3cf-613">Más fáciles de escribir con la sintaxis se integran en el lenguaje de programación.</span><span class="sxs-lookup"><span data-stu-id="de3cf-613">Simplest to write with syntax built into the programming language.</span></span>
-   <span data-ttu-id="de3cf-614">Buen rendimiento.</span><span class="sxs-lookup"><span data-stu-id="de3cf-614">Good performance.</span></span>

<span data-ttu-id="de3cf-615">**Desventajas**</span><span class="sxs-lookup"><span data-stu-id="de3cf-615">**Cons**</span></span>

-   <span data-ttu-id="de3cf-616">Ciertas restricciones técnicas, tales como:</span><span class="sxs-lookup"><span data-stu-id="de3cf-616">Certain technical restrictions, such as:</span></span>
    -   <span data-ttu-id="de3cf-617">Como resultado patrones de uso de DefaultIfEmpty para consultas OUTER JOIN en consultas más complejas que instrucciones sencillas OUTER JOIN de Entity SQL.</span><span class="sxs-lookup"><span data-stu-id="de3cf-617">Patterns using DefaultIfEmpty for OUTER JOIN queries result in more complex queries than simple OUTER JOIN statements in Entity SQL.</span></span>
    -   <span data-ttu-id="de3cf-618">Todavía no se puede utilizar LIKE con coincidencia de patrones generales.</span><span class="sxs-lookup"><span data-stu-id="de3cf-618">You still can’t use LIKE with general pattern matching.</span></span>

### <a name="62-no-tracking-linq-to-entities-queries"></a><span data-ttu-id="de3cf-619">6.2 ningún seguimiento LINQ a consultas de entidades</span><span class="sxs-lookup"><span data-stu-id="de3cf-619">6.2       No Tracking LINQ to Entities queries</span></span>

<span data-ttu-id="de3cf-620">Cuando el contexto deriva ObjectContext:</span><span class="sxs-lookup"><span data-stu-id="de3cf-620">When the context derives ObjectContext:</span></span>

``` csharp
context.Products.MergeOption = MergeOption.NoTracking;
var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
```

<span data-ttu-id="de3cf-621">Cuando el contexto deriva de DbContext:</span><span class="sxs-lookup"><span data-stu-id="de3cf-621">When the context derives DbContext:</span></span>

``` csharp
var q = context.Products.AsNoTracking()
                        .Where(p => p.Category.CategoryName == "Beverages");
```

<span data-ttu-id="de3cf-622">**Profesionales**</span><span class="sxs-lookup"><span data-stu-id="de3cf-622">**Pros**</span></span>

-   <span data-ttu-id="de3cf-623">Mejorar el rendimiento a través de las consultas LINQ normales.</span><span class="sxs-lookup"><span data-stu-id="de3cf-623">Improved performance over regular LINQ queries.</span></span>
-   <span data-ttu-id="de3cf-624">Objetos materializados completamente.</span><span class="sxs-lookup"><span data-stu-id="de3cf-624">Fully materialized objects.</span></span>
-   <span data-ttu-id="de3cf-625">Más fáciles de escribir con la sintaxis se integran en el lenguaje de programación.</span><span class="sxs-lookup"><span data-stu-id="de3cf-625">Simplest to write with syntax built into the programming language.</span></span>

<span data-ttu-id="de3cf-626">**Desventajas**</span><span class="sxs-lookup"><span data-stu-id="de3cf-626">**Cons**</span></span>

-   <span data-ttu-id="de3cf-627">No es adecuado para las operaciones CUD.</span><span class="sxs-lookup"><span data-stu-id="de3cf-627">Not suitable for CUD operations.</span></span>
-   <span data-ttu-id="de3cf-628">Ciertas restricciones técnicas, tales como:</span><span class="sxs-lookup"><span data-stu-id="de3cf-628">Certain technical restrictions, such as:</span></span>
    -   <span data-ttu-id="de3cf-629">Como resultado patrones de uso de DefaultIfEmpty para consultas OUTER JOIN en consultas más complejas que instrucciones sencillas OUTER JOIN de Entity SQL.</span><span class="sxs-lookup"><span data-stu-id="de3cf-629">Patterns using DefaultIfEmpty for OUTER JOIN queries result in more complex queries than simple OUTER JOIN statements in Entity SQL.</span></span>
    -   <span data-ttu-id="de3cf-630">Todavía no se puede utilizar LIKE con coincidencia de patrones generales.</span><span class="sxs-lookup"><span data-stu-id="de3cf-630">You still can’t use LIKE with general pattern matching.</span></span>

<span data-ttu-id="de3cf-631">Tenga en cuenta que las consultas que las propiedades escalares del proyecto no se realiza el seguimiento incluso si no se especifica el NoTracking.</span><span class="sxs-lookup"><span data-stu-id="de3cf-631">Note that queries that project scalar properties are not tracked even if the NoTracking is not specified.</span></span> <span data-ttu-id="de3cf-632">Por ejemplo:</span><span class="sxs-lookup"><span data-stu-id="de3cf-632">For example:</span></span>

``` csharp
var q = context.Products.Where(p => p.Category.CategoryName == "Beverages").Select(p => new { p.ProductName });
```

<span data-ttu-id="de3cf-633">Esta consulta en particular no especifica explícitamente que se va a NoTracking, pero dado que no lo es materializar un tipo que se sabe que el Administrador de estado de objeto, a continuación, el resultado materializado no realiza el seguimiento.</span><span class="sxs-lookup"><span data-stu-id="de3cf-633">This particular query doesn’t explicitly specify being NoTracking, but since it’s not materializing a type that’s known to the object state manager then the materialized result is not tracked.</span></span>

### <a name="63-entity-sql-over-an-objectquery"></a><span data-ttu-id="de3cf-634">6.3 entity SQL a través de un elemento ObjectQuery</span><span class="sxs-lookup"><span data-stu-id="de3cf-634">6.3       Entity SQL over an ObjectQuery</span></span>

``` csharp
ObjectQuery<Product> products = context.Products.Where("it.Category.CategoryName = 'Beverages'");
```

<span data-ttu-id="de3cf-635">**Profesionales**</span><span class="sxs-lookup"><span data-stu-id="de3cf-635">**Pros**</span></span>

-   <span data-ttu-id="de3cf-636">Adecuado para las operaciones CUD.</span><span class="sxs-lookup"><span data-stu-id="de3cf-636">Suitable for CUD operations.</span></span>
-   <span data-ttu-id="de3cf-637">Objetos materializados completamente.</span><span class="sxs-lookup"><span data-stu-id="de3cf-637">Fully materialized objects.</span></span>
-   <span data-ttu-id="de3cf-638">Admite el almacenamiento en caché de plan de consulta.</span><span class="sxs-lookup"><span data-stu-id="de3cf-638">Supports query plan caching.</span></span>

<span data-ttu-id="de3cf-639">**Desventajas**</span><span class="sxs-lookup"><span data-stu-id="de3cf-639">**Cons**</span></span>

-   <span data-ttu-id="de3cf-640">Incluye cadenas de consulta textual que son más propensas a errores del usuario que las construcciones de consulta integradas en el lenguaje.</span><span class="sxs-lookup"><span data-stu-id="de3cf-640">Involves textual query strings which are more prone to user error than query constructs built into the language.</span></span>

### <a name="64-entity-sql-over-an-entity-command"></a><span data-ttu-id="de3cf-641">6.4 entity SQL a través de un comando de entidad</span><span class="sxs-lookup"><span data-stu-id="de3cf-641">6.4       Entity SQL over an Entity Command</span></span>

``` csharp
EntityCommand cmd = eConn.CreateCommand();
cmd.CommandText = "Select p From NorthwindEntities.Products As p Where p.Category.CategoryName = 'Beverages'";

using (EntityDataReader reader = cmd.ExecuteReader(CommandBehavior.SequentialAccess))
{
    while (reader.Read())
    {
        // manually 'materialize' the product
    }
}
```

<span data-ttu-id="de3cf-642">**Profesionales**</span><span class="sxs-lookup"><span data-stu-id="de3cf-642">**Pros**</span></span>

-   <span data-ttu-id="de3cf-643">Admite el almacenamiento en caché de plan en .NET Framework 4.0 (almacenamiento en caché de plan es compatible con todos los demás tipos de consulta en .NET 4.5) de consulta.</span><span class="sxs-lookup"><span data-stu-id="de3cf-643">Supports query plan caching in .NET 4.0 (plan caching is supported by all other query types in .NET 4.5).</span></span>

<span data-ttu-id="de3cf-644">**Desventajas**</span><span class="sxs-lookup"><span data-stu-id="de3cf-644">**Cons**</span></span>

-   <span data-ttu-id="de3cf-645">Incluye cadenas de consulta textual que son más propensas a errores del usuario que las construcciones de consulta integradas en el lenguaje.</span><span class="sxs-lookup"><span data-stu-id="de3cf-645">Involves textual query strings which are more prone to user error than query constructs built into the language.</span></span>
-   <span data-ttu-id="de3cf-646">No es adecuado para las operaciones CUD.</span><span class="sxs-lookup"><span data-stu-id="de3cf-646">Not suitable for CUD operations.</span></span>
-   <span data-ttu-id="de3cf-647">Los resultados no se materializan automáticamente y se deben leer del lector de datos.</span><span class="sxs-lookup"><span data-stu-id="de3cf-647">Results are not automatically materialized, and must be read from the data reader.</span></span>

### <a name="65-sqlquery-and-executestorequery"></a><span data-ttu-id="de3cf-648">6.5 SqlQuery y ExecuteStoreQuery</span><span class="sxs-lookup"><span data-stu-id="de3cf-648">6.5       SqlQuery and ExecuteStoreQuery</span></span>

<span data-ttu-id="de3cf-649">Consulta SQL en la base de datos:</span><span class="sxs-lookup"><span data-stu-id="de3cf-649">SqlQuery on Database:</span></span>

``` csharp
// use this to obtain entities and not track them
var q1 = context.Database.SqlQuery<Product>("select * from products");
```

<span data-ttu-id="de3cf-650">SqlQuery en DbSet:</span><span class="sxs-lookup"><span data-stu-id="de3cf-650">SqlQuery on DbSet:</span></span>

``` csharp
// use this to obtain entities and have them tracked
var q2 = context.Products.SqlQuery("select * from products");
```

<span data-ttu-id="de3cf-651">ExecyteStoreQuery:</span><span class="sxs-lookup"><span data-stu-id="de3cf-651">ExecyteStoreQuery:</span></span>

``` csharp
var beverages = context.ExecuteStoreQuery<Product>(
@"     SELECT        P.ProductID, P.ProductName, P.SupplierID, P.CategoryID, P.QuantityPerUnit, P.UnitPrice, P.UnitsInStock, P.UnitsOnOrder, P.ReorderLevel, P.Discontinued, P.DiscontinuedDate
       FROM            Products AS P INNER JOIN Categories AS C ON P.CategoryID = C.CategoryID
       WHERE        (C.CategoryName = 'Beverages')"
);
```

<span data-ttu-id="de3cf-652">**Profesionales**</span><span class="sxs-lookup"><span data-stu-id="de3cf-652">**Pros**</span></span>

-   <span data-ttu-id="de3cf-653">Por lo general rendimiento más rápido porque el compilador de plan se omite.</span><span class="sxs-lookup"><span data-stu-id="de3cf-653">Generally fastest performance since plan compiler is bypassed.</span></span>
-   <span data-ttu-id="de3cf-654">Objetos materializados completamente.</span><span class="sxs-lookup"><span data-stu-id="de3cf-654">Fully materialized objects.</span></span>
-   <span data-ttu-id="de3cf-655">Adecuado para las operaciones CUD cuando se usa en la clase DbSet.</span><span class="sxs-lookup"><span data-stu-id="de3cf-655">Suitable for CUD operations when used from the DbSet.</span></span>

<span data-ttu-id="de3cf-656">**Desventajas**</span><span class="sxs-lookup"><span data-stu-id="de3cf-656">**Cons**</span></span>

-   <span data-ttu-id="de3cf-657">La consulta es textual y propenso a errores.</span><span class="sxs-lookup"><span data-stu-id="de3cf-657">Query is textual and error prone.</span></span>
-   <span data-ttu-id="de3cf-658">Consulta está asociada a un back-end específico mediante la semántica del almacén en lugar de semántica conceptual.</span><span class="sxs-lookup"><span data-stu-id="de3cf-658">Query is tied to a specific backend by using store semantics instead of conceptual semantics.</span></span>
-   <span data-ttu-id="de3cf-659">Cuando está presente la herencia, consultas artesanales deben tener en cuenta las condiciones de asignación para el tipo solicitado.</span><span class="sxs-lookup"><span data-stu-id="de3cf-659">When inheritance is present, handcrafted query needs to account for mapping conditions for the type requested.</span></span>

### <a name="66-compiledquery"></a><span data-ttu-id="de3cf-660">6.6 CompiledQuery</span><span class="sxs-lookup"><span data-stu-id="de3cf-660">6.6       CompiledQuery</span></span>

``` csharp
private static readonly Func<NorthwindEntities, string, IQueryable<Product>> productsForCategoryCQ = CompiledQuery.Compile(
    (NorthwindEntities context, string categoryName) =>
        context.Products.Where(p => p.Category.CategoryName == categoryName)
        );
…
var q = context.InvokeProductsForCategoryCQ("Beverages");
```

<span data-ttu-id="de3cf-661">**Profesionales**</span><span class="sxs-lookup"><span data-stu-id="de3cf-661">**Pros**</span></span>

-   <span data-ttu-id="de3cf-662">Proporciona hasta una mejora del rendimiento de 7% con respecto a las consultas LINQ normales.</span><span class="sxs-lookup"><span data-stu-id="de3cf-662">Provides up to a 7% performance improvement over regular LINQ queries.</span></span>
-   <span data-ttu-id="de3cf-663">Objetos materializados completamente.</span><span class="sxs-lookup"><span data-stu-id="de3cf-663">Fully materialized objects.</span></span>
-   <span data-ttu-id="de3cf-664">Adecuado para las operaciones CUD.</span><span class="sxs-lookup"><span data-stu-id="de3cf-664">Suitable for CUD operations.</span></span>

<span data-ttu-id="de3cf-665">**Desventajas**</span><span class="sxs-lookup"><span data-stu-id="de3cf-665">**Cons**</span></span>

-   <span data-ttu-id="de3cf-666">Mayor complejidad y sobrecarga de programación.</span><span class="sxs-lookup"><span data-stu-id="de3cf-666">Increased complexity and programming overhead.</span></span>
-   <span data-ttu-id="de3cf-667">La mejora del rendimiento se pierde al redactar encima de una consulta compilada.</span><span class="sxs-lookup"><span data-stu-id="de3cf-667">The performance improvement is lost when composing on top of a compiled query.</span></span>
-   <span data-ttu-id="de3cf-668">Algunas consultas LINQ no se puede escribir como un CompiledQuery - por ejemplo, las proyecciones de tipos anónimos.</span><span class="sxs-lookup"><span data-stu-id="de3cf-668">Some LINQ queries can't be written as a CompiledQuery - for example, projections of anonymous types.</span></span>

### <a name="67-performance-comparison-of-different-query-options"></a><span data-ttu-id="de3cf-669">6.7 comparación de rendimiento de opciones de consulta diferentes</span><span class="sxs-lookup"><span data-stu-id="de3cf-669">6.7       Performance Comparison of different query options</span></span>

<span data-ttu-id="de3cf-670">Microbenchmarks simple donde no se programó la creación del contexto se ponga a prueba.</span><span class="sxs-lookup"><span data-stu-id="de3cf-670">Simple microbenchmarks where the context creation was not timed were put to the test.</span></span> <span data-ttu-id="de3cf-671">Hemos medido consultas 5.000 veces superior para un conjunto de entidades sin almacenamiento en caché en un entorno controlado.</span><span class="sxs-lookup"><span data-stu-id="de3cf-671">We measured querying 5000 times for a set of non-cached entities in a controlled environment.</span></span> <span data-ttu-id="de3cf-672">Estos números son que se debe realizar con una advertencia: no reflejan los números reales generados por una aplicación, pero en su lugar, son una medida muy precisa de cuánto hay cuando se comparan las opciones de consultas diferentes una diferencia de rendimiento Apples-a-manzanas, sin incluir el costo de crear un nuevo contexto.</span><span class="sxs-lookup"><span data-stu-id="de3cf-672">These numbers are to be taken with a warning: they do not reflect actual numbers produced by an application, but instead they are a very accurate measurement of how much of a performance difference there is when different querying options are compared apples-to-apples, excluding the cost of creating a new context.</span></span>

| <span data-ttu-id="de3cf-673">EF</span><span class="sxs-lookup"><span data-stu-id="de3cf-673">EF</span></span>  | <span data-ttu-id="de3cf-674">Prueba</span><span class="sxs-lookup"><span data-stu-id="de3cf-674">Test</span></span>                                 | <span data-ttu-id="de3cf-675">Tiempo (ms)</span><span class="sxs-lookup"><span data-stu-id="de3cf-675">Time (ms)</span></span> | <span data-ttu-id="de3cf-676">Memoria</span><span class="sxs-lookup"><span data-stu-id="de3cf-676">Memory</span></span>   |
|:----|:-------------------------------------|:----------|:---------|
| <span data-ttu-id="de3cf-677">EF5</span><span class="sxs-lookup"><span data-stu-id="de3cf-677">EF5</span></span> | <span data-ttu-id="de3cf-678">ESQL ObjectContext</span><span class="sxs-lookup"><span data-stu-id="de3cf-678">ObjectContext ESQL</span></span>                   | <span data-ttu-id="de3cf-679">2414</span><span class="sxs-lookup"><span data-stu-id="de3cf-679">2414</span></span>      | <span data-ttu-id="de3cf-680">38801408</span><span class="sxs-lookup"><span data-stu-id="de3cf-680">38801408</span></span> |
| <span data-ttu-id="de3cf-681">EF5</span><span class="sxs-lookup"><span data-stu-id="de3cf-681">EF5</span></span> | <span data-ttu-id="de3cf-682">Consulta de Linq de ObjectContext</span><span class="sxs-lookup"><span data-stu-id="de3cf-682">ObjectContext Linq Query</span></span>             | <span data-ttu-id="de3cf-683">2692</span><span class="sxs-lookup"><span data-stu-id="de3cf-683">2692</span></span>      | <span data-ttu-id="de3cf-684">38277120</span><span class="sxs-lookup"><span data-stu-id="de3cf-684">38277120</span></span> |
| <span data-ttu-id="de3cf-685">EF5</span><span class="sxs-lookup"><span data-stu-id="de3cf-685">EF5</span></span> | <span data-ttu-id="de3cf-686">Ningún seguimiento de consultas de DbContext Linq</span><span class="sxs-lookup"><span data-stu-id="de3cf-686">DbContext Linq Query No Tracking</span></span>     | <span data-ttu-id="de3cf-687">2818</span><span class="sxs-lookup"><span data-stu-id="de3cf-687">2818</span></span>      | <span data-ttu-id="de3cf-688">41840640</span><span class="sxs-lookup"><span data-stu-id="de3cf-688">41840640</span></span> |
| <span data-ttu-id="de3cf-689">EF5</span><span class="sxs-lookup"><span data-stu-id="de3cf-689">EF5</span></span> | <span data-ttu-id="de3cf-690">Consulta de Linq de DbContext</span><span class="sxs-lookup"><span data-stu-id="de3cf-690">DbContext Linq Query</span></span>                 | <span data-ttu-id="de3cf-691">2930</span><span class="sxs-lookup"><span data-stu-id="de3cf-691">2930</span></span>      | <span data-ttu-id="de3cf-692">41771008</span><span class="sxs-lookup"><span data-stu-id="de3cf-692">41771008</span></span> |
| <span data-ttu-id="de3cf-693">EF5</span><span class="sxs-lookup"><span data-stu-id="de3cf-693">EF5</span></span> | <span data-ttu-id="de3cf-694">Ningún seguimiento de consultas de ObjectContext Linq</span><span class="sxs-lookup"><span data-stu-id="de3cf-694">ObjectContext Linq Query No Tracking</span></span> | <span data-ttu-id="de3cf-695">3013</span><span class="sxs-lookup"><span data-stu-id="de3cf-695">3013</span></span>      | <span data-ttu-id="de3cf-696">38412288</span><span class="sxs-lookup"><span data-stu-id="de3cf-696">38412288</span></span> |
|     |                                      |           |          |
| <span data-ttu-id="de3cf-697">EF6</span><span class="sxs-lookup"><span data-stu-id="de3cf-697">EF6</span></span> | <span data-ttu-id="de3cf-698">ESQL ObjectContext</span><span class="sxs-lookup"><span data-stu-id="de3cf-698">ObjectContext ESQL</span></span>                   | <span data-ttu-id="de3cf-699">2059</span><span class="sxs-lookup"><span data-stu-id="de3cf-699">2059</span></span>      | <span data-ttu-id="de3cf-700">46039040</span><span class="sxs-lookup"><span data-stu-id="de3cf-700">46039040</span></span> |
| <span data-ttu-id="de3cf-701">EF6</span><span class="sxs-lookup"><span data-stu-id="de3cf-701">EF6</span></span> | <span data-ttu-id="de3cf-702">Consulta de Linq de ObjectContext</span><span class="sxs-lookup"><span data-stu-id="de3cf-702">ObjectContext Linq Query</span></span>             | <span data-ttu-id="de3cf-703">3074</span><span class="sxs-lookup"><span data-stu-id="de3cf-703">3074</span></span>      | <span data-ttu-id="de3cf-704">45248512</span><span class="sxs-lookup"><span data-stu-id="de3cf-704">45248512</span></span> |
| <span data-ttu-id="de3cf-705">EF6</span><span class="sxs-lookup"><span data-stu-id="de3cf-705">EF6</span></span> | <span data-ttu-id="de3cf-706">Ningún seguimiento de consultas de DbContext Linq</span><span class="sxs-lookup"><span data-stu-id="de3cf-706">DbContext Linq Query No Tracking</span></span>     | <span data-ttu-id="de3cf-707">3125</span><span class="sxs-lookup"><span data-stu-id="de3cf-707">3125</span></span>      | <span data-ttu-id="de3cf-708">47575040</span><span class="sxs-lookup"><span data-stu-id="de3cf-708">47575040</span></span> |
| <span data-ttu-id="de3cf-709">EF6</span><span class="sxs-lookup"><span data-stu-id="de3cf-709">EF6</span></span> | <span data-ttu-id="de3cf-710">Consulta de Linq de DbContext</span><span class="sxs-lookup"><span data-stu-id="de3cf-710">DbContext Linq Query</span></span>                 | <span data-ttu-id="de3cf-711">3420</span><span class="sxs-lookup"><span data-stu-id="de3cf-711">3420</span></span>      | <span data-ttu-id="de3cf-712">47652864</span><span class="sxs-lookup"><span data-stu-id="de3cf-712">47652864</span></span> |
| <span data-ttu-id="de3cf-713">EF6</span><span class="sxs-lookup"><span data-stu-id="de3cf-713">EF6</span></span> | <span data-ttu-id="de3cf-714">Ningún seguimiento de consultas de ObjectContext Linq</span><span class="sxs-lookup"><span data-stu-id="de3cf-714">ObjectContext Linq Query No Tracking</span></span> | <span data-ttu-id="de3cf-715">3593</span><span class="sxs-lookup"><span data-stu-id="de3cf-715">3593</span></span>      | <span data-ttu-id="de3cf-716">45260800</span><span class="sxs-lookup"><span data-stu-id="de3cf-716">45260800</span></span> |

![Pruebas comparativas microcargas de EF5, 5000 iteraciones semiactivos](~/ef6/media/ef5micro5000warm.png)

![EF6 micro las pruebas comparativas, 5000 iteraciones semiactivos](~/ef6/media/ef6micro5000warm.png)

<span data-ttu-id="de3cf-719">Microbenchmarks son muy sensibles a pequeños cambios en el código.</span><span class="sxs-lookup"><span data-stu-id="de3cf-719">Microbenchmarks are very sensitive to small changes in the code.</span></span> <span data-ttu-id="de3cf-720">En este caso, la diferencia entre los costos de Entity Framework 5 y Entity Framework 6 son debido a la adición de [intercepción](~/ef6/fundamentals/logging-and-interception.md) y [mejoras transaccionales](~/ef6/saving/transactions.md).</span><span class="sxs-lookup"><span data-stu-id="de3cf-720">In this case, the difference between the costs of Entity Framework 5 and Entity Framework 6 are due to the addition of [interception](~/ef6/fundamentals/logging-and-interception.md) and [transactional improvements](~/ef6/saving/transactions.md).</span></span> <span data-ttu-id="de3cf-721">Estos números microbenchmarks, sin embargo, son una visión amplificada en un fragmento muy pequeño de lo que hace Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="de3cf-721">These microbenchmarks numbers, however, are an amplified vision into a very small fragment of what Entity Framework does.</span></span> <span data-ttu-id="de3cf-722">Escenarios del mundo real de las consultas calientes no deberían ver una regresión del rendimiento al actualizar desde Entity Framework 5 a Entity Framework 6.</span><span class="sxs-lookup"><span data-stu-id="de3cf-722">Real-world scenarios of warm queries should not see a performance regression when upgrading from Entity Framework 5 to Entity Framework 6.</span></span>

<span data-ttu-id="de3cf-723">Para comparar el rendimiento real de las opciones de consulta diferentes, creamos 5 variaciones de prueba independiente donde se utilice una opción de consulta diferentes para seleccionar todos los productos cuyo nombre de categoría es "Bebidas".</span><span class="sxs-lookup"><span data-stu-id="de3cf-723">To compare the real-world performance of the different query options, we created 5 separate test variations where we use a different query option to select all products whose category name is "Beverages".</span></span> <span data-ttu-id="de3cf-724">Cada iteración incluye el costo de crear el contexto y el costo de materializar las entidades devueltas todo.</span><span class="sxs-lookup"><span data-stu-id="de3cf-724">Each iteration includes the cost of creating the context, and the cost of materializing all returned entities.</span></span> <span data-ttu-id="de3cf-725">10 iteraciones se ejecutan untimed antes de realizar la suma de iteraciones ha superado el tiempo de 1000.</span><span class="sxs-lookup"><span data-stu-id="de3cf-725">10 iterations are run untimed before taking the sum of 1000 timed iterations.</span></span> <span data-ttu-id="de3cf-726">Los resultados mostrados son la mediana ejecución tomada de 5 ejecuciones de cada prueba.</span><span class="sxs-lookup"><span data-stu-id="de3cf-726">The results shown are the median run taken from 5 runs of each test.</span></span> <span data-ttu-id="de3cf-727">Para obtener más información, consulte el apéndice B, que incluye el código de la prueba.</span><span class="sxs-lookup"><span data-stu-id="de3cf-727">For more information, see Appendix B which includes the code for the test.</span></span>

| <span data-ttu-id="de3cf-728">EF</span><span class="sxs-lookup"><span data-stu-id="de3cf-728">EF</span></span>  | <span data-ttu-id="de3cf-729">Prueba</span><span class="sxs-lookup"><span data-stu-id="de3cf-729">Test</span></span>                                        | <span data-ttu-id="de3cf-730">Tiempo (ms)</span><span class="sxs-lookup"><span data-stu-id="de3cf-730">Time (ms)</span></span> | <span data-ttu-id="de3cf-731">Memoria</span><span class="sxs-lookup"><span data-stu-id="de3cf-731">Memory</span></span>   |
|:----|:--------------------------------------------|:----------|:---------|
| <span data-ttu-id="de3cf-732">EF5</span><span class="sxs-lookup"><span data-stu-id="de3cf-732">EF5</span></span> | <span data-ttu-id="de3cf-733">Comando de la entidad de ObjectContext</span><span class="sxs-lookup"><span data-stu-id="de3cf-733">ObjectContext Entity Command</span></span>                | <span data-ttu-id="de3cf-734">621</span><span class="sxs-lookup"><span data-stu-id="de3cf-734">621</span></span>       | <span data-ttu-id="de3cf-735">39350272</span><span class="sxs-lookup"><span data-stu-id="de3cf-735">39350272</span></span> |
| <span data-ttu-id="de3cf-736">EF5</span><span class="sxs-lookup"><span data-stu-id="de3cf-736">EF5</span></span> | <span data-ttu-id="de3cf-737">Consulta Sql de DbContext en la base de datos</span><span class="sxs-lookup"><span data-stu-id="de3cf-737">DbContext Sql Query on Database</span></span>             | <span data-ttu-id="de3cf-738">825</span><span class="sxs-lookup"><span data-stu-id="de3cf-738">825</span></span>       | <span data-ttu-id="de3cf-739">37519360</span><span class="sxs-lookup"><span data-stu-id="de3cf-739">37519360</span></span> |
| <span data-ttu-id="de3cf-740">EF5</span><span class="sxs-lookup"><span data-stu-id="de3cf-740">EF5</span></span> | <span data-ttu-id="de3cf-741">Query Store ObjectContext</span><span class="sxs-lookup"><span data-stu-id="de3cf-741">ObjectContext Store Query</span></span>                   | <span data-ttu-id="de3cf-742">878</span><span class="sxs-lookup"><span data-stu-id="de3cf-742">878</span></span>       | <span data-ttu-id="de3cf-743">39460864</span><span class="sxs-lookup"><span data-stu-id="de3cf-743">39460864</span></span> |
| <span data-ttu-id="de3cf-744">EF5</span><span class="sxs-lookup"><span data-stu-id="de3cf-744">EF5</span></span> | <span data-ttu-id="de3cf-745">Ningún seguimiento de consultas de ObjectContext Linq</span><span class="sxs-lookup"><span data-stu-id="de3cf-745">ObjectContext Linq Query No Tracking</span></span>        | <span data-ttu-id="de3cf-746">969</span><span class="sxs-lookup"><span data-stu-id="de3cf-746">969</span></span>       | <span data-ttu-id="de3cf-747">38293504</span><span class="sxs-lookup"><span data-stu-id="de3cf-747">38293504</span></span> |
| <span data-ttu-id="de3cf-748">EF5</span><span class="sxs-lookup"><span data-stu-id="de3cf-748">EF5</span></span> | <span data-ttu-id="de3cf-749">Mediante la consulta de objeto ObjectContext Entity Sql</span><span class="sxs-lookup"><span data-stu-id="de3cf-749">ObjectContext Entity Sql using Object Query</span></span> | <span data-ttu-id="de3cf-750">1089</span><span class="sxs-lookup"><span data-stu-id="de3cf-750">1089</span></span>      | <span data-ttu-id="de3cf-751">38981632</span><span class="sxs-lookup"><span data-stu-id="de3cf-751">38981632</span></span> |
| <span data-ttu-id="de3cf-752">EF5</span><span class="sxs-lookup"><span data-stu-id="de3cf-752">EF5</span></span> | <span data-ttu-id="de3cf-753">Consulta compilada de ObjectContext</span><span class="sxs-lookup"><span data-stu-id="de3cf-753">ObjectContext Compiled Query</span></span>                | <span data-ttu-id="de3cf-754">1099</span><span class="sxs-lookup"><span data-stu-id="de3cf-754">1099</span></span>      | <span data-ttu-id="de3cf-755">38682624</span><span class="sxs-lookup"><span data-stu-id="de3cf-755">38682624</span></span> |
| <span data-ttu-id="de3cf-756">EF5</span><span class="sxs-lookup"><span data-stu-id="de3cf-756">EF5</span></span> | <span data-ttu-id="de3cf-757">Consulta de Linq de ObjectContext</span><span class="sxs-lookup"><span data-stu-id="de3cf-757">ObjectContext Linq Query</span></span>                    | <span data-ttu-id="de3cf-758">1152</span><span class="sxs-lookup"><span data-stu-id="de3cf-758">1152</span></span>      | <span data-ttu-id="de3cf-759">38178816</span><span class="sxs-lookup"><span data-stu-id="de3cf-759">38178816</span></span> |
| <span data-ttu-id="de3cf-760">EF5</span><span class="sxs-lookup"><span data-stu-id="de3cf-760">EF5</span></span> | <span data-ttu-id="de3cf-761">Ningún seguimiento de consultas de DbContext Linq</span><span class="sxs-lookup"><span data-stu-id="de3cf-761">DbContext Linq Query No Tracking</span></span>            | <span data-ttu-id="de3cf-762">1208</span><span class="sxs-lookup"><span data-stu-id="de3cf-762">1208</span></span>      | <span data-ttu-id="de3cf-763">41803776</span><span class="sxs-lookup"><span data-stu-id="de3cf-763">41803776</span></span> |
| <span data-ttu-id="de3cf-764">EF5</span><span class="sxs-lookup"><span data-stu-id="de3cf-764">EF5</span></span> | <span data-ttu-id="de3cf-765">Consulta Sql de DbContext en DbSet</span><span class="sxs-lookup"><span data-stu-id="de3cf-765">DbContext Sql Query on DbSet</span></span>                | <span data-ttu-id="de3cf-766">1414</span><span class="sxs-lookup"><span data-stu-id="de3cf-766">1414</span></span>      | <span data-ttu-id="de3cf-767">37982208</span><span class="sxs-lookup"><span data-stu-id="de3cf-767">37982208</span></span> |
| <span data-ttu-id="de3cf-768">EF5</span><span class="sxs-lookup"><span data-stu-id="de3cf-768">EF5</span></span> | <span data-ttu-id="de3cf-769">Consulta de Linq de DbContext</span><span class="sxs-lookup"><span data-stu-id="de3cf-769">DbContext Linq Query</span></span>                        | <span data-ttu-id="de3cf-770">1574</span><span class="sxs-lookup"><span data-stu-id="de3cf-770">1574</span></span>      | <span data-ttu-id="de3cf-771">41738240</span><span class="sxs-lookup"><span data-stu-id="de3cf-771">41738240</span></span> |
|     |                                             |           |          |
| <span data-ttu-id="de3cf-772">EF6</span><span class="sxs-lookup"><span data-stu-id="de3cf-772">EF6</span></span> | <span data-ttu-id="de3cf-773">Comando de la entidad de ObjectContext</span><span class="sxs-lookup"><span data-stu-id="de3cf-773">ObjectContext Entity Command</span></span>                | <span data-ttu-id="de3cf-774">480</span><span class="sxs-lookup"><span data-stu-id="de3cf-774">480</span></span>       | <span data-ttu-id="de3cf-775">47247360</span><span class="sxs-lookup"><span data-stu-id="de3cf-775">47247360</span></span> |
| <span data-ttu-id="de3cf-776">EF6</span><span class="sxs-lookup"><span data-stu-id="de3cf-776">EF6</span></span> | <span data-ttu-id="de3cf-777">Query Store ObjectContext</span><span class="sxs-lookup"><span data-stu-id="de3cf-777">ObjectContext Store Query</span></span>                   | <span data-ttu-id="de3cf-778">493</span><span class="sxs-lookup"><span data-stu-id="de3cf-778">493</span></span>       | <span data-ttu-id="de3cf-779">46739456</span><span class="sxs-lookup"><span data-stu-id="de3cf-779">46739456</span></span> |
| <span data-ttu-id="de3cf-780">EF6</span><span class="sxs-lookup"><span data-stu-id="de3cf-780">EF6</span></span> | <span data-ttu-id="de3cf-781">Consulta Sql de DbContext en la base de datos</span><span class="sxs-lookup"><span data-stu-id="de3cf-781">DbContext Sql Query on Database</span></span>             | <span data-ttu-id="de3cf-782">614</span><span class="sxs-lookup"><span data-stu-id="de3cf-782">614</span></span>       | <span data-ttu-id="de3cf-783">41607168</span><span class="sxs-lookup"><span data-stu-id="de3cf-783">41607168</span></span> |
| <span data-ttu-id="de3cf-784">EF6</span><span class="sxs-lookup"><span data-stu-id="de3cf-784">EF6</span></span> | <span data-ttu-id="de3cf-785">Ningún seguimiento de consultas de ObjectContext Linq</span><span class="sxs-lookup"><span data-stu-id="de3cf-785">ObjectContext Linq Query No Tracking</span></span>        | <span data-ttu-id="de3cf-786">684</span><span class="sxs-lookup"><span data-stu-id="de3cf-786">684</span></span>       | <span data-ttu-id="de3cf-787">46333952</span><span class="sxs-lookup"><span data-stu-id="de3cf-787">46333952</span></span> |
| <span data-ttu-id="de3cf-788">EF6</span><span class="sxs-lookup"><span data-stu-id="de3cf-788">EF6</span></span> | <span data-ttu-id="de3cf-789">Mediante la consulta de objeto ObjectContext Entity Sql</span><span class="sxs-lookup"><span data-stu-id="de3cf-789">ObjectContext Entity Sql using Object Query</span></span> | <span data-ttu-id="de3cf-790">767</span><span class="sxs-lookup"><span data-stu-id="de3cf-790">767</span></span>       | <span data-ttu-id="de3cf-791">48865280</span><span class="sxs-lookup"><span data-stu-id="de3cf-791">48865280</span></span> |
| <span data-ttu-id="de3cf-792">EF6</span><span class="sxs-lookup"><span data-stu-id="de3cf-792">EF6</span></span> | <span data-ttu-id="de3cf-793">Consulta compilada de ObjectContext</span><span class="sxs-lookup"><span data-stu-id="de3cf-793">ObjectContext Compiled Query</span></span>                | <span data-ttu-id="de3cf-794">788</span><span class="sxs-lookup"><span data-stu-id="de3cf-794">788</span></span>       | <span data-ttu-id="de3cf-795">48467968</span><span class="sxs-lookup"><span data-stu-id="de3cf-795">48467968</span></span> |
| <span data-ttu-id="de3cf-796">EF6</span><span class="sxs-lookup"><span data-stu-id="de3cf-796">EF6</span></span> | <span data-ttu-id="de3cf-797">Ningún seguimiento de consultas de DbContext Linq</span><span class="sxs-lookup"><span data-stu-id="de3cf-797">DbContext Linq Query No Tracking</span></span>            | <span data-ttu-id="de3cf-798">878</span><span class="sxs-lookup"><span data-stu-id="de3cf-798">878</span></span>       | <span data-ttu-id="de3cf-799">47554560</span><span class="sxs-lookup"><span data-stu-id="de3cf-799">47554560</span></span> |
| <span data-ttu-id="de3cf-800">EF6</span><span class="sxs-lookup"><span data-stu-id="de3cf-800">EF6</span></span> | <span data-ttu-id="de3cf-801">Consulta de Linq de ObjectContext</span><span class="sxs-lookup"><span data-stu-id="de3cf-801">ObjectContext Linq Query</span></span>                    | <span data-ttu-id="de3cf-802">953</span><span class="sxs-lookup"><span data-stu-id="de3cf-802">953</span></span>       | <span data-ttu-id="de3cf-803">47632384</span><span class="sxs-lookup"><span data-stu-id="de3cf-803">47632384</span></span> |
| <span data-ttu-id="de3cf-804">EF6</span><span class="sxs-lookup"><span data-stu-id="de3cf-804">EF6</span></span> | <span data-ttu-id="de3cf-805">Consulta Sql de DbContext en DbSet</span><span class="sxs-lookup"><span data-stu-id="de3cf-805">DbContext Sql Query on DbSet</span></span>                | <span data-ttu-id="de3cf-806">1023</span><span class="sxs-lookup"><span data-stu-id="de3cf-806">1023</span></span>      | <span data-ttu-id="de3cf-807">41992192</span><span class="sxs-lookup"><span data-stu-id="de3cf-807">41992192</span></span> |
| <span data-ttu-id="de3cf-808">EF6</span><span class="sxs-lookup"><span data-stu-id="de3cf-808">EF6</span></span> | <span data-ttu-id="de3cf-809">Consulta de Linq de DbContext</span><span class="sxs-lookup"><span data-stu-id="de3cf-809">DbContext Linq Query</span></span>                        | <span data-ttu-id="de3cf-810">1290</span><span class="sxs-lookup"><span data-stu-id="de3cf-810">1290</span></span>      | <span data-ttu-id="de3cf-811">47529984</span><span class="sxs-lookup"><span data-stu-id="de3cf-811">47529984</span></span> |


![Iteraciones de consulta activa 1000 EF5](~/ef6/media/ef5warmquery1000.png)

![Iteraciones de consulta activa 1000 EF6](~/ef6/media/ef6warmquery1000.png)

> [!NOTE]
> <span data-ttu-id="de3cf-814">Por integridad, hemos incluido una variación donde se ejecuta una consulta de Entity SQL en un EntityCommand.</span><span class="sxs-lookup"><span data-stu-id="de3cf-814">For completeness, we included a variation where we execute an Entity SQL query on an EntityCommand.</span></span> <span data-ttu-id="de3cf-815">Sin embargo, dado que no se materializan los resultados de este tipo de consultas, la comparación no es necesariamente manzanas a manzanas.</span><span class="sxs-lookup"><span data-stu-id="de3cf-815">However, because results are not materialized for such queries, the comparison isn't necessarily apples-to-apples.</span></span> <span data-ttu-id="de3cf-816">La prueba incluye una buena aproximación al materializar intentar realizar la comparación más justa.</span><span class="sxs-lookup"><span data-stu-id="de3cf-816">The test includes a close approximation to materializing to try making the comparison fairer.</span></span>

<span data-ttu-id="de3cf-817">En este caso to-end, Entity Framework 6 supera a Entity Framework 5 debido a las mejoras de rendimiento realizadas en varias partes de la pila, incluida una inicialización mucho más ligera de DbContext y más rápido MetadataCollection&lt;T&gt; búsquedas.</span><span class="sxs-lookup"><span data-stu-id="de3cf-817">In this end-to-end case, Entity Framework 6 outperforms Entity Framework 5 due to performance improvements made on several parts of the stack, including a much lighter DbContext initialization and faster MetadataCollection&lt;T&gt; lookups.</span></span>

## <a name="7-design-time-performance-considerations"></a><span data-ttu-id="de3cf-818">7 Consideraciones de rendimiento de tiempo de diseño</span><span class="sxs-lookup"><span data-stu-id="de3cf-818">7 Design time performance considerations</span></span>

### <a name="71-inheritance-strategies"></a><span data-ttu-id="de3cf-819">7.1 estrategias de herencia</span><span class="sxs-lookup"><span data-stu-id="de3cf-819">7.1       Inheritance Strategies</span></span>

<span data-ttu-id="de3cf-820">Otra consideración de rendimiento al usar Entity Framework es la estrategia de herencia que se utiliza.</span><span class="sxs-lookup"><span data-stu-id="de3cf-820">Another performance consideration when using Entity Framework is the inheritance strategy you use.</span></span> <span data-ttu-id="de3cf-821">Entity Framework admite 3 tipos básicos de herencia y sus combinaciones:</span><span class="sxs-lookup"><span data-stu-id="de3cf-821">Entity Framework supports 3 basic types of inheritance and their combinations:</span></span>

-   <span data-ttu-id="de3cf-822">Tabla por jerarquía (TPH), donde cada herencia establecido se asigna a una tabla con una columna discriminadora para indicar qué tipo concreto de la jerarquía se va a representar en la fila.</span><span class="sxs-lookup"><span data-stu-id="de3cf-822">Table per Hierarchy (TPH) – where each inheritance set maps to a table with a discriminator column to indicate which particular type in the hierarchy is being represented in the row.</span></span>
-   <span data-ttu-id="de3cf-823">Tabla por tipo (TPT), donde cada tipo tiene su propia tabla de la base de datos; las tablas secundarias solo definen las columnas que no contiene la tabla primaria.</span><span class="sxs-lookup"><span data-stu-id="de3cf-823">Table per Type (TPT) – where each type has its own table in the database; the child tables only define the columns that the parent table doesn’t contain.</span></span>
-   <span data-ttu-id="de3cf-824">Tabla por clase (TPC), donde cada tipo tiene su propia tabla completa en la base de datos; las tablas secundarias definen sus campos, los definidos en los tipos de elemento primario incluidos.</span><span class="sxs-lookup"><span data-stu-id="de3cf-824">Table per Class (TPC) – where each type has its own full table in the database; the child tables define all their fields, including those defined in parent types.</span></span>

<span data-ttu-id="de3cf-825">Si el modelo usa la herencia de TPT, las consultas que se generan serán más complejas que los que se generan con las otras estrategias de herencia, lo que pueden resultar en tiempos de ejecución en el almacén.</span><span class="sxs-lookup"><span data-stu-id="de3cf-825">If your model uses TPT inheritance, the queries which are generated will be more complex than those that are generated with the other inheritance strategies, which may result on longer execution times on the store.</span></span><span data-ttu-id="de3cf-826">  Generalmente tarda más tiempo para generar consultas a través de un modelo TPT y para materializar los objetos resultantes.</span><span class="sxs-lookup"><span data-stu-id="de3cf-826">  It will generally take longer to generate queries over a TPT model, and to materialize the resulting objects.</span></span>

<span data-ttu-id="de3cf-827">Vea las "Consideraciones de rendimiento al usar la herencia de TPT (tabla por tipo) en Entity Framework" entrada de blog MSDN: \<http://blogs.msdn.com/b/adonet/archive/2010/08/17/performance-considerations-when-using-tpt-table-per-type-inheritance-in-the-entity-framework.aspx>.</span><span class="sxs-lookup"><span data-stu-id="de3cf-827">See the "Performance Considerations when using TPT (Table per Type) Inheritance in the Entity Framework" MSDN blog post: \<http://blogs.msdn.com/b/adonet/archive/2010/08/17/performance-considerations-when-using-tpt-table-per-type-inheritance-in-the-entity-framework.aspx>.</span></span>

#### <a name="711-avoiding-tpt-in-model-first-or-code-first-applications"></a><span data-ttu-id="de3cf-828">7.1.1 evitar TPT en aplicaciones de Model First o Code First</span><span class="sxs-lookup"><span data-stu-id="de3cf-828">7.1.1       Avoiding TPT in Model First or Code First applications</span></span>

<span data-ttu-id="de3cf-829">Cuando se crea un modelo a través de una base de datos existente que tiene un esquema TPT, no tiene muchas opciones.</span><span class="sxs-lookup"><span data-stu-id="de3cf-829">When you create a model over an existing database that has a TPT schema, you don't have many options.</span></span> <span data-ttu-id="de3cf-830">Pero, al crear una aplicación mediante Model First o Code First, debe evitar la herencia de TPT para problemas de rendimiento.</span><span class="sxs-lookup"><span data-stu-id="de3cf-830">But when creating an application using Model First or Code First, you should avoid TPT inheritance for performance concerns.</span></span>

<span data-ttu-id="de3cf-831">Al usar Model First en el Asistente de Entity Designer, obtendrá TPT para cualquier herencia en el modelo.</span><span class="sxs-lookup"><span data-stu-id="de3cf-831">When you use Model First in the Entity Designer Wizard, you will get TPT for any inheritance in your model.</span></span> <span data-ttu-id="de3cf-832">Si desea cambiar a una estrategia de herencia de TPH con Model First, puede usar el "Entity Designer Database Generation Power Pack" disponible desde la Galería de Visual Studio ( \<http://visualstudiogallery.msdn.microsoft.com/df3541c3-d833-4b65-b942-989e7ec74c87/>).</span><span class="sxs-lookup"><span data-stu-id="de3cf-832">If you want to switch to a TPH inheritance strategy with Model First, you can use the "Entity Designer Database Generation Power Pack" available from the Visual Studio Gallery ( \<http://visualstudiogallery.msdn.microsoft.com/df3541c3-d833-4b65-b942-989e7ec74c87/>).</span></span>

<span data-ttu-id="de3cf-833">Al usar Code First para configurar la asignación de un modelo con herencia, EF la usará TPH de manera predeterminada, por lo tanto, todas las entidades de la jerarquía de herencia se asignará a la misma tabla.</span><span class="sxs-lookup"><span data-stu-id="de3cf-833">When using Code First to configure the mapping of a model with inheritance, EF will use TPH by default, therefore all entities in the inheritance hierarchy will be mapped to the same table.</span></span> <span data-ttu-id="de3cf-834">Consulte la sección "Asignar con la API Fluent" del artículo "La código primero en entidad Framework4.1" en MSDN Magazine ( [http://msdn.microsoft.com/magazine/hh126815.aspx](https://msdn.microsoft.com/magazine/hh126815.aspx)) para obtener más detalles.</span><span class="sxs-lookup"><span data-stu-id="de3cf-834">See the "Mapping with the Fluent API" section of the "Code First in Entity Framework4.1" article in MSDN Magazine ( [http://msdn.microsoft.com/magazine/hh126815.aspx](https://msdn.microsoft.com/magazine/hh126815.aspx)) for more details.</span></span>

### <a name="72-upgrading-from-ef4-to-improve-model-generation-time"></a><span data-ttu-id="de3cf-835">7.2 actualización de EF4 a mejorar la generación del modelo de tiempo</span><span class="sxs-lookup"><span data-stu-id="de3cf-835">7.2       Upgrading from EF4 to improve model generation time</span></span>

<span data-ttu-id="de3cf-836">Una mejora específica de SQL Server para el algoritmo que genera la capa de almacenamiento (SSDL) del modelo está disponible en Entity Framework 5 y 6 y como una actualización de Entity Framework 4, cuando se instala Visual Studio 2010 SP1.</span><span class="sxs-lookup"><span data-stu-id="de3cf-836">A SQL Server-specific improvement to the algorithm that generates the store-layer (SSDL) of the model is available in Entity Framework 5 and 6, and as an update to Entity Framework 4 when Visual Studio 2010 SP1 is installed.</span></span> <span data-ttu-id="de3cf-837">Los resultados de pruebas siguientes muestran la mejora al generar un modelo muy grande, en este caso, el modelo de Navision.</span><span class="sxs-lookup"><span data-stu-id="de3cf-837">The following test results demonstrate the improvement when generating a very big model, in this case the Navision model.</span></span> <span data-ttu-id="de3cf-838">Consulte el apéndice C para obtener más detalles sobre él.</span><span class="sxs-lookup"><span data-stu-id="de3cf-838">See Appendix C for more details about it.</span></span>

<span data-ttu-id="de3cf-839">El modelo contiene conjuntos de entidades 1005 y 4227 conjuntos de asociaciones.</span><span class="sxs-lookup"><span data-stu-id="de3cf-839">The model contains 1005 entity sets and 4227 association sets.</span></span>

| <span data-ttu-id="de3cf-840">Configuración</span><span class="sxs-lookup"><span data-stu-id="de3cf-840">Configuration</span></span>                              | <span data-ttu-id="de3cf-841">Desglose de tiempo consumido</span><span class="sxs-lookup"><span data-stu-id="de3cf-841">Breakdown of time consumed</span></span>                                                                                                                                               |
|:-------------------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="de3cf-842">Visual Studio 2010, Entity Framework 4</span><span class="sxs-lookup"><span data-stu-id="de3cf-842">Visual Studio 2010, Entity Framework 4</span></span>     | <span data-ttu-id="de3cf-843">Generación de SSDL: 2 horas 27 min.</span><span class="sxs-lookup"><span data-stu-id="de3cf-843">SSDL Generation: 2 hr 27 min</span></span> <br/> <span data-ttu-id="de3cf-844">Generación de asignación: 1 segundo</span><span class="sxs-lookup"><span data-stu-id="de3cf-844">Mapping Generation: 1 second</span></span> <br/> <span data-ttu-id="de3cf-845">Generación de CSDL: 1 segundo</span><span class="sxs-lookup"><span data-stu-id="de3cf-845">CSDL Generation: 1 second</span></span> <br/> <span data-ttu-id="de3cf-846">Generación de ObjectLayer: 1 segundo</span><span class="sxs-lookup"><span data-stu-id="de3cf-846">ObjectLayer Generation: 1 second</span></span> <br/> <span data-ttu-id="de3cf-847">Generación de vistas: 2 h 14 minutos</span><span class="sxs-lookup"><span data-stu-id="de3cf-847">View Generation: 2 h 14 min</span></span> |
| <span data-ttu-id="de3cf-848">Visual Studio 2010 SP1, Entity Framework 4</span><span class="sxs-lookup"><span data-stu-id="de3cf-848">Visual Studio 2010 SP1, Entity Framework 4</span></span> | <span data-ttu-id="de3cf-849">Generación de SSDL: 1 segundo</span><span class="sxs-lookup"><span data-stu-id="de3cf-849">SSDL Generation: 1 second</span></span> <br/> <span data-ttu-id="de3cf-850">Generación de asignación: 1 segundo</span><span class="sxs-lookup"><span data-stu-id="de3cf-850">Mapping Generation: 1 second</span></span> <br/> <span data-ttu-id="de3cf-851">Generación de CSDL: 1 segundo</span><span class="sxs-lookup"><span data-stu-id="de3cf-851">CSDL Generation: 1 second</span></span> <br/> <span data-ttu-id="de3cf-852">Generación de ObjectLayer: 1 segundo</span><span class="sxs-lookup"><span data-stu-id="de3cf-852">ObjectLayer Generation: 1 second</span></span> <br/> <span data-ttu-id="de3cf-853">Generación de vistas: 1 hora 53 min.</span><span class="sxs-lookup"><span data-stu-id="de3cf-853">View Generation: 1 hr 53 min</span></span>   |
| <span data-ttu-id="de3cf-854">Visual Studio 2013, Entity Framework 5</span><span class="sxs-lookup"><span data-stu-id="de3cf-854">Visual Studio 2013, Entity Framework 5</span></span>     | <span data-ttu-id="de3cf-855">Generación de SSDL: 1 segundo</span><span class="sxs-lookup"><span data-stu-id="de3cf-855">SSDL Generation: 1 second</span></span> <br/> <span data-ttu-id="de3cf-856">Generación de asignación: 1 segundo</span><span class="sxs-lookup"><span data-stu-id="de3cf-856">Mapping Generation: 1 second</span></span> <br/> <span data-ttu-id="de3cf-857">Generación de CSDL: 1 segundo</span><span class="sxs-lookup"><span data-stu-id="de3cf-857">CSDL Generation: 1 second</span></span> <br/> <span data-ttu-id="de3cf-858">Generación de ObjectLayer: 1 segundo</span><span class="sxs-lookup"><span data-stu-id="de3cf-858">ObjectLayer Generation: 1 second</span></span> <br/> <span data-ttu-id="de3cf-859">Generación de vistas: 65 minutos</span><span class="sxs-lookup"><span data-stu-id="de3cf-859">View Generation: 65 minutes</span></span>    |
| <span data-ttu-id="de3cf-860">Visual Studio 2013, Entity Framework 6</span><span class="sxs-lookup"><span data-stu-id="de3cf-860">Visual Studio 2013, Entity Framework 6</span></span>     | <span data-ttu-id="de3cf-861">Generación de SSDL: 1 segundo</span><span class="sxs-lookup"><span data-stu-id="de3cf-861">SSDL Generation: 1 second</span></span> <br/> <span data-ttu-id="de3cf-862">Generación de asignación: 1 segundo</span><span class="sxs-lookup"><span data-stu-id="de3cf-862">Mapping Generation: 1 second</span></span> <br/> <span data-ttu-id="de3cf-863">Generación de CSDL: 1 segundo</span><span class="sxs-lookup"><span data-stu-id="de3cf-863">CSDL Generation: 1 second</span></span> <br/> <span data-ttu-id="de3cf-864">Generación de ObjectLayer: 1 segundo</span><span class="sxs-lookup"><span data-stu-id="de3cf-864">ObjectLayer Generation: 1 second</span></span> <br/> <span data-ttu-id="de3cf-865">Generación de vistas: 28 segundos.</span><span class="sxs-lookup"><span data-stu-id="de3cf-865">View Generation: 28 seconds.</span></span>   |


<span data-ttu-id="de3cf-866">Es importante destacar que cuando se genera el SSDL, la carga se casi por completo dedica a SQL Server, mientras se espera a que el equipo de desarrollo de cliente inactivo que proceden del servidor de resultados.</span><span class="sxs-lookup"><span data-stu-id="de3cf-866">It's worth noting that when generating the SSDL, the load is almost entirely spent on the SQL Server, while the client development machine is waiting idle for results to come back from the server.</span></span> <span data-ttu-id="de3cf-867">Los DBA deberían apreciarán especialmente esta mejora.</span><span class="sxs-lookup"><span data-stu-id="de3cf-867">DBAs should particularly appreciate this improvement.</span></span> <span data-ttu-id="de3cf-868">También merece la pena tener en cuenta que básicamente el coste íntegro de generación de modelos tiene lugar en la generación de vistas de ahora.</span><span class="sxs-lookup"><span data-stu-id="de3cf-868">It's also worth noting that essentially the entire cost of model generation takes place in View Generation now.</span></span>

### <a name="73-splitting-large-models-with-database-first-and-model-first"></a><span data-ttu-id="de3cf-869">7.3 dividir grandes modelos con la base de datos en primer lugar y Model First</span><span class="sxs-lookup"><span data-stu-id="de3cf-869">7.3       Splitting Large Models with Database First and Model First</span></span>

<span data-ttu-id="de3cf-870">A medida que aumenta el tamaño del modelo, la superficie del diseñador se convierte en confuso y difícil de usar.</span><span class="sxs-lookup"><span data-stu-id="de3cf-870">As model size increases, the designer surface becomes cluttered and difficult to use.</span></span> <span data-ttu-id="de3cf-871">Normalmente consideramos un modelo con más de 300 entidades sea demasiado grande para utilizar el Diseñador de forma efectiva.</span><span class="sxs-lookup"><span data-stu-id="de3cf-871">We typically consider a model with more than 300 entities to be too large to effectively use the designer.</span></span> <span data-ttu-id="de3cf-872">Entrada de blog siguiente describe varias opciones para dividir los modelos grandes: \<http://blogs.msdn.com/b/adonet/archive/2008/11/25/working-with-large-models-in-entity-framework-part-2.aspx>.</span><span class="sxs-lookup"><span data-stu-id="de3cf-872">The following blog post describes several options for splitting large models: \<http://blogs.msdn.com/b/adonet/archive/2008/11/25/working-with-large-models-in-entity-framework-part-2.aspx>.</span></span>

<span data-ttu-id="de3cf-873">La publicación se ha escrito para la primera versión de Entity Framework, pero los pasos se siguen aplican.</span><span class="sxs-lookup"><span data-stu-id="de3cf-873">The post was written for the first version of Entity Framework, but the steps still apply.</span></span>

### <a name="74-performance-considerations-with-the-entity-data-source-control"></a><span data-ttu-id="de3cf-874">7.4 consideraciones de rendimiento de con el Control de origen de datos de entidad</span><span class="sxs-lookup"><span data-stu-id="de3cf-874">7.4       Performance considerations with the Entity Data Source Control</span></span>

<span data-ttu-id="de3cf-875">Hemos visto casos de pruebas de esfuerzo y rendimiento multiproceso donde se deteriora considerablemente el rendimiento de una aplicación web mediante el EntityDataSource Control.</span><span class="sxs-lookup"><span data-stu-id="de3cf-875">We've seen cases in multi-threaded performance and stress tests where the performance of a web application using the EntityDataSource Control deteriorates significantly.</span></span> <span data-ttu-id="de3cf-876">La causa subyacente es que EntityDataSource llama repetidamente a MetadataWorkspace.LoadFromAssembly en los ensamblados que se hace referencia la aplicación Web para detectar los tipos que se usará como entidades.</span><span class="sxs-lookup"><span data-stu-id="de3cf-876">The underlying cause is that the EntityDataSource repeatedly calls MetadataWorkspace.LoadFromAssembly on the assemblies referenced by the Web application to discover the types to be used as entities.</span></span>

<span data-ttu-id="de3cf-877">La solución es establecer el ContextTypeName de EntityDataSource en el nombre de tipo de la clase derivada de ObjectContext.</span><span class="sxs-lookup"><span data-stu-id="de3cf-877">The solution is to set the ContextTypeName of the EntityDataSource to the type name of your derived ObjectContext class.</span></span> <span data-ttu-id="de3cf-878">Esta opción desactiva el mecanismo que examina todos los ensamblados que se hace referencia para tipos de entidad.</span><span class="sxs-lookup"><span data-stu-id="de3cf-878">This turns off the mechanism that scans all referenced assemblies for entity types.</span></span>

<span data-ttu-id="de3cf-879">Establecer el campo ContextTypeName también evita que un problema funcional donde EntityDataSource en .NET Framework 4.0 produce una ReflectionTypeLoadException cuando un tipo no puede cargar desde un ensamblado mediante reflexión.</span><span class="sxs-lookup"><span data-stu-id="de3cf-879">Setting the ContextTypeName field also prevents a functional problem where the EntityDataSource in .NET 4.0 throws a ReflectionTypeLoadException when it can't load a type from an assembly via reflection.</span></span> <span data-ttu-id="de3cf-880">Este problema se corrigió en .NET 4.5.</span><span class="sxs-lookup"><span data-stu-id="de3cf-880">This issue has been fixed in .NET 4.5.</span></span>

### <a name="75-poco-entities-and-change-tracking-proxies"></a><span data-ttu-id="de3cf-881">7.5 entidades POCO y proxies de seguimiento de cambios</span><span class="sxs-lookup"><span data-stu-id="de3cf-881">7.5       POCO entities and change tracking proxies</span></span>

<span data-ttu-id="de3cf-882">Entity Framework permite usar clases de datos personalizadas junto con el modelo de datos sin realizar ninguna modificación en las clases de datos.</span><span class="sxs-lookup"><span data-stu-id="de3cf-882">Entity Framework enables you to use custom data classes together with your data model without making any modifications to the data classes themselves.</span></span> <span data-ttu-id="de3cf-883">Esto significa que podrá utilizar objetos CLR "antiguos" (POCO), tales como objetos de dominio existentes, con el modelo de datos.</span><span class="sxs-lookup"><span data-stu-id="de3cf-883">This means that you can use "plain-old" CLR objects (POCO), such as existing domain objects, with your data model.</span></span> <span data-ttu-id="de3cf-884">Estas clases de datos POCO (también conocido como objetos que ignoran la persistencia), que se asignan a entidades que se definen en un modelo de datos, admiten la mayoría de la misma consulta, insertarán, actualizarán y eliminación comportamientos como tipos de entidad generados por las herramientas de Entity Data Model.</span><span class="sxs-lookup"><span data-stu-id="de3cf-884">These POCO data classes (also known as persistence-ignorant objects), which are mapped to entities that are defined in a data model, support most of the same query, insert, update, and delete behaviors as entity types that are generated by the Entity Data Model tools.</span></span>

<span data-ttu-id="de3cf-885">Entity Framework también puede crear clases de proxy que deriva de los tipos POCO, que se usan cuando desea habilitar características como la carga diferida y automática seguimiento de cambios en entidades POCO.</span><span class="sxs-lookup"><span data-stu-id="de3cf-885">Entity Framework can also create proxy classes derived from your POCO types, which are used when you want to enable features such as lazy loading and automatic change tracking on POCO entities.</span></span> <span data-ttu-id="de3cf-886">Las clases POCO deben cumplir ciertos requisitos para permitir que Entity Framework utilizar servidores proxy, como se describe aquí: [http://msdn.microsoft.com/library/dd468057.aspx](https://msdn.microsoft.com/library/dd468057.aspx).</span><span class="sxs-lookup"><span data-stu-id="de3cf-886">Your POCO classes must meet certain requirements to allow Entity Framework to use proxies, as described here: [http://msdn.microsoft.com/library/dd468057.aspx](https://msdn.microsoft.com/library/dd468057.aspx).</span></span>

<span data-ttu-id="de3cf-887">Los proxys de seguimiento de oportunidad notificará el Administrador de estado del objeto cada vez que cualquiera de las propiedades de las entidades tiene su valor puede cambiar, por lo que Entity Framework conoce el estado real de las entidades de todo el tiempo.</span><span class="sxs-lookup"><span data-stu-id="de3cf-887">Chance tracking proxies will notify the object state manager each time any of the properties of your entities has its value changed, so Entity Framework knows the actual state of your entities all the time.</span></span> <span data-ttu-id="de3cf-888">Esto se hace agregando eventos de notificación en el cuerpo de los métodos establecedores de las propiedades, y que el Administrador de estado de objeto procesamiento dichos eventos.</span><span class="sxs-lookup"><span data-stu-id="de3cf-888">This is done by adding notification events to the body of the setter methods of your properties, and having the object state manager processing such events.</span></span> <span data-ttu-id="de3cf-889">Tenga en cuenta que la creación de un proxy entidad tendrán normalmente es más costoso que crear una entidad POCO no proxy debido al conjunto de eventos creadas por Entity Framework se ha agregado.</span><span class="sxs-lookup"><span data-stu-id="de3cf-889">Note that creating a proxy entity will typically be more expensive than creating a non-proxy POCO entity due to the added set of events created by Entity Framework.</span></span>

<span data-ttu-id="de3cf-890">Cuando una entidad POCO no tiene un proxy de seguimiento de cambios, se detectan cambios, comparando el contenido de las entidades con una copia de un estado guardado anterior.</span><span class="sxs-lookup"><span data-stu-id="de3cf-890">When a POCO entity does not have a change tracking proxy, changes are found by comparing the contents of your entities against a copy of a previous saved state.</span></span> <span data-ttu-id="de3cf-891">Esta comparación profunda se convertirá en un proceso largo cuando haya muchas entidades en el contexto, o cuando las entidades tienen una gran cantidad de propiedades, aunque ninguno de ellos cambiado desde la última comparación tuvo lugar.</span><span class="sxs-lookup"><span data-stu-id="de3cf-891">This deep comparison will become a lengthy process when you have many entities in your context, or when your entities have a very large amount of properties, even if none of them changed since the last comparison took place.</span></span>

<span data-ttu-id="de3cf-892">En resumen: deberá pagar un impacto al crear el proxy de seguimiento de cambios en el rendimiento, pero el seguimiento de cambios le ayudarán a acelerar el proceso de detección de cambios cuando las entidades tienen muchas propiedades o cuando se tienen muchas entidades en el modelo.</span><span class="sxs-lookup"><span data-stu-id="de3cf-892">In summary: you’ll pay a performance hit when creating the change tracking proxy, but change tracking will help you speed up the change detection process when your entities have many properties or when you have many entities in your model.</span></span> <span data-ttu-id="de3cf-893">Para las entidades con un pequeño número de propiedades donde la cantidad de entidades no aumente demasiado, no puede ser tener objetos proxy de seguimiento de cambios de muchas ventajas.</span><span class="sxs-lookup"><span data-stu-id="de3cf-893">For entities with a small number of properties where the amount of entities doesn’t grow too much, having change tracking proxies may not be of much benefit.</span></span>

## <a name="8-loading-related-entities"></a><span data-ttu-id="de3cf-894">Las entidades relacionadas con la carga de 8</span><span class="sxs-lookup"><span data-stu-id="de3cf-894">8 Loading Related Entities</span></span>

### <a name="81-lazy-loading-vs-eager-loading"></a><span data-ttu-id="de3cf-895">8.1 frente a la carga diferida Carga diligente</span><span class="sxs-lookup"><span data-stu-id="de3cf-895">8.1 Lazy Loading vs. Eager Loading</span></span>

<span data-ttu-id="de3cf-896">Entity Framework ofrece varias formas de cargar las entidades que están relacionados con la entidad de destino.</span><span class="sxs-lookup"><span data-stu-id="de3cf-896">Entity Framework offers several different ways to load the entities that are related to your target entity.</span></span> <span data-ttu-id="de3cf-897">Por ejemplo, al consultar los productos, hay diferentes maneras de que se cargarán los pedidos relacionados en el Administrador de estado de objeto.</span><span class="sxs-lookup"><span data-stu-id="de3cf-897">For example, when you query for Products, there are different ways that the related Orders will be loaded into the Object State Manager.</span></span> <span data-ttu-id="de3cf-898">Desde la perspectiva del rendimiento, la cuestión más importante a tener en cuenta al cargar las entidades relacionadas será si se debe usar la carga diferida o la carga diligente.</span><span class="sxs-lookup"><span data-stu-id="de3cf-898">From a performance standpoint, the biggest question to consider when loading related entities will be whether to use Lazy Loading or Eager Loading.</span></span>

<span data-ttu-id="de3cf-899">Cuando se usa la carga diligente, las entidades relacionadas se cargan junto con su conjunto de entidades de destino.</span><span class="sxs-lookup"><span data-stu-id="de3cf-899">When using Eager Loading, the related entities are loaded along with your target entity set.</span></span> <span data-ttu-id="de3cf-900">Utilice una instrucción de inclusión en la consulta para indicar que relacionados con las entidades que desea incorporar.</span><span class="sxs-lookup"><span data-stu-id="de3cf-900">You use an Include statement in your query to indicate which related entities you want to bring in.</span></span>

<span data-ttu-id="de3cf-901">Cuando se usa la carga diferida, la consulta inicial solo vuelve a colocar en el conjunto de entidades de destino.</span><span class="sxs-lookup"><span data-stu-id="de3cf-901">When using Lazy Loading, your initial query only brings in the target entity set.</span></span> <span data-ttu-id="de3cf-902">Pero siempre que tenga acceso a una propiedad de navegación, se emite otra consulta en el almacén para cargar la entidad relacionada.</span><span class="sxs-lookup"><span data-stu-id="de3cf-902">But whenever you access a navigation property, another query is issued against the store to load the related entity.</span></span>

<span data-ttu-id="de3cf-903">Una vez que se ha cargado una entidad, cualquier otra consulta para la entidad cargará directamente desde el Administrador de estado de objeto, si está utilizando la carga diferida o la carga diligente.</span><span class="sxs-lookup"><span data-stu-id="de3cf-903">Once an entity has been loaded, any further queries for the entity will load it directly from the Object State Manager, whether you are using lazy loading or eager loading.</span></span>

### <a name="82-how-to-choose-between-lazy-loading-and-eager-loading"></a><span data-ttu-id="de3cf-904">8.2 cómo elegir entre la carga diferida y la carga diligente</span><span class="sxs-lookup"><span data-stu-id="de3cf-904">8.2 How to choose between Lazy Loading and Eager Loading</span></span>

<span data-ttu-id="de3cf-905">Lo importante es comprender la diferencia entre la carga diferida y la carga diligente para que pueda tomar la opción correcta para su aplicación.</span><span class="sxs-lookup"><span data-stu-id="de3cf-905">The important thing is that you understand the difference between Lazy Loading and Eager Loading so that you can make the correct choice for your application.</span></span> <span data-ttu-id="de3cf-906">Esto ayudará a evaluar el equilibrio entre varias solicitudes en la base de datos frente a una solicitud única que puede contener una carga grande.</span><span class="sxs-lookup"><span data-stu-id="de3cf-906">This will help you evaluate the tradeoff between multiple requests against the database versus a single request that may contain a large payload.</span></span> <span data-ttu-id="de3cf-907">Puede ser adecuado utilizar la carga diligente en algunas partes de la aplicación y la carga diferida en otras partes.</span><span class="sxs-lookup"><span data-stu-id="de3cf-907">It may be appropriate to use eager loading in some parts of your application and lazy loading in other parts.</span></span>

<span data-ttu-id="de3cf-908">Como ejemplo de lo que sucede en segundo plano, suponga que desea consultar para los clientes que viven en el Reino Unido y el número de pedido.</span><span class="sxs-lookup"><span data-stu-id="de3cf-908">As an example of what's happening under the hood, suppose you want to query for the customers who live in the UK and their order count.</span></span>

<span data-ttu-id="de3cf-909">**Mediante la carga diligente**</span><span class="sxs-lookup"><span data-stu-id="de3cf-909">**Using Eager Loading**</span></span>

``` csharp
using (NorthwindEntities context = new NorthwindEntities())
{
    var ukCustomers = context.Customers.Include(c => c.Orders).Where(c => c.Address.Country == "UK");
    var chosenCustomer = AskUserToPickCustomer(ukCustomers);
    Console.WriteLine("Customer Id: {0} has {1} orders", customer.CustomerID, customer.Orders.Count);
}
```

<span data-ttu-id="de3cf-910">**Uso de la carga diferida**</span><span class="sxs-lookup"><span data-stu-id="de3cf-910">**Using Lazy Loading**</span></span>

``` csharp
using (NorthwindEntities context = new NorthwindEntities())
{
    context.ContextOptions.LazyLoadingEnabled = true;

    //Notice that the Include method call is missing in the query
    var ukCustomers = context.Customers.Where(c => c.Address.Country == "UK");

    var chosenCustomer = AskUserToPickCustomer(ukCustomers);
    Console.WriteLine("Customer Id: {0} has {1} orders", customer.CustomerID, customer.Orders.Count);
}
```

<span data-ttu-id="de3cf-911">Cuando se usa la carga diligente, deberá emitir una única consulta que devuelve todos los clientes y todos los pedidos.</span><span class="sxs-lookup"><span data-stu-id="de3cf-911">When using eager loading, you'll issue a single query that returns all customers and all orders.</span></span> <span data-ttu-id="de3cf-912">El comando de almacén tiene el siguiente aspecto:</span><span class="sxs-lookup"><span data-stu-id="de3cf-912">The store command looks like:</span></span>

``` SQL
SELECT
[Project1].[C1] AS [C1],
[Project1].[CustomerID] AS [CustomerID],
[Project1].[CompanyName] AS [CompanyName],
[Project1].[ContactName] AS [ContactName],
[Project1].[ContactTitle] AS [ContactTitle],
[Project1].[Address] AS [Address],
[Project1].[City] AS [City],
[Project1].[Region] AS [Region],
[Project1].[PostalCode] AS [PostalCode],
[Project1].[Country] AS [Country],
[Project1].[Phone] AS [Phone],
[Project1].[Fax] AS [Fax],
[Project1].[C2] AS [C2],
[Project1].[OrderID] AS [OrderID],
[Project1].[CustomerID1] AS [CustomerID1],
[Project1].[EmployeeID] AS [EmployeeID],
[Project1].[OrderDate] AS [OrderDate],
[Project1].[RequiredDate] AS [RequiredDate],
[Project1].[ShippedDate] AS [ShippedDate],
[Project1].[ShipVia] AS [ShipVia],
[Project1].[Freight] AS [Freight],
[Project1].[ShipName] AS [ShipName],
[Project1].[ShipAddress] AS [ShipAddress],
[Project1].[ShipCity] AS [ShipCity],
[Project1].[ShipRegion] AS [ShipRegion],
[Project1].[ShipPostalCode] AS [ShipPostalCode],
[Project1].[ShipCountry] AS [ShipCountry]
FROM ( SELECT
      [Extent1].[CustomerID] AS [CustomerID],
       [Extent1].[CompanyName] AS [CompanyName],
       [Extent1].[ContactName] AS [ContactName],
       [Extent1].[ContactTitle] AS [ContactTitle],
       [Extent1].[Address] AS [Address],
       [Extent1].[City] AS [City],
       [Extent1].[Region] AS [Region],
       [Extent1].[PostalCode] AS [PostalCode],
       [Extent1].[Country] AS [Country],
       [Extent1].[Phone] AS [Phone],
       [Extent1].[Fax] AS [Fax],
      1 AS [C1],
       [Extent2].[OrderID] AS [OrderID],
       [Extent2].[CustomerID] AS [CustomerID1],
       [Extent2].[EmployeeID] AS [EmployeeID],
       [Extent2].[OrderDate] AS [OrderDate],
       [Extent2].[RequiredDate] AS [RequiredDate],
       [Extent2].[ShippedDate] AS [ShippedDate],
       [Extent2].[ShipVia] AS [ShipVia],
       [Extent2].[Freight] AS [Freight],
       [Extent2].[ShipName] AS [ShipName],
       [Extent2].[ShipAddress] AS [ShipAddress],
       [Extent2].[ShipCity] AS [ShipCity],
       [Extent2].[ShipRegion] AS [ShipRegion],
       [Extent2].[ShipPostalCode] AS [ShipPostalCode],
       [Extent2].[ShipCountry] AS [ShipCountry],
      CASE WHEN ([Extent2].[OrderID] IS NULL) THEN CAST(NULL AS int) ELSE 1 END AS [C2]
      FROM  [dbo].[Customers] AS [Extent1]
      LEFT OUTER JOIN [dbo].[Orders] AS [Extent2] ON [Extent1].[CustomerID] = [Extent2].[CustomerID]
      WHERE N'UK' = [Extent1].[Country]
)  AS [Project1]
ORDER BY [Project1].[CustomerID] ASC, [Project1].[C2] ASC
```

<span data-ttu-id="de3cf-913">Cuando se usa la carga diferida, deberá emitir la siguiente consulta inicialmente:</span><span class="sxs-lookup"><span data-stu-id="de3cf-913">When using lazy loading, you'll issue the following query initially:</span></span>

``` SQL
SELECT
[Extent1].[CustomerID] AS [CustomerID],
[Extent1].[CompanyName] AS [CompanyName],
[Extent1].[ContactName] AS [ContactName],
[Extent1].[ContactTitle] AS [ContactTitle],
[Extent1].[Address] AS [Address],
[Extent1].[City] AS [City],
[Extent1].[Region] AS [Region],
[Extent1].[PostalCode] AS [PostalCode],
[Extent1].[Country] AS [Country],
[Extent1].[Phone] AS [Phone],
[Extent1].[Fax] AS [Fax]
FROM [dbo].[Customers] AS [Extent1]
WHERE N'UK' = [Extent1].[Country]
```

<span data-ttu-id="de3cf-914">Y cada vez que utilice la propiedad de navegación de pedidos de un cliente se emite otra consulta similar al siguiente en el almacén:</span><span class="sxs-lookup"><span data-stu-id="de3cf-914">And each time you access the Orders navigation property of a customer another query like the following is issued against the store:</span></span>

``` SQL
exec sp_executesql N'SELECT
[Extent1].[OrderID] AS [OrderID],
[Extent1].[CustomerID] AS [CustomerID],
[Extent1].[EmployeeID] AS [EmployeeID],
[Extent1].[OrderDate] AS [OrderDate],
[Extent1].[RequiredDate] AS [RequiredDate],
[Extent1].[ShippedDate] AS [ShippedDate],
[Extent1].[ShipVia] AS [ShipVia],
[Extent1].[Freight] AS [Freight],
[Extent1].[ShipName] AS [ShipName],
[Extent1].[ShipAddress] AS [ShipAddress],
[Extent1].[ShipCity] AS [ShipCity],
[Extent1].[ShipRegion] AS [ShipRegion],
[Extent1].[ShipPostalCode] AS [ShipPostalCode],
[Extent1].[ShipCountry] AS [ShipCountry]
FROM [dbo].[Orders] AS [Extent1]
WHERE [Extent1].[CustomerID] = @EntityKeyValue1',N'@EntityKeyValue1 nchar(5)',@EntityKeyValue1=N'AROUT'
```

<span data-ttu-id="de3cf-915">Para obtener más información, consulte el [cargar objetos relacionados](https://msdn.microsoft.com/library/bb896272.aspx).</span><span class="sxs-lookup"><span data-stu-id="de3cf-915">For more information, see the [Loading Related Objects](https://msdn.microsoft.com/library/bb896272.aspx).</span></span>

#### <a name="821-lazy-loading-versus-eager-loading-cheat-sheet"></a><span data-ttu-id="de3cf-916">8.2.1 la carga diferida frente a la hoja de referencia de la carga diligente</span><span class="sxs-lookup"><span data-stu-id="de3cf-916">8.2.1 Lazy Loading versus Eager Loading cheat sheet</span></span>

<span data-ttu-id="de3cf-917">No hay nada como una única a elegir la carga diligente frente a la carga diferida.</span><span class="sxs-lookup"><span data-stu-id="de3cf-917">There’s no such thing as a one-size-fits-all to choosing eager loading versus lazy loading.</span></span> <span data-ttu-id="de3cf-918">Pruebe primero comprender las diferencias entre ambas estrategias de manera que pueda hacer una decisión informada bien; Además, tenga en cuenta si el código se ajusta a cualquiera de los siguientes escenarios:</span><span class="sxs-lookup"><span data-stu-id="de3cf-918">Try first to understand the differences between both strategies so you can do a well informed decision; also, consider if your code fits to any of the following scenarios:</span></span>

| <span data-ttu-id="de3cf-919">Escenario</span><span class="sxs-lookup"><span data-stu-id="de3cf-919">Scenario</span></span>                                                                    | <span data-ttu-id="de3cf-920">Nuestra sugerencia</span><span class="sxs-lookup"><span data-stu-id="de3cf-920">Our Suggestion</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
|:----------------------------------------------------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="de3cf-921">¿Necesita tener acceso a muchas de las propiedades de navegación de las entidades recuperadas?</span><span class="sxs-lookup"><span data-stu-id="de3cf-921">Do you need to access many navigation properties from the fetched entities?</span></span> | <span data-ttu-id="de3cf-922">**No** -probablemente hará ambas opciones.</span><span class="sxs-lookup"><span data-stu-id="de3cf-922">**No** - Both options will probably do.</span></span> <span data-ttu-id="de3cf-923">Sin embargo, si la carga que aporta la consulta no es demasiado grande, que puede experimentar las ventajas de rendimiento mediante el uso de la carga diligente como requerirá menos recorridos de ida y para materializar los objetos de red.</span><span class="sxs-lookup"><span data-stu-id="de3cf-923">However, if the payload your query is bringing is not too big, you may experience performance benefits by using Eager loading as it’ll require less network round trips to materialize your objects.</span></span> <br/> <br/> <span data-ttu-id="de3cf-924">**Sí** -si necesita tener acceso a muchas de las propiedades de navegación de las entidades, haría que utilizando varias incluir instrucciones en la consulta con la carga diligente.</span><span class="sxs-lookup"><span data-stu-id="de3cf-924">**Yes** -  If you need to access many navigation properties from the entities, you’d do that by using multiple include statements in your query with Eager loading.</span></span> <span data-ttu-id="de3cf-925">Las entidades más incluye, mayor es la carga de la consulta va a devolver.</span><span class="sxs-lookup"><span data-stu-id="de3cf-925">The more entities you include, the bigger the payload your query will return.</span></span> <span data-ttu-id="de3cf-926">Una vez que se incluyen tres o más entidades en la consulta, considere la posibilidad de Lazy cargando.</span><span class="sxs-lookup"><span data-stu-id="de3cf-926">Once you include three or more entities into your query, consider switching to Lazy loading.</span></span> |
| <span data-ttu-id="de3cf-927">¿Sabe exactamente qué datos se necesitará en tiempo de ejecución?</span><span class="sxs-lookup"><span data-stu-id="de3cf-927">Do you know exactly what data will be needed at run time?</span></span>                   | <span data-ttu-id="de3cf-928">**No** -carga diferida será mejor para usted.</span><span class="sxs-lookup"><span data-stu-id="de3cf-928">**No** - Lazy loading will be better for you.</span></span> <span data-ttu-id="de3cf-929">En caso contrario, puede acabar consultar los datos que no necesitará.</span><span class="sxs-lookup"><span data-stu-id="de3cf-929">Otherwise, you may end up querying for data that you will not need.</span></span> <br/> <br/> <span data-ttu-id="de3cf-930">**Sí** : diligente, la carga es probablemente la mejor opción; le ayudarán a conjuntos completos de carga con mayor rapidez.</span><span class="sxs-lookup"><span data-stu-id="de3cf-930">**Yes** - Eager loading is probably your best bet; it will help loading entire sets faster.</span></span> <span data-ttu-id="de3cf-931">Si la consulta requiere la obtención de una gran cantidad de datos, y esto se convierte en demasiado lento, vuelva a intentar Lazy cargar en su lugar.</span><span class="sxs-lookup"><span data-stu-id="de3cf-931">If your query requires fetching a very large amount of data, and this becomes too slow, then try Lazy loading instead.</span></span>                                                                                                                                                                                                                                                       |
| <span data-ttu-id="de3cf-932">¿Se está ejecutando el código lejos de la base de datos?</span><span class="sxs-lookup"><span data-stu-id="de3cf-932">Is your code executing far from your database?</span></span> <span data-ttu-id="de3cf-933">(mayor latencia de red)</span><span class="sxs-lookup"><span data-stu-id="de3cf-933">(increased network latency)</span></span>  | <span data-ttu-id="de3cf-934">**No** : cuando la latencia de red no es un problema, utilizando la carga diferida puede simplificar el código.</span><span class="sxs-lookup"><span data-stu-id="de3cf-934">**No** - When the network latency is not an issue, using Lazy loading may simplify your code.</span></span> <span data-ttu-id="de3cf-935">Recuerde que puede cambiar la topología de la aplicación, por lo que no toman la proximidad de la base de datos por sentado.</span><span class="sxs-lookup"><span data-stu-id="de3cf-935">Remember that the topology of your application may change, so don’t take database proximity for granted.</span></span> <br/> <br/> <span data-ttu-id="de3cf-936">**Sí** : cuando la red es un problema, solo puede decidir lo que se adapta mejor para su escenario.</span><span class="sxs-lookup"><span data-stu-id="de3cf-936">**Yes** - When the network is a problem, only you can decide what fits better for your scenario.</span></span> <span data-ttu-id="de3cf-937">Normalmente la carga diligente será mejor porque requiere menos ida y vuelta.</span><span class="sxs-lookup"><span data-stu-id="de3cf-937">Typically Eager loading will be better because it requires fewer round trips.</span></span>                                                                                                                                                                                                      |


#### <a name="822-performance-concerns-with-multiple-includes"></a><span data-ttu-id="de3cf-938">8.2.2 problemas de rendimiento de with incluye varios</span><span class="sxs-lookup"><span data-stu-id="de3cf-938">8.2.2       Performance concerns with multiple Includes</span></span>

<span data-ttu-id="de3cf-939">Cuando recibimos preguntas de rendimiento que implican problemas de tiempo de respuesta de servidor, el origen del problema es con frecuencia consultas con varias instrucciones de inclusión.</span><span class="sxs-lookup"><span data-stu-id="de3cf-939">When we hear performance questions that involve server response time problems, the source of the issue is frequently queries with multiple Include statements.</span></span> <span data-ttu-id="de3cf-940">Aunque es eficaz incluidas entidades relacionadas en una consulta, es importante entender lo que sucede en segundo plano.</span><span class="sxs-lookup"><span data-stu-id="de3cf-940">While including related entities in a query is powerful, it's important to understand what's happening under the covers.</span></span>

<span data-ttu-id="de3cf-941">Tarda un tiempo relativamente largo para una consulta con varias instrucciones Include en él para ir a través de nuestro compilador plan interno para generar el comando de almacén.</span><span class="sxs-lookup"><span data-stu-id="de3cf-941">It takes a relatively long time for a query with multiple Include statements in it to go through our internal plan compiler to produce the store command.</span></span> <span data-ttu-id="de3cf-942">La mayoría de este tiempo se dedica a tratar de optimizar la consulta resultante.</span><span class="sxs-lookup"><span data-stu-id="de3cf-942">The majority of this time is spent trying to optimize the resulting query.</span></span> <span data-ttu-id="de3cf-943">El comando generado contendrá una Outer Join o Union para incluir cada, dependiendo de su asignación.</span><span class="sxs-lookup"><span data-stu-id="de3cf-943">The generated store command will contain an Outer Join or Union for each Include, depending on your mapping.</span></span> <span data-ttu-id="de3cf-944">Consultas similares a esto llevará de gráficos conectados de gran tamaño desde la base de datos en una única carga, que se acerbate los problemas de ancho de banda, especialmente cuando hay una gran cantidad de redundancia en la carga (por ejemplo, cuando se utilizan varios niveles de inclusión para atravesar asociaciones en la dirección de uno a varios).</span><span class="sxs-lookup"><span data-stu-id="de3cf-944">Queries like this will bring in large connected graphs from your database in a single payload, which will acerbate any bandwidth issues, especially when there is a lot of redundancy in the payload (for example, when multiple levels of Include are used to traverse associations in the one-to-many direction).</span></span>

<span data-ttu-id="de3cf-945">Puede buscar los casos donde las consultas devuelven excesivamente grandes cargas mediante el acceso a la TSQL subyacente para la consulta mediante ToTraceString y ejecutar el comando de almacén de SQL Server Management Studio para ver el tamaño de carga.</span><span class="sxs-lookup"><span data-stu-id="de3cf-945">You can check for cases where your queries are returning excessively large payloads by accessing the underlying TSQL for the query by using ToTraceString and executing the store command in SQL Server Management Studio to see the payload size.</span></span> <span data-ttu-id="de3cf-946">En tales casos que puede intentar reducir el número de instrucciones Include en la consulta simplemente poner en los datos que necesita.</span><span class="sxs-lookup"><span data-stu-id="de3cf-946">In such cases you can try to reduce the number of Include statements in your query to just bring in the data you need.</span></span> <span data-ttu-id="de3cf-947">O bien, es posible que pueda dividir la consulta en una secuencia más pequeña de subconsultas, por ejemplo:</span><span class="sxs-lookup"><span data-stu-id="de3cf-947">Or you may be able to break your query into a smaller sequence of subqueries, for example:</span></span>

<span data-ttu-id="de3cf-948">**Antes de interrumpir la consulta:**</span><span class="sxs-lookup"><span data-stu-id="de3cf-948">**Before breaking the query:**</span></span>

``` csharp
using (NorthwindEntities context = new NorthwindEntities())
{
    var customers = from c in context.Customers.Include(c => c.Orders)
                    where c.LastName.StartsWith(lastNameParameter)
                    select c;

    foreach (Customer customer in customers)
    {
        ...
    }
}
```

<span data-ttu-id="de3cf-949">**Después de interrumpir la consulta:**</span><span class="sxs-lookup"><span data-stu-id="de3cf-949">**After breaking the query:**</span></span>

``` csharp
using (NorthwindEntities context = new NorthwindEntities())
{
    var orders = from o in context.Orders
                 where o.Customer.LastName.StartsWith(lastNameParameter)
                 select o;

    orders.Load();

    var customers = from c in context.Customers
                    where c.LastName.StartsWith(lastNameParameter)
                    select c;

    foreach (Customer customer in customers)
    {
        ...
    }
}
```

<span data-ttu-id="de3cf-950">Esto funcionará sólo en las consultas de seguimiento, como vamos a hacer que el uso de la capacidad que tiene el contexto para realizar la corrección de asociación y la resolución de identidad automáticamente.</span><span class="sxs-lookup"><span data-stu-id="de3cf-950">This will work only on tracked queries, as we are making use of the ability the context has to perform identity resolution and association fixup automatically.</span></span>

<span data-ttu-id="de3cf-951">Al igual que con la carga diferida, el equilibrio será más consultas para las cargas más pequeñas.</span><span class="sxs-lookup"><span data-stu-id="de3cf-951">As with lazy loading, the tradeoff will be more queries for smaller payloads.</span></span> <span data-ttu-id="de3cf-952">También puede usar las proyecciones de las propiedades individuales para seleccionar explícitamente sólo los datos que necesita de cada entidad, pero, no se carga entidades en este caso, y no se admitirán actualizaciones.</span><span class="sxs-lookup"><span data-stu-id="de3cf-952">You can also use projections of individual properties to explicitly select only the data you need from each entity, but you will not be loading entities in this case, and updates will not be supported.</span></span>

#### <a name="823-workaround-to-get-lazy-loading-of-properties"></a><span data-ttu-id="de3cf-953">8.2.3 solución alternativa para obtener la carga diferida de propiedades</span><span class="sxs-lookup"><span data-stu-id="de3cf-953">8.2.3 Workaround to get lazy loading of properties</span></span>

<span data-ttu-id="de3cf-954">Entity Framework actualmente no admite la carga diferida de propiedades escalares o complejas.</span><span class="sxs-lookup"><span data-stu-id="de3cf-954">Entity Framework currently doesn’t support lazy loading of scalar or complex properties.</span></span> <span data-ttu-id="de3cf-955">Sin embargo, en casos donde haya una tabla que incluye un objeto grande, como un BLOB, puede usar la división de tablas para separar las propiedades de gran tamaño en una entidad independiente.</span><span class="sxs-lookup"><span data-stu-id="de3cf-955">However, in cases where you have a table that includes a large object such as a BLOB, you can use table splitting to separate the large properties into a separate entity.</span></span> <span data-ttu-id="de3cf-956">Por ejemplo, suponga que tiene una tabla Product que incluya una columna de la foto varbinary.</span><span class="sxs-lookup"><span data-stu-id="de3cf-956">For example, suppose you have a Product table that includes a varbinary photo column.</span></span> <span data-ttu-id="de3cf-957">Si con frecuencia no es necesario tener acceso a esta propiedad en las consultas, puede usar para mostrar solo las partes de la entidad que normalmente necesita la división de tabla.</span><span class="sxs-lookup"><span data-stu-id="de3cf-957">If you don't frequently need to access this property in your queries, you can use table splitting to bring in only the parts of the entity that you normally need.</span></span> <span data-ttu-id="de3cf-958">La entidad que representa la fotografía del producto sólo se cargarán cuando necesite explícitamente.</span><span class="sxs-lookup"><span data-stu-id="de3cf-958">The entity representing the product photo will only be loaded when you explicitly need it.</span></span>

<span data-ttu-id="de3cf-959">Un buen recurso que se muestra cómo habilitar la división de tablas es "Tabla dividir en Entity Framework" entrada de blog de Gil Fink: \<http://blogs.microsoft.co.il/blogs/gilf/archive/2009/10/13/table-splitting-in-entity-framework.aspx>.</span><span class="sxs-lookup"><span data-stu-id="de3cf-959">A good resource that shows how to enable table splitting is Gil Fink's "Table Splitting in Entity Framework" blog post: \<http://blogs.microsoft.co.il/blogs/gilf/archive/2009/10/13/table-splitting-in-entity-framework.aspx>.</span></span>

## <a name="9-other-considerations"></a><span data-ttu-id="de3cf-960">9 otras consideraciones</span><span class="sxs-lookup"><span data-stu-id="de3cf-960">9 Other considerations</span></span>

### <a name="91-server-garbage-collection"></a><span data-ttu-id="de3cf-961">9.1 recolección de elementos no utilizados de servidor de</span><span class="sxs-lookup"><span data-stu-id="de3cf-961">9.1      Server Garbage Collection</span></span>

<span data-ttu-id="de3cf-962">Algunos usuarios podrían experimentar contención de recursos que limita el paralelismo que se espera cuando el recolector de elementos no utilizados no está configurado correctamente.</span><span class="sxs-lookup"><span data-stu-id="de3cf-962">Some users might experience resource contention that limits the parallelism they are expecting when the Garbage Collector is not properly configured.</span></span> <span data-ttu-id="de3cf-963">Cada vez que EF se usa en un escenario con varios subprocesos, o en cualquier aplicación que se parece a un sistema de servidor, asegúrese de habilitar la recolección de elementos no utilizados de servidor.</span><span class="sxs-lookup"><span data-stu-id="de3cf-963">Whenever EF is used in a multithreaded scenario, or in any application that resembles a server-side system, make sure to enable Server Garbage Collection.</span></span> <span data-ttu-id="de3cf-964">Esto se realiza a través de una configuración simple en el archivo de configuración de aplicación:</span><span class="sxs-lookup"><span data-stu-id="de3cf-964">This is done via a simple setting in your application config file:</span></span>

``` xml
<?xmlversion="1.0" encoding="utf-8" ?>
<configuration>
        <runtime>
               <gcServer enabled="true" />
        </runtime>
</configuration>
```

<span data-ttu-id="de3cf-965">Esto debería reducir la contención de subprocesos y aumentar su rendimiento en hasta un 30% en los escenarios de CPU saturado.</span><span class="sxs-lookup"><span data-stu-id="de3cf-965">This should decrease your thread contention and increase your throughput by up to 30% in CPU saturated scenarios.</span></span> <span data-ttu-id="de3cf-966">En términos generales, siempre debe probar cómo comporta la aplicación mediante la colección de elementos no utilizados clásico (que se ajusta mejor para escenarios de lado cliente y la interfaz de usuario), así como la colección de elementos no utilizados de servidor.</span><span class="sxs-lookup"><span data-stu-id="de3cf-966">In general terms, you should always test how your application behaves using the classic Garbage Collection (which is better tuned for UI and client side scenarios) as well as the Server Garbage Collection.</span></span>

### <a name="92-autodetectchanges"></a><span data-ttu-id="de3cf-967">9.2 AutoDetectChanges</span><span class="sxs-lookup"><span data-stu-id="de3cf-967">9.2      AutoDetectChanges</span></span>

<span data-ttu-id="de3cf-968">Como se mencionó anteriormente, Entity Framework podría mostrar problemas de rendimiento cuando la caché de objetos tiene muchas entidades.</span><span class="sxs-lookup"><span data-stu-id="de3cf-968">As mentioned earlier, Entity Framework might show performance issues when the object cache has many entities.</span></span> <span data-ttu-id="de3cf-969">Ciertas operaciones, como agregar, quitar, buscar, entrada y SaveChanges, desencadenan llamadas a DetectChanges que puede consumir una gran cantidad de CPU en función de tamaño se ha vuelto la caché de objetos.</span><span class="sxs-lookup"><span data-stu-id="de3cf-969">Certain operations, such as Add, Remove, Find, Entry and SaveChanges, trigger calls to DetectChanges which might consume a large amount of CPU based on how large the object cache has become.</span></span> <span data-ttu-id="de3cf-970">El motivo es que la caché de objetos e intente de administrador de estado de objeto para permanecer como sincronizan como sea posible en cada operación realizada en un contexto para que se garantiza que los datos producidos sea correcta en una amplia gama de escenarios.</span><span class="sxs-lookup"><span data-stu-id="de3cf-970">The reason for this is that the object cache and the object state manager try to stay as synchronized as possible on each operation performed to a context so that the produced data is guaranteed to be correct under a wide array of scenarios.</span></span>

<span data-ttu-id="de3cf-971">Suele ser una buena idea dejar la detección de cambios automática de Entity Framework habilitada para toda la vida de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="de3cf-971">It is generally a good practice to leave Entity Framework’s automatic change detection enabled for the entire life of your application.</span></span> <span data-ttu-id="de3cf-972">Si su escenario es que se ve afectado negativamente por el uso elevado de CPU y los perfiles indican que el culpable es la llamada a DetectChanges, considere la posibilidad de desactivar temporalmente AutoDetectChanges en la parte del código confidencial:</span><span class="sxs-lookup"><span data-stu-id="de3cf-972">If your scenario is being negatively affected by high CPU usage and your profiles indicate that the culprit is the call to DetectChanges, consider temporarily turning off AutoDetectChanges in the sensitive portion of your code:</span></span>

``` csharp
try
{
    context.Configuration.AutoDetectChangesEnabled = false;
    var product = context.Products.Find(productId);
    ...
}
finally
{
    context.Configuration.AutoDetectChangesEnabled = true;
}
```

<span data-ttu-id="de3cf-973">Antes de desactivar AutoDetectChanges, es conveniente entender que esto puede provocar que Entity Framework a perder su habilidad para realizar un seguimiento de cierta información sobre los cambios que están teniendo lugar en las entidades.</span><span class="sxs-lookup"><span data-stu-id="de3cf-973">Before turning off AutoDetectChanges, it’s good to understand that this might cause Entity Framework to lose its ability to track certain information about the changes that are taking place on the entities.</span></span> <span data-ttu-id="de3cf-974">Si se controlan correctamente, esto podría causar incoherencia de datos en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="de3cf-974">If handled incorrectly, this might cause data inconsistency on your application.</span></span> <span data-ttu-id="de3cf-975">Para obtener más información sobre cómo desactivar AutoDetectChanges, lea \<http://blog.oneunicorn.com/2012/03/12/secrets-of-detectchanges-part-3-switching-off-automatic-detectchanges/>.</span><span class="sxs-lookup"><span data-stu-id="de3cf-975">For more information on turning off AutoDetectChanges, read \<http://blog.oneunicorn.com/2012/03/12/secrets-of-detectchanges-part-3-switching-off-automatic-detectchanges/>.</span></span>

### <a name="93-context-per-request"></a><span data-ttu-id="de3cf-976">9.3 contexto por solicitud</span><span class="sxs-lookup"><span data-stu-id="de3cf-976">9.3      Context per request</span></span>

<span data-ttu-id="de3cf-977">Contextos de Entity Framework están diseñadas para usarse como instancias de corta duración para proporcionar un rendimiento óptimo con más experimentan.</span><span class="sxs-lookup"><span data-stu-id="de3cf-977">Entity Framework’s contexts are meant to be used as short-lived instances in order to provide the most optimal performance experience.</span></span> <span data-ttu-id="de3cf-978">Contextos se esperan que sea más corta duración y se descartan y por lo tanto se han implementado para que sea muy ligero y reutilize metadatos siempre que sea posible.</span><span class="sxs-lookup"><span data-stu-id="de3cf-978">Contexts are expected to be short lived and discarded, and as such have been implemented to be very lightweight and reutilize metadata whenever possible.</span></span> <span data-ttu-id="de3cf-979">En escenarios de web es importante tener esto en mente y no tiene un contexto para la mayor que la duración de una única solicitud.</span><span class="sxs-lookup"><span data-stu-id="de3cf-979">In web scenarios it’s important to keep this in mind and not have a context for more than the duration of a single request.</span></span> <span data-ttu-id="de3cf-980">De forma similar, en escenarios que no son web, contexto debe descartarse según su comprensión de los distintos niveles de almacenamiento en caché en Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="de3cf-980">Similarly, in non-web scenarios, context should be discarded based on your understanding of the different levels of caching in the Entity Framework.</span></span> <span data-ttu-id="de3cf-981">Por lo general, se debería evitar tener una instancia de contexto durante la vida de la aplicación, así como contextos de subprocesos y contextos estáticos.</span><span class="sxs-lookup"><span data-stu-id="de3cf-981">Generally speaking, one should avoid having a context instance throughout the life of the application, as well as contexts per thread and static contexts.</span></span>

### <a name="94-database-null-semantics"></a><span data-ttu-id="de3cf-982">9.4 semántica de null de base de datos</span><span class="sxs-lookup"><span data-stu-id="de3cf-982">9.4      Database null semantics</span></span>

<span data-ttu-id="de3cf-983">Entity Framework de forma predeterminada generará código SQL que tiene C\# null semántica de comparación.</span><span class="sxs-lookup"><span data-stu-id="de3cf-983">Entity Framework by default will generate SQL code that has C\# null comparison semantics.</span></span> <span data-ttu-id="de3cf-984">Tenga en cuenta la siguiente consulta de ejemplo:</span><span class="sxs-lookup"><span data-stu-id="de3cf-984">Consider the following example query:</span></span>

``` csharp
            int? categoryId = 7;
            int? supplierId = 8;
            decimal? unitPrice = 0;
            short? unitsInStock = 100;
            short? unitsOnOrder = 20;
            short? reorderLevel = null;

            var q = from p incontext.Products
                    wherep.Category.CategoryName == "Beverages"
                          || (p.CategoryID == categoryId
                                || p.SupplierID == supplierId
                                || p.UnitPrice == unitPrice
                                || p.UnitsInStock == unitsInStock
                                || p.UnitsOnOrder == unitsOnOrder
                                || p.ReorderLevel == reorderLevel)
                    select p;

            var r = q.ToList();
```

<span data-ttu-id="de3cf-985">En este ejemplo, nos estamos comparando una serie de variables que aceptan valores NULL en las propiedades que aceptan valores NULL en la entidad, como SupplierID y UnitPrice.</span><span class="sxs-lookup"><span data-stu-id="de3cf-985">In this example, we’re comparing a number of nullable variables against nullable properties on the entity, such as SupplierID and UnitPrice.</span></span> <span data-ttu-id="de3cf-986">El código SQL generado para esta consulta le preguntará si el valor del parámetro es el mismo que el valor de columna, o si el parámetro y los valores de columna son nulos.</span><span class="sxs-lookup"><span data-stu-id="de3cf-986">The generated SQL for this query will ask if the parameter value is the same as the column value, or if both the parameter and the column values are null.</span></span> <span data-ttu-id="de3cf-987">Esto ocultará la manera en que el servidor de base de datos controla los valores NULL y le proporcionará una C coherente\# null experiencia a través de proveedores de base de datos diferente.</span><span class="sxs-lookup"><span data-stu-id="de3cf-987">This will hide the way the database server handles nulls and will provide a consistent C\# null experience across different database vendors.</span></span> <span data-ttu-id="de3cf-988">Por otro lado, el código generado es un poco complicado y no se puede realizar bien cuando la cantidad de comparaciones en el lugar en la instrucción de la consulta que crece a un gran número.</span><span class="sxs-lookup"><span data-stu-id="de3cf-988">On the other hand, the generated code is a bit convoluted and may not perform well when the amount of comparisons in the where statement of the query grows to a large number.</span></span>

<span data-ttu-id="de3cf-989">Una manera de tratar esta situación es mediante la semántica de null de base de datos.</span><span class="sxs-lookup"><span data-stu-id="de3cf-989">One way to deal with this situation is by using database null semantics.</span></span> <span data-ttu-id="de3cf-990">Tenga en cuenta que esto podría potencialmente comportarse de manera diferente a la C\# null semántica desde ahora Entity Framework generará código SQL más sencillo que expone la manera en que el motor de base de datos controla los valores null.</span><span class="sxs-lookup"><span data-stu-id="de3cf-990">Note that this might potentially behave differently to the C\# null semantics since now Entity Framework will generate simpler SQL that exposes the way the database engine handles null values.</span></span> <span data-ttu-id="de3cf-991">Semántica de null de base de datos puede ser activado por contexto con una línea de configuración único frente a la configuración de contexto:</span><span class="sxs-lookup"><span data-stu-id="de3cf-991">Database null semantics can be activated per-context with one single configuration line against the context configuration:</span></span>

``` csharp
                context.Configuration.UseDatabaseNullSemantics = true;
```

<span data-ttu-id="de3cf-992">Pequeña a mediana con tamaño de las consultas no mostrarán una mejora del rendimiento perceptible cuando se usa la semántica de null de base de datos, pero la diferencia será más evidente en las consultas con un gran número de posibles comparaciones de null.</span><span class="sxs-lookup"><span data-stu-id="de3cf-992">Small to medium sized queries will not display a perceptible performance improvement when using database null semantics, but the difference will become more noticeable on queries with a large number of potential null comparisons.</span></span>

<span data-ttu-id="de3cf-993">En la consulta del ejemplo anterior, la diferencia de rendimiento era menor que 2% en un microbenchmark que se ejecuta en un entorno controlado.</span><span class="sxs-lookup"><span data-stu-id="de3cf-993">In the example query above, the performance difference was less than 2% in a microbenchmark running in a controlled environment.</span></span>

### <a name="95-async"></a><span data-ttu-id="de3cf-994">9.5 Async</span><span class="sxs-lookup"><span data-stu-id="de3cf-994">9.5      Async</span></span>

<span data-ttu-id="de3cf-995">Entity Framework 6 introdujo compatibilidad con las operaciones asincrónicas cuando se ejecuta en .NET 4.5 o versiones posteriores.</span><span class="sxs-lookup"><span data-stu-id="de3cf-995">Entity Framework 6 introduced support of async operations when running on .NET 4.5 or later.</span></span> <span data-ttu-id="de3cf-996">En su mayor parte, las aplicaciones que tienen E/S relacionados con la contención se beneficiarán el máximo partido de la consulta asincrónica de uso y las operaciones de guardado.</span><span class="sxs-lookup"><span data-stu-id="de3cf-996">For the most part, applications that have IO related contention will benefit the most from using asynchronous query and save operations.</span></span> <span data-ttu-id="de3cf-997">Si la aplicación no sufren la contención de E/S, el uso de async se, en el mejor de los casos, se ejecutan sincrónicamente y devuelven el resultado en la misma cantidad de tiempo que una llamada sincrónica, o en el peor de los casos, simplemente aplazar la ejecución de una tarea asincrónica y agregue a tim adicional e a la finalización de su escenario.</span><span class="sxs-lookup"><span data-stu-id="de3cf-997">If your application does not suffer from IO contention, the use of async will, in the best cases, run synchronously and return the result in the same amount of time as a synchronous call, or in the worst case, simply defer execution to an asynchronous task and add extra time to the completion of your scenario.</span></span>

<span data-ttu-id="de3cf-998">Para obtener información sobre el trabajo de programación asincrónico que le ayudarán a decidir si async mejorará el rendimiento de la aplicación visita [http://msdn.microsoft.com/library/hh191443.aspx](https://msdn.microsoft.com/library/hh191443.aspx).</span><span class="sxs-lookup"><span data-stu-id="de3cf-998">For information on how asynchronous programming work that will help you deciding if async will improve the performance of your application visit [http://msdn.microsoft.com/library/hh191443.aspx](https://msdn.microsoft.com/library/hh191443.aspx).</span></span> <span data-ttu-id="de3cf-999">Para obtener más información sobre el uso de operaciones asincrónicas en Entity Framework, vea [consulta asincrónica y guardar](~/ef6/fundamentals/async.md
).</span><span class="sxs-lookup"><span data-stu-id="de3cf-999">For more information on the use of async operations on Entity Framework, see [Async Query and Save](~/ef6/fundamentals/async.md
).</span></span>

### <a name="96-ngen"></a><span data-ttu-id="de3cf-1000">9.6 NGEN</span><span class="sxs-lookup"><span data-stu-id="de3cf-1000">9.6      NGEN</span></span>

<span data-ttu-id="de3cf-1001">Entity Framework 6 no se incluye en la instalación predeterminada de .NET framework.</span><span class="sxs-lookup"><span data-stu-id="de3cf-1001">Entity Framework 6 does not come in the default installation of .NET framework.</span></span> <span data-ttu-id="de3cf-1002">Por lo tanto, los ensamblados de Entity Framework no están que Ngen de forma predeterminada, lo que significa que todo el código de Entity Framework está sujeto a los mismos costes JIT'ing como cualquier otro ensamblado MSIL.</span><span class="sxs-lookup"><span data-stu-id="de3cf-1002">As such, the Entity Framework assemblies are not NGEN’d by default which means that all the Entity Framework code is subject to the same JIT’ing costs as any other MSIL assembly.</span></span> <span data-ttu-id="de3cf-1003">Esto podría degradar la experiencia de F5 al desarrollar y también el inicio en frío de la aplicación en los entornos de producción.</span><span class="sxs-lookup"><span data-stu-id="de3cf-1003">This might degrade the F5 experience while developing and also the cold startup of your application in the production environments.</span></span> <span data-ttu-id="de3cf-1004">Con el fin de reducir los costos de CPU y memoria de JIT'ing es aconsejable NGEN Entity Framework imágenes según corresponda.</span><span class="sxs-lookup"><span data-stu-id="de3cf-1004">In order to reduce the CPU and memory costs of JIT’ing it is advisable to NGEN the Entity Framework images as appropriate.</span></span> <span data-ttu-id="de3cf-1005">Para obtener más información sobre cómo mejorar el rendimiento de inicio de Entity Framework 6 con NGEN, consulte [mejorar el rendimiento de inicio con NGen](~/ef6/fundamentals/performance/ngen.md).</span><span class="sxs-lookup"><span data-stu-id="de3cf-1005">For more information on how to improve the startup performance of Entity Framework 6 with NGEN, see [Improving Startup Performance with NGen](~/ef6/fundamentals/performance/ngen.md).</span></span>

### <a name="97-code-first-versus-edmx"></a><span data-ttu-id="de3cf-1006">9.7 code First y EDMX</span><span class="sxs-lookup"><span data-stu-id="de3cf-1006">9.7      Code First versus EDMX</span></span>

<span data-ttu-id="de3cf-1007">Motivos de Entity Framework acerca del problema de falta de coincidencia de impedancia entre la programación orientada a objetos y bases de datos relacionales al tener una representación en memoria del modelo conceptual (objetos), el esquema de almacenamiento (base de datos) y una asignación entre la dos.</span><span class="sxs-lookup"><span data-stu-id="de3cf-1007">Entity Framework reasons about the impedance mismatch problem between object oriented programming and relational databases by having an in-memory representation of the conceptual model (the objects), the storage schema (the database) and a mapping between the two.</span></span> <span data-ttu-id="de3cf-1008">Estos metadatos se denominan un Entity Data Model o EDM para abreviar.</span><span class="sxs-lookup"><span data-stu-id="de3cf-1008">This metadata is called an Entity Data Model, or EDM for short.</span></span> <span data-ttu-id="de3cf-1009">De este tipo de EDM, Entity Framework se derivan de las vistas a los datos de ida y vuelta de los objetos en memoria a la base de datos y realizar una copia.</span><span class="sxs-lookup"><span data-stu-id="de3cf-1009">From this EDM, Entity Framework will derive the views to roundtrip data from the objects in memory to the database and back.</span></span>

<span data-ttu-id="de3cf-1010">Cuando Entity Framework se usa con un archivo EDMX formalmente que especifica el modelo conceptual, el esquema de almacenamiento y la asignación y, después, la fase de carga del modelo solo tiene que validar que el EDM es correcto (por ejemplo, asegúrese de que no faltan asignaciones), a continuación, generar las vistas, validar las vistas y estos metadatos para su uso.</span><span class="sxs-lookup"><span data-stu-id="de3cf-1010">When Entity Framework is used with an EDMX file that formally specifies the conceptual model, the storage schema, and the mapping, then the model loading stage only has to validate that the EDM is correct (for example, make sure that no mappings are missing), then generate the views, then validate the views and have this metadata ready for use.</span></span> <span data-ttu-id="de3cf-1011">Solo puede, a continuación, una consulta se ejecuta o se puede guardar nuevos datos al almacén de datos.</span><span class="sxs-lookup"><span data-stu-id="de3cf-1011">Only then can a query be executed or new data be saved to the data store.</span></span>

<span data-ttu-id="de3cf-1012">En esencia, el enfoque Code First es un generador de Entity Data Model sofisticado.</span><span class="sxs-lookup"><span data-stu-id="de3cf-1012">The Code First approach is, at its heart, a sophisticated Entity Data Model generator.</span></span> <span data-ttu-id="de3cf-1013">Entity Framework debe generar un EDM desde el código proporcionado; lo hace analizar las clases implicadas en el modelo, aplicar las convenciones y configuración del modelo mediante la API Fluent.</span><span class="sxs-lookup"><span data-stu-id="de3cf-1013">The Entity Framework has to produce an EDM from the provided code; it does so by analyzing the classes involved in the model, applying conventions and configuring the model via the Fluent API.</span></span> <span data-ttu-id="de3cf-1014">Una vez compilado el EDM, Entity Framework básicamente se comporta igual manera que haría tenía un archivo EDMX estado presente en el proyecto.</span><span class="sxs-lookup"><span data-stu-id="de3cf-1014">After the EDM is built, the Entity Framework essentially behaves the same way as it would had an EDMX file been present in the project.</span></span> <span data-ttu-id="de3cf-1015">Por lo tanto, la creación del modelo de Code First agrega complejidad adicional que se traduce en un tiempo de inicio más lento para Entity Framework cuando se comparan para tener un EDMX.</span><span class="sxs-lookup"><span data-stu-id="de3cf-1015">Thus, building the model from Code First adds extra complexity that translates into a slower startup time for the Entity Framework when compared to having an EDMX.</span></span> <span data-ttu-id="de3cf-1016">El costo depende completamente del tamaño y complejidad del modelo que se está compilando.</span><span class="sxs-lookup"><span data-stu-id="de3cf-1016">The cost is completely dependent on the size and complexity of the model that’s being built.</span></span>

<span data-ttu-id="de3cf-1017">Al elegir la opción Usar EDMX frente a Code First, es importante saber que la flexibilidad introducida por Code First aumenta el costo de generar el modelo por primera vez.</span><span class="sxs-lookup"><span data-stu-id="de3cf-1017">When choosing to use EDMX versus Code First, it’s important to know that the flexibility introduced by Code First increases the cost of building the model for the first time.</span></span> <span data-ttu-id="de3cf-1018">Si la aplicación puede resistir el costo de esta carga por primera vez, a continuación, normalmente Code First será la mejor manera de ir.</span><span class="sxs-lookup"><span data-stu-id="de3cf-1018">If your application can withstand the cost of this first-time load then typically Code First will be the preferred way to go.</span></span>

## <a name="10-investigating-performance"></a><span data-ttu-id="de3cf-1019">Rendimiento de investigación de 10</span><span class="sxs-lookup"><span data-stu-id="de3cf-1019">10 Investigating Performance</span></span>

### <a name="101-using-the-visual-studio-profiler"></a><span data-ttu-id="de3cf-1020">10.1 utilizando al Profiler de Visual Studio</span><span class="sxs-lookup"><span data-stu-id="de3cf-1020">10.1 Using the Visual Studio Profiler</span></span>

<span data-ttu-id="de3cf-1021">Si tiene problemas de rendimiento con Entity Framework, puede usar un generador de perfiles como el integrado en Visual Studio para ver dónde la aplicación dedica el tiempo.</span><span class="sxs-lookup"><span data-stu-id="de3cf-1021">If you are having performance issues with the Entity Framework, you can use a profiler like the one built into Visual Studio to see where your application is spending its time.</span></span> <span data-ttu-id="de3cf-1022">Esta es la herramienta que se usa para generar los gráficos circulares en la entrada de blog "Explorar el rendimiento de ADO.NET Entity Framework - parte 1" ( \<http://blogs.msdn.com/b/adonet/archive/2008/02/04/exploring-the-performance-of-the-ado-net-entity-framework-part-1.aspx>) que muestre en Entity Framework emplea tiempo durante las consultas en frío y calientes.</span><span class="sxs-lookup"><span data-stu-id="de3cf-1022">This is the tool we used to generate the pie charts in the “Exploring the Performance of the ADO.NET Entity Framework - Part 1” blog post ( \<http://blogs.msdn.com/b/adonet/archive/2008/02/04/exploring-the-performance-of-the-ado-net-entity-framework-part-1.aspx>) that show where Entity Framework spends its time during cold and warm queries.</span></span>

<span data-ttu-id="de3cf-1023">La entrada de blog "Generación de perfiles de Entity Framework mediante el Profiler de 2010 Visual Studio" escrita por los datos y modelado de Customer Advisory Team muestra un ejemplo de cómo usa el generador de perfiles para investigar un problema de rendimiento del mundo real.</span><span class="sxs-lookup"><span data-stu-id="de3cf-1023">The "Profiling Entity Framework using the Visual Studio 2010 Profiler" blog post written by the Data and Modeling Customer Advisory Team shows a real-world example of how they used the profiler to investigate a performance problem.</span></span><span data-ttu-id="de3cf-1024">  \<http://blogs.msdn.com/b/dmcat/archive/2010/04/30/profiling-entity-framework-using-the-visual-studio-2010-profiler.aspx>.</span><span class="sxs-lookup"><span data-stu-id="de3cf-1024">  \<http://blogs.msdn.com/b/dmcat/archive/2010/04/30/profiling-entity-framework-using-the-visual-studio-2010-profiler.aspx>.</span></span> <span data-ttu-id="de3cf-1025">Este artículo se escribió para una aplicación de windows.</span><span class="sxs-lookup"><span data-stu-id="de3cf-1025">This post was written for a windows application.</span></span> <span data-ttu-id="de3cf-1026">Si necesita un perfil de una aplicación web de las herramientas de Windows Performance Recorder (WPR) y Windows Performance Analyzer (WPA) funcionen mejor que el trabajo desde Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="de3cf-1026">If you need to profile a web application the Windows Performance Recorder (WPR) and Windows Performance Analyzer (WPA) tools may work better than working from Visual Studio.</span></span> <span data-ttu-id="de3cf-1027">WPR y WPA son parte del Kit de herramientas de rendimiento de Windows que se incluye con el Windows Assessment and Deployment Kit ( [http://www.microsoft.com/download/details.aspx?id=39982 ](https://www.microsoft.com/download/details.aspx?id=39982)).</span><span class="sxs-lookup"><span data-stu-id="de3cf-1027">WPR and WPA are part of the Windows Performance Toolkit which is included with the Windows Assessment and Deployment Kit ( [http://www.microsoft.com/download/details.aspx?id=39982](https://www.microsoft.com/download/details.aspx?id=39982)).</span></span>

### <a name="102-applicationdatabase-profiling"></a><span data-ttu-id="de3cf-1028">10.2 aplicación/base de datos de generación de perfiles</span><span class="sxs-lookup"><span data-stu-id="de3cf-1028">10.2 Application/Database profiling</span></span>

<span data-ttu-id="de3cf-1029">Herramientas como el generador de perfiles integrado en Visual Studio indican dónde dedica tiempo la aplicación.</span><span class="sxs-lookup"><span data-stu-id="de3cf-1029">Tools like the profiler built into Visual Studio tell you where your application is spending time.</span></span><span data-ttu-id="de3cf-1030">  Hay otro tipo de generador de perfiles que realiza el análisis dinámico de la aplicación en ejecución, en producción o preproducción según las necesidades y busca los riesgos comunes y antipatrones de acceso de la base de datos.</span><span class="sxs-lookup"><span data-stu-id="de3cf-1030">  Another type of profiler is available that performs dynamic analysis of your running application, either in production or pre-production depending on needs, and looks for common pitfalls and anti-patterns of database access.</span></span>

<span data-ttu-id="de3cf-1031">Dos generadores de perfiles comercialmente disponibles son el Profiler de Entity Framework ( \<http://efprof.com>) y ORMProfiler ( \<http://ormprofiler.com>).</span><span class="sxs-lookup"><span data-stu-id="de3cf-1031">Two commercially available profilers are the Entity Framework Profiler ( \<http://efprof.com>) and ORMProfiler ( \<http://ormprofiler.com>).</span></span>

<span data-ttu-id="de3cf-1032">Si la aplicación es una aplicación MVC mediante Code First, puede usar MiniProfiler de StackExchange.</span><span class="sxs-lookup"><span data-stu-id="de3cf-1032">If your application is an MVC application using Code First, you can use StackExchange's MiniProfiler.</span></span> <span data-ttu-id="de3cf-1033">Scott Hanselman describe esta herramienta en su blog en: \<http://www.hanselman.com/blog/NuGetPackageOfTheWeek9ASPNETMiniProfilerFromStackExchangeRocksYourWorld.aspx>.</span><span class="sxs-lookup"><span data-stu-id="de3cf-1033">Scott Hanselman describes this tool in his blog at: \<http://www.hanselman.com/blog/NuGetPackageOfTheWeek9ASPNETMiniProfilerFromStackExchangeRocksYourWorld.aspx>.</span></span>

<span data-ttu-id="de3cf-1034">Para obtener más información sobre la generación de perfiles de actividad de la base de datos de la aplicación, consulte artículo de MSDN Magazine de Julie titulada [actividad de base de datos de generación de perfiles en Entity Framework](https://msdn.microsoft.com/magazine/gg490349.aspx).</span><span class="sxs-lookup"><span data-stu-id="de3cf-1034">For more information on profiling your application's database activity, see Julie Lerman's MSDN Magazine article titled [Profiling Database Activity in the Entity Framework](https://msdn.microsoft.com/magazine/gg490349.aspx).</span></span>

### <a name="103-database-logger"></a><span data-ttu-id="de3cf-1035">10.3 registrador de la base de datos</span><span class="sxs-lookup"><span data-stu-id="de3cf-1035">10.3 Database logger</span></span>

<span data-ttu-id="de3cf-1036">Si usa Entity Framework 6 también considere el uso de la funcionalidad de registro integrados.</span><span class="sxs-lookup"><span data-stu-id="de3cf-1036">If you are using Entity Framework 6 also consider using the built-in logging functionality.</span></span> <span data-ttu-id="de3cf-1037">La propiedad de base de datos del contexto puede indicará que su actividad a través de una configuración simple de una línea de registro:</span><span class="sxs-lookup"><span data-stu-id="de3cf-1037">The Database property of the context can be instructed to log its activity via a simple one-line configuration:</span></span>

``` csharp
    using (var context = newQueryComparison.DbC.NorthwindEntities())
    {
        context.Database.Log = Console.WriteLine;
        var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
        q.ToList();
    }
```

<span data-ttu-id="de3cf-1038">En este ejemplo se registrará la actividad de la base de datos en la consola, pero se puede configurar la propiedad del registro para llamar a cualquier acción&lt;cadena&gt; delegar.</span><span class="sxs-lookup"><span data-stu-id="de3cf-1038">In this example the database activity will be logged to the console, but the Log property can be configured to call any Action&lt;string&gt; delegate.</span></span>

<span data-ttu-id="de3cf-1039">Si desea habilitar el registro de base de datos sin tener que volver a compilar y está utilizando Entity Framework 6.1 o posterior, puede hacerlo mediante la adición de un interceptor en el archivo web.config o app.config de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="de3cf-1039">If you want to enable database logging without recompiling, and you are using Entity Framework 6.1 or later, you can do so by adding an interceptor in the web.config or app.config file of your application.</span></span>

``` xml
  <interceptors>
    <interceptor type="System.Data.Entity.Infrastructure.Interception.DatabaseLogger, EntityFramework">
      <parameters>
        <parameter value="C:\Path\To\My\LogOutput.txt"/>
      </parameters>
    </interceptor>
  </interceptors>
```

<span data-ttu-id="de3cf-1040">Para obtener más información sobre cómo agregar un registro sin volver a compilar vaya a \<http://blog.oneunicorn.com/2014/02/09/ef-6-1-turning-on-logging-without-recompiling/>.</span><span class="sxs-lookup"><span data-stu-id="de3cf-1040">For more information on how to add logging without recompiling go to \<http://blog.oneunicorn.com/2014/02/09/ef-6-1-turning-on-logging-without-recompiling/>.</span></span>

## <a name="11-appendix"></a><span data-ttu-id="de3cf-1041">Apéndice 11</span><span class="sxs-lookup"><span data-stu-id="de3cf-1041">11 Appendix</span></span>

### <a name="111-a-test-environment"></a><span data-ttu-id="de3cf-1042">11.1 entorno de prueba de r de.</span><span class="sxs-lookup"><span data-stu-id="de3cf-1042">11.1 A. Test Environment</span></span>

<span data-ttu-id="de3cf-1043">Este entorno usa una configuración de máquina de 2 con la base de datos en un equipo independiente de la aplicación cliente.</span><span class="sxs-lookup"><span data-stu-id="de3cf-1043">This environment uses a 2-machine setup with the database on a separate machine from the client application.</span></span> <span data-ttu-id="de3cf-1044">Las máquinas están en el mismo bastidor, por lo que la latencia de red es relativamente bajo, pero más realista de una sola máquina del entorno.</span><span class="sxs-lookup"><span data-stu-id="de3cf-1044">Machines are in the same rack, so network latency is relatively low, but more realistic than a single-machine environment.</span></span>

#### <a name="1111-app-server"></a><span data-ttu-id="de3cf-1045">11.1.1 servidor de aplicaciones</span><span class="sxs-lookup"><span data-stu-id="de3cf-1045">11.1.1       App Server</span></span>

##### <a name="11111-software-environment"></a><span data-ttu-id="de3cf-1046">11.1.1.1 entorno de software</span><span class="sxs-lookup"><span data-stu-id="de3cf-1046">11.1.1.1      Software Environment</span></span>

-   <span data-ttu-id="de3cf-1047">Entorno de Software de Entity Framework 4</span><span class="sxs-lookup"><span data-stu-id="de3cf-1047">Entity Framework 4 Software Environment</span></span>
    -   <span data-ttu-id="de3cf-1048">Nombre del sistema operativo: Windows Server 2008 R2 SP1 Enterprise.</span><span class="sxs-lookup"><span data-stu-id="de3cf-1048">OS Name: Windows Server 2008 R2 Enterprise SP1.</span></span>
    -   <span data-ttu-id="de3cf-1049">Visual Studio 2010: Ultimate.</span><span class="sxs-lookup"><span data-stu-id="de3cf-1049">Visual Studio 2010 – Ultimate.</span></span>
    -   <span data-ttu-id="de3cf-1050">Visual Studio 2010 SP1 (solo para algunos comparaciones).</span><span class="sxs-lookup"><span data-stu-id="de3cf-1050">Visual Studio 2010 SP1 (only for some comparisons).</span></span>
-   <span data-ttu-id="de3cf-1051">Entorno de Software de Entity Framework 5 y 6</span><span class="sxs-lookup"><span data-stu-id="de3cf-1051">Entity Framework 5 and 6 Software Environment</span></span>
    -   <span data-ttu-id="de3cf-1052">Nombre del sistema operativo: Windows 8.1 Enterprise</span><span class="sxs-lookup"><span data-stu-id="de3cf-1052">OS Name: Windows 8.1 Enterprise</span></span>
    -   <span data-ttu-id="de3cf-1053">Visual Studio 2013: Ultimate.</span><span class="sxs-lookup"><span data-stu-id="de3cf-1053">Visual Studio 2013 – Ultimate.</span></span>

##### <a name="11112-hardware-environment"></a><span data-ttu-id="de3cf-1054">11.1.1.2 entorno de hardware</span><span class="sxs-lookup"><span data-stu-id="de3cf-1054">11.1.1.2      Hardware Environment</span></span>

-   <span data-ttu-id="de3cf-1055">Procesador dual: W3530 de Intel (r) Xeon (r) CPU L5520 a 2,27 GHz, 2261 Mhz8 GHz, 4 núcleos, 84 procesadores lógicos.</span><span class="sxs-lookup"><span data-stu-id="de3cf-1055">Dual Processor:     Intel(R) Xeon(R) CPU L5520 W3530 @ 2.27GHz, 2261 Mhz8 GHz, 4 Core(s), 84 Logical Processor(s).</span></span>
-   <span data-ttu-id="de3cf-1056">RamRAM de 2412 GB.</span><span class="sxs-lookup"><span data-stu-id="de3cf-1056">2412 GB RamRAM.</span></span>
-   <span data-ttu-id="de3cf-1057">136 GB SCSI250GB SATA 7200 rpm / 3GB/s unidad dividir en 4 particiones.</span><span class="sxs-lookup"><span data-stu-id="de3cf-1057">136 GB SCSI250GB SATA 7200 rpm 3GB/s drive split into 4 partitions.</span></span>

#### <a name="1112-db-server"></a><span data-ttu-id="de3cf-1058">11.1.2 servidor de base de datos</span><span class="sxs-lookup"><span data-stu-id="de3cf-1058">11.1.2       DB server</span></span>

##### <a name="11121-software-environment"></a><span data-ttu-id="de3cf-1059">11.1.2.1 entorno de software</span><span class="sxs-lookup"><span data-stu-id="de3cf-1059">11.1.2.1      Software Environment</span></span>

-   <span data-ttu-id="de3cf-1060">Nombre del sistema operativo: Windows Server 2008 R28.1 Enterprise SP1.</span><span class="sxs-lookup"><span data-stu-id="de3cf-1060">OS Name: Windows Server 2008 R28.1 Enterprise SP1.</span></span>
-   <span data-ttu-id="de3cf-1061">SQL Server 2008 R22012.</span><span class="sxs-lookup"><span data-stu-id="de3cf-1061">SQL Server 2008 R22012.</span></span>

##### <a name="11122-hardware-environment"></a><span data-ttu-id="de3cf-1062">11.1.2.2 entorno de hardware</span><span class="sxs-lookup"><span data-stu-id="de3cf-1062">11.1.2.2      Hardware Environment</span></span>

-   <span data-ttu-id="de3cf-1063">Único procesador: Intel (r) Xeon (r) CPU L5520 a 2,27 GHz, 2261 MhzES-1620 0 @ 3,60 GHz, 4 núcleos, 8 procesadores lógicos.</span><span class="sxs-lookup"><span data-stu-id="de3cf-1063">Single Processor: Intel(R) Xeon(R) CPU L5520  @ 2.27GHz, 2261 MhzES-1620 0 @ 3.60GHz, 4 Core(s), 8 Logical Processor(s).</span></span>
-   <span data-ttu-id="de3cf-1064">RamRAM de 824 GB.</span><span class="sxs-lookup"><span data-stu-id="de3cf-1064">824 GB RamRAM.</span></span>
-   <span data-ttu-id="de3cf-1065">465 GB ATA500GB SATA 7200 rpm 6GB/s unidad dividir en 4 particiones.</span><span class="sxs-lookup"><span data-stu-id="de3cf-1065">465 GB ATA500GB SATA 7200 rpm 6GB/s drive split into 4 partitions.</span></span>

### <a name="112-b-query-performance-comparison-tests"></a><span data-ttu-id="de3cf-1066">11.2 pruebas comparativas de rendimiento de consulta B.</span><span class="sxs-lookup"><span data-stu-id="de3cf-1066">11.2      B. Query performance comparison tests</span></span>

<span data-ttu-id="de3cf-1067">El modelo de Northwind se usó para ejecutar estas pruebas.</span><span class="sxs-lookup"><span data-stu-id="de3cf-1067">The Northwind model was used to execute these tests.</span></span> <span data-ttu-id="de3cf-1068">Se generó desde la base de datos mediante el Diseñador de Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="de3cf-1068">It was generated from the database using the Entity Framework designer.</span></span> <span data-ttu-id="de3cf-1069">A continuación, el código siguiente se usó para comparar el rendimiento de las opciones de ejecución de consulta:</span><span class="sxs-lookup"><span data-stu-id="de3cf-1069">Then, the following code was used to compare the performance of the query execution options:</span></span>

``` csharp
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.Common;
using System.Data.Entity.Infrastructure;
using System.Data.EntityClient;
using System.Data.Objects;
using System.Linq;

namespace QueryComparison
{
    public partial class NorthwindEntities : ObjectContext
    {
        private static readonly Func<NorthwindEntities, string, IQueryable<Product>> productsForCategoryCQ = CompiledQuery.Compile(
            (NorthwindEntities context, string categoryName) =>
                context.Products.Where(p => p.Category.CategoryName == categoryName)
                );

        public IQueryable<Product> InvokeProductsForCategoryCQ(string categoryName)
        {
            return productsForCategoryCQ(this, categoryName);
        }
    }

    public class QueryTypePerfComparison
    {
        private static string entityConnectionStr = @"metadata=res://*/Northwind.csdl|res://*/Northwind.ssdl|res://*/Northwind.msl;provider=System.Data.SqlClient;provider connection string='data source=.;initial catalog=Northwind;integrated security=True;multipleactiveresultsets=True;App=EntityFramework'";

        public void LINQIncludingContextCreation()
        {
            using (NorthwindEntities context = new NorthwindEntities())
            {                 
                var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
                q.ToList();
            }
        }

        public void LINQNoTracking()
        {
            using (NorthwindEntities context = new NorthwindEntities())
            {
                context.Products.MergeOption = MergeOption.NoTracking;

                var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
                q.ToList();
            }
        }

        public void CompiledQuery()
        {
            using (NorthwindEntities context = new NorthwindEntities())
            {
                var q = context.InvokeProductsForCategoryCQ("Beverages");
                q.ToList();
            }
        }

        public void ObjectQuery()
        {
            using (NorthwindEntities context = new NorthwindEntities())
            {
                ObjectQuery<Product> products = context.Products.Where("it.Category.CategoryName = 'Beverages'");
                products.ToList();
            }
        }

        public void EntityCommand()
        {
            using (EntityConnection eConn = new EntityConnection(entityConnectionStr))
            {
                eConn.Open();
                EntityCommand cmd = eConn.CreateCommand();
                cmd.CommandText = "Select p From NorthwindEntities.Products As p Where p.Category.CategoryName = 'Beverages'";

                using (EntityDataReader reader = cmd.ExecuteReader(CommandBehavior.SequentialAccess))
                {
                    List<Product> productsList = new List<Product>();
                    while (reader.Read())
                    {
                        DbDataRecord record = (DbDataRecord)reader.GetValue(0);

                        // 'materialize' the product by accessing each field and value. Because we are materializing products, we won't have any nested data readers or records.
                        int fieldCount = record.FieldCount;

                        // Treat all products as Product, even if they are the subtype DiscontinuedProduct.
                        Product product = new Product();  

                        product.ProductID = record.GetInt32(0);
                        product.ProductName = record.GetString(1);
                        product.SupplierID = record.GetInt32(2);
                        product.CategoryID = record.GetInt32(3);
                        product.QuantityPerUnit = record.GetString(4);
                        product.UnitPrice = record.GetDecimal(5);
                        product.UnitsInStock = record.GetInt16(6);
                        product.UnitsOnOrder = record.GetInt16(7);
                        product.ReorderLevel = record.GetInt16(8);
                        product.Discontinued = record.GetBoolean(9);

                        productsList.Add(product);
                    }
                }
            }
        }

        public void ExecuteStoreQuery()
        {
            using (NorthwindEntities context = new NorthwindEntities())
            {
                ObjectResult<Product> beverages = context.ExecuteStoreQuery<Product>(
@"    SELECT        P.ProductID, P.ProductName, P.SupplierID, P.CategoryID, P.QuantityPerUnit, P.UnitPrice, P.UnitsInStock, P.UnitsOnOrder, P.ReorderLevel, P.Discontinued
    FROM            Products AS P INNER JOIN Categories AS C ON P.CategoryID = C.CategoryID
    WHERE        (C.CategoryName = 'Beverages')"
);
                beverages.ToList();
            }
        }

        public void ExecuteStoreQueryDbContext()
        {
            using (var context = new QueryComparison.DbC.NorthwindEntities())
            {
                var beverages = context.Database.SqlQuery\<QueryComparison.DbC.Product>(
@"    SELECT        P.ProductID, P.ProductName, P.SupplierID, P.CategoryID, P.QuantityPerUnit, P.UnitPrice, P.UnitsInStock, P.UnitsOnOrder, P.ReorderLevel, P.Discontinued
    FROM            Products AS P INNER JOIN Categories AS C ON P.CategoryID = C.CategoryID
    WHERE        (C.CategoryName = 'Beverages')"
);
                beverages.ToList();
            }
        }

        public void ExecuteStoreQueryDbSet()
        {
            using (var context = new QueryComparison.DbC.NorthwindEntities())
            {
                var beverages = context.Products.SqlQuery(
@"    SELECT        P.ProductID, P.ProductName, P.SupplierID, P.CategoryID, P.QuantityPerUnit, P.UnitPrice, P.UnitsInStock, P.UnitsOnOrder, P.ReorderLevel, P.Discontinued
    FROM            Products AS P INNER JOIN Categories AS C ON P.CategoryID = C.CategoryID
    WHERE        (C.CategoryName = 'Beverages')"
);
                beverages.ToList();
            }
        }

        public void LINQIncludingContextCreationDbContext()
        {
            using (var context = new QueryComparison.DbC.NorthwindEntities())
            {                 
                var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
                q.ToList();
            }
        }

        public void LINQNoTrackingDbContext()
        {
            using (var context = new QueryComparison.DbC.NorthwindEntities())
            {
                var q = context.Products.AsNoTracking().Where(p => p.Category.CategoryName == "Beverages");
                q.ToList();
            }
        }
    }
}
```

### <a name="113-c-navision-model"></a><span data-ttu-id="de3cf-1070">C. 11.3 Navision modelo</span><span class="sxs-lookup"><span data-stu-id="de3cf-1070">11.3 C. Navision Model</span></span>

<span data-ttu-id="de3cf-1071">La base de datos Navision es una gran base de datos usa para la demostración de Microsoft Dynamics: barra de navegación.</span><span class="sxs-lookup"><span data-stu-id="de3cf-1071">The Navision database is a large database used to demo Microsoft Dynamics – NAV.</span></span> <span data-ttu-id="de3cf-1072">El modelo conceptual generado contiene conjuntos de entidades 1005 y 4227 conjuntos de asociaciones.</span><span class="sxs-lookup"><span data-stu-id="de3cf-1072">The generated conceptual model contains 1005 entity sets and 4227 association sets.</span></span> <span data-ttu-id="de3cf-1073">El modelo utilizado en la prueba no es "plano": se agregó ningún herencia a él.</span><span class="sxs-lookup"><span data-stu-id="de3cf-1073">The model used in the test is “flat” – no inheritance has been added to it.</span></span>

#### <a name="1131-queries-used-for-navision-tests"></a><span data-ttu-id="de3cf-1074">11.3.1 consultas que se usan para las pruebas de Navision</span><span class="sxs-lookup"><span data-stu-id="de3cf-1074">11.3.1 Queries used for Navision tests</span></span>

<span data-ttu-id="de3cf-1075">La lista de consultas que se usa con el modelo Navision contiene 3 categorías de las consultas de Entity SQL:</span><span class="sxs-lookup"><span data-stu-id="de3cf-1075">The queries list used with the Navision model contains 3 categories of Entity SQL queries:</span></span>

##### <a name="11311-lookup"></a><span data-ttu-id="de3cf-1076">11.3.1.1 búsqueda de</span><span class="sxs-lookup"><span data-stu-id="de3cf-1076">11.3.1.1 Lookup</span></span>

<span data-ttu-id="de3cf-1077">Una consulta de búsqueda simple sin agregaciones</span><span class="sxs-lookup"><span data-stu-id="de3cf-1077">A simple lookup query with no aggregations</span></span>

-   <span data-ttu-id="de3cf-1078">Recuento: 16232</span><span class="sxs-lookup"><span data-stu-id="de3cf-1078">Count: 16232</span></span>
-   <span data-ttu-id="de3cf-1079">Ejemplo:</span><span class="sxs-lookup"><span data-stu-id="de3cf-1079">Example:</span></span>

``` xml
  <Query complexity="Lookup">
    <CommandText>Select value distinct top(4) e.Idle_Time From NavisionFKContext.Session as e</CommandText>
  </Query>
```

##### <a name="11312singleaggregating"></a><span data-ttu-id="de3cf-1080">11.3.1.2 SingleAggregating</span><span class="sxs-lookup"><span data-stu-id="de3cf-1080">11.3.1.2 SingleAggregating</span></span>

<span data-ttu-id="de3cf-1081">Una consulta de BI normal con varias agregaciones, pero no los subtotales (consulta individual)</span><span class="sxs-lookup"><span data-stu-id="de3cf-1081">A normal BI query with multiple aggregations, but no subtotals (single query)</span></span>

-   <span data-ttu-id="de3cf-1082">Recuento: 2313</span><span class="sxs-lookup"><span data-stu-id="de3cf-1082">Count: 2313</span></span>
-   <span data-ttu-id="de3cf-1083">Ejemplo:</span><span class="sxs-lookup"><span data-stu-id="de3cf-1083">Example:</span></span>

``` xml
  <Query complexity="SingleAggregating">
    <CommandText>NavisionFK.MDF_SessionLogin_Time_Max()</CommandText>
  </Query>
```

<span data-ttu-id="de3cf-1084">Donde MDF\_SessionLogin\_tiempo\_Max() se define en el modelo como:</span><span class="sxs-lookup"><span data-stu-id="de3cf-1084">Where MDF\_SessionLogin\_Time\_Max() is defined in the model as:</span></span>

``` xml
  <Function Name="MDF_SessionLogin_Time_Max" ReturnType="Collection(DateTime)">
    <DefiningExpression>SELECT VALUE Edm.Min(E.Login_Time) FROM NavisionFKContext.Session as E</DefiningExpression>
  </Function>
```

##### <a name="11313aggregatingsubtotals"></a><span data-ttu-id="de3cf-1085">11.3.1.3 AggregatingSubtotals</span><span class="sxs-lookup"><span data-stu-id="de3cf-1085">11.3.1.3 AggregatingSubtotals</span></span>

<span data-ttu-id="de3cf-1086">Una consulta de BI con las agregaciones y subtotales (a través de la unión de todos)</span><span class="sxs-lookup"><span data-stu-id="de3cf-1086">A BI query with aggregations and subtotals (via union all)</span></span>

-   <span data-ttu-id="de3cf-1087">Recuento: 178</span><span class="sxs-lookup"><span data-stu-id="de3cf-1087">Count: 178</span></span>
-   <span data-ttu-id="de3cf-1088">Ejemplo:</span><span class="sxs-lookup"><span data-stu-id="de3cf-1088">Example:</span></span>

``` xml
  <Query complexity="AggregatingSubtotals">
    <CommandText>
using NavisionFK;
function AmountConsumed(entities Collection([CRONUS_International_Ltd__Zone])) as
(
    Edm.Sum(select value N.Block_Movement FROM entities as E, E.CRONUS_International_Ltd__Bin as N)
)
function AmountConsumed(P1 Edm.Int32) as
(
    AmountConsumed(select value e from NavisionFKContext.CRONUS_International_Ltd__Zone as e where e.Zone_Ranking = P1)
)
----------------------------------------------------------------------------------------------------------------------
(
    select top(10) Zone_Ranking, Cross_Dock_Bin_Zone, AmountConsumed(GroupPartition(E))
    from NavisionFKContext.CRONUS_International_Ltd__Zone as E
    where AmountConsumed(E.Zone_Ranking) > @MinAmountConsumed
    group by E.Zone_Ranking, E.Cross_Dock_Bin_Zone
)
union all
(
    select top(10) Zone_Ranking, Cast(null as Edm.Byte) as P2, AmountConsumed(GroupPartition(E))
    from NavisionFKContext.CRONUS_International_Ltd__Zone as E
    where AmountConsumed(E.Zone_Ranking) > @MinAmountConsumed
    group by E.Zone_Ranking
)
union all
{
    Row(Cast(null as Edm.Int32) as P1, Cast(null as Edm.Byte) as P2, AmountConsumed(select value E
                                                                         from NavisionFKContext.CRONUS_International_Ltd__Zone as E
                                                                         where AmountConsumed(E.Zone_Ranking) > @MinAmountConsumed))
}</CommandText>
    <Parameters>
      <Parameter Name="MinAmountConsumed" DbType="Int32" Value="10000" />
    </Parameters>
  </Query>
```
